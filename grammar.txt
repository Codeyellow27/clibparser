==== RULE ====
abstractDeclarator => ( pointer | [ pointer ] directAbstractDeclarator )
additiveExpression => [ additiveExpression ( '+' | '-' ) ] multiplicativeExpression
andExpression => [ andExpression '&' ] equalityExpression
argumentExpressionList => [ argumentExpressionList ',' ] assignmentExpression
assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator assignmentExpression )
assignmentOperator => ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' )
blockItem => ( statement | declaration )
blockItemList => [ blockItemList ] blockItem
castExpression => ( '(' typeName ')' castExpression | unaryExpression )
compilationUnit => translationUnit [ compilationUnit ]
compoundStatement => '{' [ blockItemList ] '}'
conditionalExpression => logicalOrExpression [ '?' expression '=' conditionalExpression ]
constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #float# | #double# )
constantExpression => conditionalExpression
declaration => declarationSpecifiers [ initDeclaratorList ] ';'
declarationList => [ declarationList ] declaration
declarationSpecifier => ( storageClassSpecifier | typeSpecifier | typeQualifier )
declarationSpecifiers => declarationSpecifier [ declarationSpecifiers ]
declarationSpecifiers2 => declarationSpecifier [ declarationSpecifiers ]
declarator => [ pointer ] directDeclarator
designation => designatorList '='
designator => ( '[' constantExpression ']' | '.' #identifier# )
designatorList => [ designatorList ] designator
directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [
assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList ] ( assignmentExpre
ssion | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
enumSpecifier => enum ( [ #identifier# ] '{' enumeratorList [ ',' ] '{' | #identifier# )
enumerationConstant => #identifier#
enumerator => enumerationConstant [ '=' constantExpression ]
enumeratorList => [ enumeratorList ',' ] enumerator
equalityExpression => [ equalityExpression ( '==' | '!=' ) ] relationalExpression
exclusiveOrExpression => [ exclusiveOrExpression '^' ] andExpression
expression => [ expression ',' ] assignmentExpression
expressionStatement => [ expression ] ';'
externalDeclaration => ( functionDefinition | declaration | ';' )
forCondition => ( forDeclaration | [ expression ] ) ';' [ forExpression ] ';' [ forExpression ]
forDeclaration => declarationSpecifiers [ initDeclaratorList ]
forExpression => [ forExpression ',' ] assignmentExpression
functionDefinition => [ declarationSpecifiers ] declarator [ declarationList ] compoundStatement
identifierList => [ identifierList ',' ] #identifier#
inclusiveOrExpression => [ inclusiveOrExpression '|' ] exclusiveOrExpression
initDeclarator => declarator [ '=' initializer ]
initDeclaratorList => [ initDeclaratorList ',' ] initDeclarator
initializer => ( assignmentExpression | '{' initializerList [ ',' ] '}' )
initializerList => [ initializerList ',' ] [ designation ] initializer
iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' ';' | for '(' forCond
ition ')' statement )
jumpStatement => ( goto #identifier# ';' | continue ';' | break ';' | return [ expression ] ';' )
labeledStatement => ( #identifier# | case constantExpression | default ) '=' statement
logicalAndExpression => [ logicalAndExpression '&&' ] inclusiveOrExpression
logicalOrExpression => [ logicalOrExpression '||' ] logicalAndExpression
multiplicativeExpression => ( castExpression | multiplicativeExpression ( '*' castExpression | '/' castExpression | '%'
castExpression ) )
parameterDeclaration => ( declarationSpecifiers declarator | declarationSpecifiers2 [ abstractDeclarator ] )
parameterList => [ parameterList ',' ] parameterDeclaration
parameterTypeList => parameterList [ ',' '...' ]
pointer => [ typeQualifierList ] [ pointer ] ( '*' | '^' )
postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpressionList ] ')' |
 '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}' )
primaryExpression => ( #identifier# | constant | #string# | '(' expression ')' )
program => compilationUnit
relationalExpression => [ relationalExpression ( '<' | '>' | '<=' | '>=' ) ] shiftExpression
selectionStatement => ( if '(' expression ')' statement [ else statement ] | switch '(' expression ')' statement )
shiftExpression => [ shiftExpression ( '<<' | '>>' ) ] additiveExpression
specifierQualifierList => ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationStatement | ju
mpStatement )
storageClassSpecifier => ( typedef | extern | static | auto | register )
structDeclaration => specifierQualifierList [ structDeclaratorList ] ';'
structDeclarationList => [ structDeclarationList ] structDeclaration
structDeclarator => ( declarator | [ declarator ] '=' constantExpression )
structDeclaratorList => [ structDeclaratorList ',' ] structDeclarator
structOrUnion => ( struct | union )
structOrUnionSpecifier => structOrUnion ( #identifier# | [ #identifier# ] '{' structDeclarationList '}' )
translationUnit => [ translationUnit ] externalDeclaration
typeName => specifierQualifierList [ abstractDeclarator ]
typeQualifier => ( const | volatile )
typeQualifierList => [ typeQualifierList ] typeQualifier
typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier
 | enumSpecifier | typedefName | typeSpecifier pointer )
typedefName => #identifier#
unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unary
Expression | '(' typeName ')' ) )
unaryOperator => ( '&' | '*' | '+' | '-' | '~' | '!' )
==== NGA  ====
** Rule: abstractDeclarator => ( pointer | [ pointer ] directAbstractDeclarator )
-- Tokens: '[' '(' '*' '^' const volatile
-- First-set tokens: volatile const '^' '*' '(' '['
-- First-set rules: directAbstractDeclarator pointer
Status #0 - abstractDeclarator => @ ( pointer | [ pointer ] directAbstractDeclarator )
  To #1:  directAbstractDeclarator
  To #2:  pointer
  To #3:  pointer
Status #1 [FINAL] - abstractDeclarator => ( pointer | [ pointer ] directAbstractDeclarator @ )
Status #2 [FINAL] - abstractDeclarator => ( pointer @ | [ pointer ] directAbstractDeclarator )
Status #3 - abstractDeclarator => ( pointer | [ pointer @ ] directAbstractDeclarator )
  To #1:  directAbstractDeclarator

** Rule: additiveExpression => [ additiveExpression ( '+' | '-' ) ] multiplicativeExpression
-- Tokens: #double# '&' '*' #uint# '+' #uchar# #float# '~' #short# '(' '-' #ushort# '++' '--' '!' #int# #char# sizeof #s
tring# #identifier# #long# #ulong#
-- First-set tokens: #double# #uint# #uchar# #float# '~' '+' #short# '(' #ushort# '++' '--' '!' '-' #int# #char# sizeof
#string# '&' #identifier# '*' #long# #ulong#
-- First-set rules: multiplicativeExpression additiveExpression
Status #0 - additiveExpression => [ @ additiveExpression ( '+' | '-' ) ] multiplicativeExpression
  To #1:  additiveExpression
  To #2:  multiplicativeExpression
Status #1 - additiveExpression => [ additiveExpression @ ( '+' | '-' ) ] multiplicativeExpression
  To #3:  '-'
  To #4:  '+'
Status #2 [FINAL] - additiveExpression => [ additiveExpression ( '+' | '-' ) ] multiplicativeExpression @
Status #3 - additiveExpression => [ additiveExpression ( '+' | '-' @ ) ] multiplicativeExpression
  To #2:  multiplicativeExpression
Status #4 - additiveExpression => [ additiveExpression ( '+' @ | '-' ) ] multiplicativeExpression
  To #2:  multiplicativeExpression

** Rule: andExpression => [ andExpression '&' ] equalityExpression
-- Tokens: #double# '&' '*' #uint# '+' #uchar# #float# '~' #short# '(' '-' #ushort# '++' '--' '!' #int# #char# sizeof #s
tring# #identifier# #long# #ulong#
-- First-set tokens: #double# #uint# #uchar# #float# '~' '+' #short# '(' #ushort# '++' '--' '!' '-' #int# #char# sizeof
#string# '&' #identifier# '*' #long# #ulong#
-- First-set rules: equalityExpression andExpression
Status #0 - andExpression => [ @ andExpression '&' ] equalityExpression
  To #1:  andExpression
  To #2:  equalityExpression
Status #1 - andExpression => [ andExpression @ '&' ] equalityExpression
  To #3:  '&'
Status #2 [FINAL] - andExpression => [ andExpression '&' ] equalityExpression @
Status #3 - andExpression => [ andExpression '&' @ ] equalityExpression
  To #2:  equalityExpression

** Rule: argumentExpressionList => [ argumentExpressionList ',' ] assignmentExpression
-- Tokens: #float# #ulong# #long# #int# #char# #identifier# #string# sizeof '!' '--' '++' '-' #ushort# '(' #short# '~' '
+' #uchar# '*' #uint# '&' #double#
-- First-set tokens: #float# #ulong# #char# #string# sizeof '!' '--' '++' #int# '-' #ushort# '(' '~' #short# '+' #uchar#
 #long# '*' #uint# #identifier# '&' #double#
-- First-set rules: assignmentExpression argumentExpressionList
Status #0 - argumentExpressionList => [ @ argumentExpressionList ',' ] assignmentExpression
  To #1:  argumentExpressionList
  To #2:  assignmentExpression
Status #1 - argumentExpressionList => [ argumentExpressionList @ ',' ] assignmentExpression
  To #3:  ','
Status #2 [FINAL] - argumentExpressionList => [ argumentExpressionList ',' ] assignmentExpression @
Status #3 - argumentExpressionList => [ argumentExpressionList ',' @ ] assignmentExpression
  To #2:  assignmentExpression

** Rule: assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator assignmentExpression )
-- Tokens: #float# #ulong# #long# #int# #char# #identifier# #string# sizeof '!' '--' '++' '-' #ushort# '(' #short# '~' '
+' #uchar# '*' #uint# '&' #double#
-- First-set tokens: #double# #uint# #uchar# '~' '+' #short# '(' #ushort# '++' '--' '!' sizeof #string# '&' #identifier#
 #char# '-' #int# '*' #long# #ulong# #float#
-- First-set rules: unaryExpression conditionalExpression
Status #0 - assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExpression
)
  To #1:  unaryExpression
  To #2:  conditionalExpression
Status #1 - assignmentExpression => ( conditionalExpression | unaryExpression @ assignmentOperator assignmentExpression
)
  To #3:  assignmentOperator
Status #2 [FINAL] - assignmentExpression => ( conditionalExpression @ | unaryExpression assignmentOperator assignmentExp
ression )
Status #3 - assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator @ assignmentExpression
)
  To #4:  assignmentExpression
Status #4 [FINAL] - assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator assignmentExpre
ssion @ )

** Rule: assignmentOperator => ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' )
-- Tokens: '/=' '%=' '*=' '=' '<<=' '+=' '-=' '>>='
-- First-set tokens: '>>=' '-=' '+=' '<<=' '=' '*=' '%=' '/='
-- First-set rules:
Status #0 - assignmentOperator => @ ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' )
  To #1:  '>>='
  To #2:  '='
  To #3:  '*='
  To #4:  '/='
  To #5:  '%='
  To #6:  '+='
  To #7:  '-='
  To #8:  '<<='
Status #1 [FINAL] - assignmentOperator => ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' @ )
Status #2 [FINAL] - assignmentOperator => ( '=' @ | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' )
Status #3 [FINAL] - assignmentOperator => ( '=' | '*=' @ | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' )
Status #4 [FINAL] - assignmentOperator => ( '=' | '*=' | '/=' @ | '%=' | '+=' | '-=' | '<<=' | '>>=' )
Status #5 [FINAL] - assignmentOperator => ( '=' | '*=' | '/=' | '%=' @ | '+=' | '-=' | '<<=' | '>>=' )
Status #6 [FINAL] - assignmentOperator => ( '=' | '*=' | '/=' | '%=' | '+=' @ | '-=' | '<<=' | '>>=' )
Status #7 [FINAL] - assignmentOperator => ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' @ | '<<=' | '>>=' )
Status #8 [FINAL] - assignmentOperator => ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' @ | '>>=' )

** Rule: blockItem => ( statement | declaration )
-- Tokens: register typedef #long# extern static #short# auto signed #char# #identifier# volatile const '{' short void #
double# double unsigned #float# float '--' long char bool int enum ';' struct #ushort# union #ulong# switch #int# return
 continue while #string# '(' case default '*' goto for break '~' '-' '!' do '&' sizeof #uchar# '++' if '+' #uint#
-- First-set tokens: #uint# '+' if '++' #uchar# sizeof '&' do '!' '-' '~' break for goto '*' default case '(' #string# w
hile continue return #int# switch #ulong# union #ushort# struct ';' enum int bool char long '--' float #float# unsigned
double #double# void short '{' const volatile #identifier# #char# signed auto #short# static extern #long# typedef regis
ter
-- First-set rules: declaration statement
Status #0 - blockItem => @ ( statement | declaration )
  To #1:  declaration
  To #2:  statement
Status #1 [FINAL] - blockItem => ( statement | declaration @ )
Status #2 [FINAL] - blockItem => ( statement @ | declaration )

** Rule: blockItemList => [ blockItemList ] blockItem
-- Tokens: register typedef #long# extern static #short# auto signed #char# #identifier# volatile const '{' short void #
double# double unsigned #float# float '--' long char bool int enum ';' struct #ushort# union #ulong# switch #int# return
 continue while #string# '(' case default '*' goto for break '~' '-' '!' do '&' sizeof #uchar# '++' if '+' #uint#
-- First-set tokens: register typedef #long# extern static #short# auto signed #char# #identifier# volatile const '{' sh
ort void #double# double unsigned #float# float '--' long char bool int enum ';' struct #ushort# union #ulong# switch #i
nt# return continue while #string# '(' case default '*' goto for break '~' '-' '!' do '&' sizeof #uchar# '++' if '+' #ui
nt#
-- First-set rules: blockItem blockItemList
Status #0 - blockItemList => [ @ blockItemList ] blockItem
  To #1:  blockItemList
  To #2:  blockItem
Status #1 - blockItemList => [ blockItemList @ ] blockItem
  To #2:  blockItem
Status #2 [FINAL] - blockItemList => [ blockItemList ] blockItem @

** Rule: castExpression => ( '(' typeName ')' castExpression | unaryExpression )
-- Tokens: #double# '&' '*' #uint# '+' #uchar# #float# '~' #short# '(' '-' #ushort# '++' '--' '!' #int# #char# sizeof #s
tring# #identifier# #long# #ulong#
-- First-set tokens: #ulong# #long# #identifier# #string# #char# sizeof #int# '!' '--' '++' #ushort# '-' #short# #float#
 '~' #uchar# '+' #uint# '*' '&' #double# '('
-- First-set rules: unaryExpression
Status #0 - castExpression => @ ( '(' typeName ')' castExpression | unaryExpression )
  To #1:  unaryExpression
  To #2:  '('
Status #1 [FINAL] - castExpression => ( '(' typeName ')' castExpression | unaryExpression @ )
Status #2 - castExpression => ( '(' @ typeName ')' castExpression | unaryExpression )
  To #3:  typeName
Status #3 - castExpression => ( '(' typeName @ ')' castExpression | unaryExpression )
  To #4:  ')'
Status #4 - castExpression => ( '(' typeName ')' @ castExpression | unaryExpression )
  To #5:  castExpression
Status #5 [FINAL] - castExpression => ( '(' typeName ')' castExpression @ | unaryExpression )

** Rule: compilationUnit => translationUnit [ compilationUnit ]
-- Tokens: static typedef auto signed #identifier# const short void double unsigned float long int enum struct union boo
l volatile char '(' register '^' extern ';' '*'
-- First-set tokens: '*' ';' extern '^' register '(' char volatile bool union struct enum int long float unsigned double
 void short const #identifier# signed auto typedef static
-- First-set rules: translationUnit
Status #0 - compilationUnit => @ translationUnit [ compilationUnit ]
  To #1:  translationUnit
Status #1 [FINAL] - compilationUnit => translationUnit @ [ compilationUnit ]
  To #2:  compilationUnit
Status #2 [FINAL] - compilationUnit => translationUnit [ compilationUnit @ ]

** Rule: compoundStatement => '{' [ blockItemList ] '}'
-- Tokens: '{'
-- First-set tokens: '{'
-- First-set rules:
Status #0 - compoundStatement => @ '{' [ blockItemList ] '}'
  To #1:  '{'
Status #1 - compoundStatement => '{' @ [ blockItemList ] '}'
  To #2:  '}'
  To #3:  blockItemList
Status #2 [FINAL] - compoundStatement => '{' [ blockItemList ] '}' @
Status #3 - compoundStatement => '{' [ blockItemList @ ] '}'
  To #2:  '}'

** Rule: conditionalExpression => logicalOrExpression [ '?' expression '=' conditionalExpression ]
-- Tokens: #double# '&' '*' #uint# '+' #uchar# #float# '~' #short# '(' '-' #ushort# '++' '--' '!' #int# #char# sizeof #s
tring# #identifier# #long# #ulong#
-- First-set tokens: #ulong# #long# #identifier# #string# sizeof #char# #int# '!' '--' '++' #ushort# '-' '(' #short# '~'
 #float# #uchar# '+' #uint# '*' '&' #double#
-- First-set rules: logicalOrExpression
Status #0 - conditionalExpression => @ logicalOrExpression [ '?' expression '=' conditionalExpression ]
  To #1:  logicalOrExpression
Status #1 [FINAL] - conditionalExpression => logicalOrExpression @ [ '?' expression '=' conditionalExpression ]
  To #2:  '?'
Status #2 - conditionalExpression => logicalOrExpression [ '?' @ expression '=' conditionalExpression ]
  To #3:  expression
Status #3 - conditionalExpression => logicalOrExpression [ '?' expression @ '=' conditionalExpression ]
  To #4:  '='
Status #4 - conditionalExpression => logicalOrExpression [ '?' expression '=' @ conditionalExpression ]
  To #5:  conditionalExpression
Status #5 [FINAL] - conditionalExpression => logicalOrExpression [ '?' expression '=' conditionalExpression @ ]

** Rule: constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #float# | #double# )
-- Tokens: #ushort# #short# #uchar# #char# #int# #uint# #long# #ulong# #float# #double#
-- First-set tokens: #double# #float# #ulong# #long# #uint# #int# #char# #uchar# #short# #ushort#
-- First-set rules:
Status #0 - constant => @ ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #float# | #doubl
e# )
  To #1:  #double#
  To #2:  #char#
  To #3:  #uchar#
  To #4:  #short#
  To #5:  #ushort#
  To #6:  #int#
  To #7:  #uint#
  To #8:  #long#
  To #9:  #ulong#
  To #10:  #float#
Status #1 [FINAL] - constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #float# |
#double# @ )
Status #2 [FINAL] - constant => ( #char# @ | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #float#
| #double# )
Status #3 [FINAL] - constant => ( #char# | #uchar# @ | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #float#
| #double# )
Status #4 [FINAL] - constant => ( #char# | #uchar# | #short# @ | #ushort# | #int# | #uint# | #long# | #ulong# | #float#
| #double# )
Status #5 [FINAL] - constant => ( #char# | #uchar# | #short# | #ushort# @ | #int# | #uint# | #long# | #ulong# | #float#
| #double# )
Status #6 [FINAL] - constant => ( #char# | #uchar# | #short# | #ushort# | #int# @ | #uint# | #long# | #ulong# | #float#
| #double# )
Status #7 [FINAL] - constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# @ | #long# | #ulong# | #float#
| #double# )
Status #8 [FINAL] - constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# @ | #ulong# | #float#
| #double# )
Status #9 [FINAL] - constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# @ | #float#
| #double# )
Status #10 [FINAL] - constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #float# @
 | #double# )

** Rule: constantExpression => conditionalExpression
-- Tokens: #double# '&' '*' #uint# '+' #uchar# #float# '~' #short# '(' '-' #ushort# '++' '--' '!' #int# #char# sizeof #s
tring# #identifier# #long# #ulong#
-- First-set tokens: #ulong# #long# #identifier# #string# sizeof #char# #int# '!' '--' '++' #ushort# '-' '(' #short# '~'
 #float# #uchar# '+' #uint# '*' '&' #double#
-- First-set rules: conditionalExpression
Status #0 - constantExpression => @ conditionalExpression
  To #1:  conditionalExpression
Status #1 [FINAL] - constantExpression => conditionalExpression @

** Rule: declaration => declarationSpecifiers [ initDeclaratorList ] ';'
-- Tokens: union struct enum int bool char long float unsigned double void short const volatile #identifier# signed auto
 static extern typedef register
-- First-set tokens: register typedef extern static auto signed #identifier# volatile const short void double unsigned f
loat long char bool int enum struct union
-- First-set rules: declarationSpecifiers
Status #0 - declaration => @ declarationSpecifiers [ initDeclaratorList ] ';'
  To #1:  declarationSpecifiers
Status #1 - declaration => declarationSpecifiers @ [ initDeclaratorList ] ';'
  To #2:  ';'
  To #3:  initDeclaratorList
Status #2 [FINAL] - declaration => declarationSpecifiers [ initDeclaratorList ] ';' @
Status #3 - declaration => declarationSpecifiers [ initDeclaratorList @ ] ';'
  To #2:  ';'

** Rule: declarationList => [ declarationList ] declaration
-- Tokens: union struct enum int bool char long float unsigned double void short const volatile #identifier# signed auto
 static extern typedef register
-- First-set tokens: union struct enum int bool char long float unsigned double void short const volatile #identifier# s
igned auto static extern typedef register
-- First-set rules: declaration declarationList
Status #0 - declarationList => [ @ declarationList ] declaration
  To #1:  declarationList
  To #2:  declaration
Status #1 - declarationList => [ declarationList @ ] declaration
  To #2:  declaration
Status #2 [FINAL] - declarationList => [ declarationList ] declaration @

** Rule: declarationSpecifier => ( storageClassSpecifier | typeSpecifier | typeQualifier )
-- Tokens: union struct enum int bool char long float unsigned double void short const volatile #identifier# signed auto
 static extern typedef register
-- First-set tokens: register typedef extern static auto volatile const short signed void unsigned float long char bool
#identifier# int enum double struct union
-- First-set rules: typeQualifier typeSpecifier storageClassSpecifier
Status #0 - declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
  To #1:  typeQualifier
  To #2:  storageClassSpecifier
  To #3:  typeSpecifier
Status #1 [FINAL] - declarationSpecifier => ( storageClassSpecifier | typeSpecifier | typeQualifier @ )
Status #2 [FINAL] - declarationSpecifier => ( storageClassSpecifier @ | typeSpecifier | typeQualifier )
Status #3 [FINAL] - declarationSpecifier => ( storageClassSpecifier | typeSpecifier @ | typeQualifier )

** Rule: declarationSpecifiers => declarationSpecifier [ declarationSpecifiers ]
-- Tokens: union struct enum int bool char long float unsigned double void short const volatile #identifier# signed auto
 static extern typedef register
-- First-set tokens: register typedef extern static auto signed #identifier# volatile const short void double unsigned f
loat long char bool int enum struct union
-- First-set rules: declarationSpecifier
Status #0 - declarationSpecifiers => @ declarationSpecifier [ declarationSpecifiers ]
  To #1:  declarationSpecifier
Status #1 [FINAL] - declarationSpecifiers => declarationSpecifier @ [ declarationSpecifiers ]
  To #2:  declarationSpecifiers
Status #2 [FINAL] - declarationSpecifiers => declarationSpecifier [ declarationSpecifiers @ ]

** Rule: declarationSpecifiers2 => declarationSpecifier [ declarationSpecifiers ]
-- Tokens: union struct enum int bool char long float unsigned double void short const volatile #identifier# signed auto
 static extern typedef register
-- First-set tokens: register typedef extern static auto signed #identifier# volatile const short void double unsigned f
loat long char bool int enum struct union
-- First-set rules: declarationSpecifier
Status #0 - declarationSpecifiers2 => @ declarationSpecifier [ declarationSpecifiers ]
  To #1:  declarationSpecifier
Status #1 [FINAL] - declarationSpecifiers2 => declarationSpecifier @ [ declarationSpecifiers ]
  To #2:  declarationSpecifiers
Status #2 [FINAL] - declarationSpecifiers2 => declarationSpecifier [ declarationSpecifiers @ ]

** Rule: declarator => [ pointer ] directDeclarator
-- Tokens: '(' '*' #identifier# '^' const volatile
-- First-set tokens: volatile const '^' #identifier# '*' '('
-- First-set rules: directDeclarator pointer
Status #0 - declarator => [ @ pointer ] directDeclarator
  To #1:  pointer
  To #2:  directDeclarator
Status #1 - declarator => [ pointer @ ] directDeclarator
  To #2:  directDeclarator
Status #2 [FINAL] - declarator => [ pointer ] directDeclarator @

** Rule: designation => designatorList '='
-- Tokens: '[' '.'
-- First-set tokens: '.' '['
-- First-set rules: designatorList
Status #0 - designation => @ designatorList '='
  To #1:  designatorList
Status #1 - designation => designatorList @ '='
  To #2:  '='
Status #2 [FINAL] - designation => designatorList '=' @

** Rule: designator => ( '[' constantExpression ']' | '.' #identifier# )
-- Tokens: '[' '.'
-- First-set tokens: '.' '['
-- First-set rules:
Status #0 - designator => @ ( '[' constantExpression ']' | '.' #identifier# )
  To #1:  '.'
  To #2:  '['
Status #1 - designator => ( '[' constantExpression ']' | '.' @ #identifier# )
  To #3:  #identifier#
Status #2 - designator => ( '[' @ constantExpression ']' | '.' #identifier# )
  To #4:  constantExpression
Status #3 [FINAL] - designator => ( '[' constantExpression ']' | '.' #identifier# @ )
Status #4 - designator => ( '[' constantExpression @ ']' | '.' #identifier# )
  To #5:  ']'
Status #5 [FINAL] - designator => ( '[' constantExpression ']' @ | '.' #identifier# )

** Rule: designatorList => [ designatorList ] designator
-- Tokens: '[' '.'
-- First-set tokens: '[' '.'
-- First-set rules: designator designatorList
Status #0 - designatorList => [ @ designatorList ] designator
  To #1:  designatorList
  To #2:  designator
Status #1 - designatorList => [ designatorList @ ] designator
  To #2:  designator
Status #2 [FINAL] - designatorList => [ designatorList ] designator @

** Rule: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQualifier
List ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
-- Tokens: '(' '['
-- First-set tokens: '[' '('
-- First-set rules: directAbstractDeclarator
Status #0 - directAbstractDeclarator => @ ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQual
ifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
  To #1:  '('
  To #2:  '('
  To #3:  directAbstractDeclarator
  To #4:  '['
Status #1 - directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQualif
ierList ] [ assignmentExpression ] | '*' ) ']' | '(' @ [ parameterTypeList ] ')' ) )
  To #5:  ')'
  To #6:  parameterTypeList
Status #2 - directAbstractDeclarator => ( '(' @ abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQual
ifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
  To #7:  abstractDeclarator
Status #3 - directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator @ ] ( '[' ( [ typeQual
ifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
  To #1:  '('
  To #4:  '['
Status #4 - directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' @ ( [ typeQual
ifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
  To #8:  ']'
  To #9:  typeQualifierList
  To #10:  '*'
  To #11:  assignmentExpression
Status #5 [FINAL] - directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ ty
peQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' @ ) )
Status #6 - directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQualif
ierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList @ ] ')' ) )
  To #5:  ')'
Status #7 - directAbstractDeclarator => ( '(' abstractDeclarator @ ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQual
ifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
  To #12:  ')'
Status #8 [FINAL] - directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ ty
peQualifierList ] [ assignmentExpression ] | '*' ) ']' @ | '(' [ parameterTypeList ] ')' ) )
Status #9 - directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQualif
ierList @ ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
  To #8:  ']'
  To #11:  assignmentExpression
Status #10 - directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQuali
fierList ] [ assignmentExpression ] | '*' @ ) ']' | '(' [ parameterTypeList ] ')' ) )
  To #8:  ']'
Status #11 - directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQuali
fierList ] [ assignmentExpression @ ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
  To #8:  ']'
Status #12 [FINAL] - directAbstractDeclarator => ( '(' abstractDeclarator ')' @ | [ directAbstractDeclarator ] ( '[' ( [
 typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )

** Rule: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList ] ( assign
mentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
-- Tokens: #identifier# '('
-- First-set tokens: '(' #identifier#
-- First-set rules: directDeclarator
Status #0 - directDeclarator => @ ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList ] ( a
ssignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
  To #1:  directDeclarator
  To #2:  #identifier#
  To #3:  '('
Status #1 - directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator @ ( '[' [ typeQualifierList ] ( a
ssignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
  To #4:  '('
  To #5:  '['
Status #2 [FINAL] - directDeclarator => ( #identifier# @ | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierLi
st ] ( assignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
Status #3 - directDeclarator => ( #identifier# | '(' @ declarator ')' | directDeclarator ( '[' [ typeQualifierList ] ( a
ssignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
  To #6:  declarator
Status #4 - directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList ] ( ass
ignmentExpression | '*' ) ']' | '(' @ ( parameterTypeList | [ identifierList ] ) ')' ) )
  To #7:  ')'
  To #8:  parameterTypeList
  To #9:  identifierList
Status #5 - directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' @ [ typeQualifierList ] ( a
ssignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
  To #10:  '*'
  To #11:  typeQualifierList
  To #12:  assignmentExpression
Status #6 - directDeclarator => ( #identifier# | '(' declarator @ ')' | directDeclarator ( '[' [ typeQualifierList ] ( a
ssignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
  To #13:  ')'
Status #7 [FINAL] - directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList
 ] ( assignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' @ ) )
Status #8 - directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList ] ( ass
ignmentExpression | '*' ) ']' | '(' ( parameterTypeList @ | [ identifierList ] ) ')' ) )
  To #7:  ')'
Status #9 - directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList ] ( ass
ignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList @ ] ) ')' ) )
  To #7:  ')'
Status #10 - directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList ] ( as
signmentExpression | '*' @ ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
  To #14:  ']'
Status #11 - directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList @ ] (
assignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
  To #10:  '*'
  To #12:  assignmentExpression
Status #12 - directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList ] ( as
signmentExpression @ | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
  To #14:  ']'
Status #13 [FINAL] - directDeclarator => ( #identifier# | '(' declarator ')' @ | directDeclarator ( '[' [ typeQualifierL
ist ] ( assignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
Status #14 [FINAL] - directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierLis
t ] ( assignmentExpression | '*' ) ']' @ | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )

** Rule: enumSpecifier => enum ( [ #identifier# ] '{' enumeratorList [ ',' ] '{' | #identifier# )
-- Tokens: enum
-- First-set tokens: enum
-- First-set rules:
Status #0 - enumSpecifier => @ enum ( [ #identifier# ] '{' enumeratorList [ ',' ] '{' | #identifier# )
  To #1:  enum
Status #1 - enumSpecifier => enum @ ( [ #identifier# ] '{' enumeratorList [ ',' ] '{' | #identifier# )
  To #2:  '{'
  To #3:  #identifier#
  To #4:  #identifier#
Status #2 - enumSpecifier => enum ( [ #identifier# ] '{' @ enumeratorList [ ',' ] '{' | #identifier# )
  To #5:  enumeratorList
Status #3 - enumSpecifier => enum ( [ #identifier# @ ] '{' enumeratorList [ ',' ] '{' | #identifier# )
  To #2:  '{'
Status #4 [FINAL] - enumSpecifier => enum ( [ #identifier# ] '{' enumeratorList [ ',' ] '{' | #identifier# @ )
Status #5 - enumSpecifier => enum ( [ #identifier# ] '{' enumeratorList @ [ ',' ] '{' | #identifier# )
  To #6:  '{'
  To #7:  ','
Status #6 [FINAL] - enumSpecifier => enum ( [ #identifier# ] '{' enumeratorList [ ',' ] '{' @ | #identifier# )
Status #7 - enumSpecifier => enum ( [ #identifier# ] '{' enumeratorList [ ',' @ ] '{' | #identifier# )
  To #6:  '{'

** Rule: enumerationConstant => #identifier#
-- Tokens: #identifier#
-- First-set tokens: #identifier#
-- First-set rules:
Status #0 - enumerationConstant => @ #identifier#
  To #1:  #identifier#
Status #1 [FINAL] - enumerationConstant => #identifier# @

** Rule: enumerator => enumerationConstant [ '=' constantExpression ]
-- Tokens: #identifier#
-- First-set tokens: #identifier#
-- First-set rules: enumerationConstant
Status #0 - enumerator => @ enumerationConstant [ '=' constantExpression ]
  To #1:  enumerationConstant
Status #1 [FINAL] - enumerator => enumerationConstant @ [ '=' constantExpression ]
  To #2:  '='
Status #2 - enumerator => enumerationConstant [ '=' @ constantExpression ]
  To #3:  constantExpression
Status #3 [FINAL] - enumerator => enumerationConstant [ '=' constantExpression @ ]

** Rule: enumeratorList => [ enumeratorList ',' ] enumerator
-- Tokens: #identifier#
-- First-set tokens: #identifier#
-- First-set rules: enumerator enumeratorList
Status #0 - enumeratorList => [ @ enumeratorList ',' ] enumerator
  To #1:  enumeratorList
  To #2:  enumerator
Status #1 - enumeratorList => [ enumeratorList @ ',' ] enumerator
  To #3:  ','
Status #2 [FINAL] - enumeratorList => [ enumeratorList ',' ] enumerator @
Status #3 - enumeratorList => [ enumeratorList ',' @ ] enumerator
  To #2:  enumerator

** Rule: equalityExpression => [ equalityExpression ( '==' | '!=' ) ] relationalExpression
-- Tokens: #double# '&' '*' #uint# '+' #uchar# #float# '~' #short# '(' '-' #ushort# '++' '--' '!' #int# #char# sizeof #s
tring# #identifier# #long# #ulong#
-- First-set tokens: #double# #uint# #uchar# #float# '~' '+' #short# '(' #ushort# '++' '--' '!' '-' #int# #char# sizeof
#string# '&' #identifier# '*' #long# #ulong#
-- First-set rules: relationalExpression equalityExpression
Status #0 - equalityExpression => [ @ equalityExpression ( '==' | '!=' ) ] relationalExpression
  To #1:  equalityExpression
  To #2:  relationalExpression
Status #1 - equalityExpression => [ equalityExpression @ ( '==' | '!=' ) ] relationalExpression
  To #3:  '!='
  To #4:  '=='
Status #2 [FINAL] - equalityExpression => [ equalityExpression ( '==' | '!=' ) ] relationalExpression @
Status #3 - equalityExpression => [ equalityExpression ( '==' | '!=' @ ) ] relationalExpression
  To #2:  relationalExpression
Status #4 - equalityExpression => [ equalityExpression ( '==' @ | '!=' ) ] relationalExpression
  To #2:  relationalExpression

** Rule: exclusiveOrExpression => [ exclusiveOrExpression '^' ] andExpression
-- Tokens: #double# '&' '*' #uint# '+' #uchar# #float# '~' #short# '(' '-' #ushort# '++' '--' '!' #int# #char# sizeof #s
tring# #identifier# #long# #ulong#
-- First-set tokens: #double# #uint# #uchar# #float# '~' '+' #short# '(' #ushort# '++' '--' '!' '-' #int# #char# sizeof
#string# '&' #identifier# '*' #long# #ulong#
-- First-set rules: andExpression exclusiveOrExpression
Status #0 - exclusiveOrExpression => [ @ exclusiveOrExpression '^' ] andExpression
  To #1:  exclusiveOrExpression
  To #2:  andExpression
Status #1 - exclusiveOrExpression => [ exclusiveOrExpression @ '^' ] andExpression
  To #3:  '^'
Status #2 [FINAL] - exclusiveOrExpression => [ exclusiveOrExpression '^' ] andExpression @
Status #3 - exclusiveOrExpression => [ exclusiveOrExpression '^' @ ] andExpression
  To #2:  andExpression

** Rule: expression => [ expression ',' ] assignmentExpression
-- Tokens: #float# #ulong# #long# #int# #char# #identifier# #string# sizeof '!' '--' '++' '-' #ushort# '(' #short# '~' '
+' #uchar# '*' #uint# '&' #double#
-- First-set tokens: #float# #ulong# #char# #string# sizeof '!' '--' '++' #int# '-' #ushort# '(' '~' #short# '+' #uchar#
 #long# '*' #uint# #identifier# '&' #double#
-- First-set rules: assignmentExpression expression
Status #0 - expression => [ @ expression ',' ] assignmentExpression
  To #1:  expression
  To #2:  assignmentExpression
Status #1 - expression => [ expression @ ',' ] assignmentExpression
  To #3:  ','
Status #2 [FINAL] - expression => [ expression ',' ] assignmentExpression @
Status #3 - expression => [ expression ',' @ ] assignmentExpression
  To #2:  assignmentExpression

** Rule: expressionStatement => [ expression ] ';'
-- Tokens: ';' '*' #float# '~' #ulong# #long# #int# '!' #char# sizeof #identifier# #string# '--' '++' '-' #ushort# '(' #
double# #short# '+' #uchar# #uint# '&'
-- First-set tokens: '&' #uint# #uchar# '+' #short# #double# '(' #ushort# '-' '++' '--' #string# #identifier# sizeof #ch
ar# '!' #int# #long# #ulong# '~' #float# '*' ';'
-- First-set rules: expression
Status #0 - expressionStatement => [ @ expression ] ';'
  To #1:  expression
  To #2:  ';'
Status #1 - expressionStatement => [ expression @ ] ';'
  To #2:  ';'
Status #2 [FINAL] - expressionStatement => [ expression ] ';' @

** Rule: externalDeclaration => ( functionDefinition | declaration | ';' )
-- Tokens: static typedef auto signed #identifier# const short void double unsigned float long int enum struct union boo
l volatile char '(' register '^' extern ';' '*'
-- First-set tokens: '*' '^' '(' bool union struct enum int char long float unsigned double void short const volatile #i
dentifier# ';' signed auto static extern typedef register
-- First-set rules: declaration functionDefinition
Status #0 - externalDeclaration => @ ( functionDefinition | declaration | ';' )
  To #1:  ';'
  To #2:  functionDefinition
  To #3:  declaration
Status #1 [FINAL] - externalDeclaration => ( functionDefinition | declaration | ';' @ )
Status #2 [FINAL] - externalDeclaration => ( functionDefinition @ | declaration | ';' )
Status #3 [FINAL] - externalDeclaration => ( functionDefinition | declaration @ | ';' )

** Rule: forCondition => ( forDeclaration | [ expression ] ) ';' [ forExpression ] ';' [ forExpression ]
-- Tokens: #uint# #uchar# sizeof '+' #short# #double# void '(' #ushort# static '++' struct '--' #string# '&' #identifier
# volatile #char# '!' '-' #int# typedef #ulong# union float '~' #float# unsigned #long# '*' signed ';' enum int bool cha
r long double short const auto extern register
-- First-set tokens: register extern auto const short double long char bool int enum ';' '*' unsigned #float# '~' union
#ulong# typedef #long# #int# '!' signed #char# volatile #identifier# #string# float '--' '++' '-' struct #ushort# '(' vo
id #double# static #short# '+' sizeof #uchar# #uint# '&'
-- First-set rules: expression forDeclaration
Status #0 - forCondition => @ ( forDeclaration | [ expression ] ) ';' [ forExpression ] ';' [ forExpression ]
  To #1:  ';'
  To #2:  forDeclaration
  To #3:  expression
Status #1 - forCondition => ( forDeclaration | [ expression ] ) ';' @ [ forExpression ] ';' [ forExpression ]
  To #4:  ';'
  To #5:  forExpression
Status #2 - forCondition => ( forDeclaration @ | [ expression ] ) ';' [ forExpression ] ';' [ forExpression ]
  To #1:  ';'
Status #3 - forCondition => ( forDeclaration | [ expression @ ] ) ';' [ forExpression ] ';' [ forExpression ]
  To #1:  ';'
Status #4 [FINAL] - forCondition => ( forDeclaration | [ expression ] ) ';' [ forExpression ] ';' @ [ forExpression ]
  To #6:  forExpression
Status #5 - forCondition => ( forDeclaration | [ expression ] ) ';' [ forExpression @ ] ';' [ forExpression ]
  To #4:  ';'
Status #6 [FINAL] - forCondition => ( forDeclaration | [ expression ] ) ';' [ forExpression ] ';' [ forExpression @ ]

** Rule: forDeclaration => declarationSpecifiers [ initDeclaratorList ]
-- Tokens: union struct enum int bool char long float unsigned double void short const volatile #identifier# signed auto
 static extern typedef register
-- First-set tokens: register typedef extern static auto signed #identifier# volatile const short void double unsigned f
loat long char bool int enum struct union
-- First-set rules: declarationSpecifiers
Status #0 - forDeclaration => @ declarationSpecifiers [ initDeclaratorList ]
  To #1:  declarationSpecifiers
Status #1 [FINAL] - forDeclaration => declarationSpecifiers @ [ initDeclaratorList ]
  To #2:  initDeclaratorList
Status #2 [FINAL] - forDeclaration => declarationSpecifiers [ initDeclaratorList @ ]

** Rule: forExpression => [ forExpression ',' ] assignmentExpression
-- Tokens: #float# #ulong# #long# #int# #char# #identifier# #string# sizeof '!' '--' '++' '-' #ushort# '(' #short# '~' '
+' #uchar# '*' #uint# '&' #double#
-- First-set tokens: #float# #ulong# #char# #string# sizeof '!' '--' '++' #int# '-' #ushort# '(' '~' #short# '+' #uchar#
 #long# '*' #uint# #identifier# '&' #double#
-- First-set rules: assignmentExpression forExpression
Status #0 - forExpression => [ @ forExpression ',' ] assignmentExpression
  To #1:  forExpression
  To #2:  assignmentExpression
Status #1 - forExpression => [ forExpression @ ',' ] assignmentExpression
  To #3:  ','
Status #2 [FINAL] - forExpression => [ forExpression ',' ] assignmentExpression @
Status #3 - forExpression => [ forExpression ',' @ ] assignmentExpression
  To #2:  assignmentExpression

** Rule: functionDefinition => [ declarationSpecifiers ] declarator [ declarationList ] compoundStatement
-- Tokens: volatile '(' char const #identifier# '^' register '*' extern union bool struct enum int long float unsigned d
ouble void short signed auto typedef static
-- First-set tokens: static typedef auto signed short void double unsigned float long int enum struct bool union extern
'*' register '^' #identifier# const char '(' volatile
-- First-set rules: declarator declarationSpecifiers
Status #0 - functionDefinition => [ @ declarationSpecifiers ] declarator [ declarationList ] compoundStatement
  To #1:  declarationSpecifiers
  To #2:  declarator
Status #1 - functionDefinition => [ declarationSpecifiers @ ] declarator [ declarationList ] compoundStatement
  To #2:  declarator
Status #2 - functionDefinition => [ declarationSpecifiers ] declarator @ [ declarationList ] compoundStatement
  To #3:  compoundStatement
  To #4:  declarationList
Status #3 [FINAL] - functionDefinition => [ declarationSpecifiers ] declarator [ declarationList ] compoundStatement @
Status #4 - functionDefinition => [ declarationSpecifiers ] declarator [ declarationList @ ] compoundStatement
  To #3:  compoundStatement

** Rule: identifierList => [ identifierList ',' ] #identifier#
-- Tokens: #identifier#
-- First-set tokens: #identifier#
-- First-set rules: identifierList
Status #0 - identifierList => [ @ identifierList ',' ] #identifier#
  To #1:  identifierList
  To #2:  #identifier#
Status #1 - identifierList => [ identifierList @ ',' ] #identifier#
  To #3:  ','
Status #2 [FINAL] - identifierList => [ identifierList ',' ] #identifier# @
Status #3 - identifierList => [ identifierList ',' @ ] #identifier#
  To #2:  #identifier#

** Rule: inclusiveOrExpression => [ inclusiveOrExpression '|' ] exclusiveOrExpression
-- Tokens: #double# '&' '*' #uint# '+' #uchar# #float# '~' #short# '(' '-' #ushort# '++' '--' '!' #int# #char# sizeof #s
tring# #identifier# #long# #ulong#
-- First-set tokens: #double# #uint# #uchar# #float# '~' '+' #short# '(' #ushort# '++' '--' '!' '-' #int# #char# sizeof
#string# '&' #identifier# '*' #long# #ulong#
-- First-set rules: exclusiveOrExpression inclusiveOrExpression
Status #0 - inclusiveOrExpression => [ @ inclusiveOrExpression '|' ] exclusiveOrExpression
  To #1:  inclusiveOrExpression
  To #2:  exclusiveOrExpression
Status #1 - inclusiveOrExpression => [ inclusiveOrExpression @ '|' ] exclusiveOrExpression
  To #3:  '|'
Status #2 [FINAL] - inclusiveOrExpression => [ inclusiveOrExpression '|' ] exclusiveOrExpression @
Status #3 - inclusiveOrExpression => [ inclusiveOrExpression '|' @ ] exclusiveOrExpression
  To #2:  exclusiveOrExpression

** Rule: initDeclarator => declarator [ '=' initializer ]
-- Tokens: '(' '*' #identifier# '^' const volatile
-- First-set tokens: volatile const '^' #identifier# '*' '('
-- First-set rules: declarator
Status #0 - initDeclarator => @ declarator [ '=' initializer ]
  To #1:  declarator
Status #1 [FINAL] - initDeclarator => declarator @ [ '=' initializer ]
  To #2:  '='
Status #2 - initDeclarator => declarator [ '=' @ initializer ]
  To #3:  initializer
Status #3 [FINAL] - initDeclarator => declarator [ '=' initializer @ ]

** Rule: initDeclaratorList => [ initDeclaratorList ',' ] initDeclarator
-- Tokens: '(' '*' #identifier# '^' const volatile
-- First-set tokens: '(' '*' #identifier# '^' const volatile
-- First-set rules: initDeclarator initDeclaratorList
Status #0 - initDeclaratorList => [ @ initDeclaratorList ',' ] initDeclarator
  To #1:  initDeclaratorList
  To #2:  initDeclarator
Status #1 - initDeclaratorList => [ initDeclaratorList @ ',' ] initDeclarator
  To #3:  ','
Status #2 [FINAL] - initDeclaratorList => [ initDeclaratorList ',' ] initDeclarator @
Status #3 - initDeclaratorList => [ initDeclaratorList ',' @ ] initDeclarator
  To #2:  initDeclarator

** Rule: initializer => ( assignmentExpression | '{' initializerList [ ',' ] '}' )
-- Tokens: '{' #string# #float# '~' #ulong# #long# #int# '!' #char# sizeof #identifier# '--' '++' '-' #ushort# '(' #doub
le# #short# '+' #uchar# '*' #uint# '&'
-- First-set tokens: '&' #uint# '*' #uchar# '+' #short# #double# '(' #ushort# '-' '++' '--' #identifier# sizeof #char# '
!' #int# #long# #ulong# '~' #float# #string# '{'
-- First-set rules: assignmentExpression
Status #0 - initializer => @ ( assignmentExpression | '{' initializerList [ ',' ] '}' )
  To #1:  '{'
  To #2:  assignmentExpression
Status #1 - initializer => ( assignmentExpression | '{' @ initializerList [ ',' ] '}' )
  To #3:  initializerList
Status #2 [FINAL] - initializer => ( assignmentExpression @ | '{' initializerList [ ',' ] '}' )
Status #3 - initializer => ( assignmentExpression | '{' initializerList @ [ ',' ] '}' )
  To #4:  '}'
  To #5:  ','
Status #4 [FINAL] - initializer => ( assignmentExpression | '{' initializerList [ ',' ] '}' @ )
Status #5 - initializer => ( assignmentExpression | '{' initializerList [ ',' @ ] '}' )
  To #4:  '}'

** Rule: initializerList => [ initializerList ',' ] [ designation ] initializer
-- Tokens: '{' #string# #float# '~' #ulong# #long# #int# '!' #char# sizeof #identifier# '--' '++' '-' #ushort# '(' #doub
le# #short# '+' '[' #uchar# '*' #uint# '&' '.'
-- First-set tokens: '{' #string# #float# '~' #ulong# #long# #int# '!' #char# #identifier# '--' '++' '-' #ushort# '(' #d
ouble# #short# '+' '[' sizeof #uchar# '*' #uint# '&' '.'
-- First-set rules: initializer designation initializerList
Status #0 - initializerList => [ @ initializerList ',' ] [ designation ] initializer
  To #1:  initializerList
  To #2:  designation
  To #3:  initializer
Status #1 - initializerList => [ initializerList @ ',' ] [ designation ] initializer
  To #4:  ','
Status #2 - initializerList => [ initializerList ',' ] [ designation @ ] initializer
  To #3:  initializer
Status #3 [FINAL] - initializerList => [ initializerList ',' ] [ designation ] initializer @
Status #4 - initializerList => [ initializerList ',' @ ] [ designation ] initializer
  To #3:  initializer
  To #2:  designation

** Rule: iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' ';' | for '(
' forCondition ')' statement )
-- Tokens: while do for
-- First-set tokens: for do while
-- First-set rules:
Status #0 - iterationStatement => @ ( while '(' expression ')' statement | do statement while '(' expression ')' ';' | f
or '(' forCondition ')' statement )
  To #1:  for
  To #2:  while
  To #3:  do
Status #1 - iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' ';' | for
 @ '(' forCondition ')' statement )
  To #4:  '('
Status #2 - iterationStatement => ( while @ '(' expression ')' statement | do statement while '(' expression ')' ';' | f
or '(' forCondition ')' statement )
  To #5:  '('
Status #3 - iterationStatement => ( while '(' expression ')' statement | do @ statement while '(' expression ')' ';' | f
or '(' forCondition ')' statement )
  To #6:  statement
Status #4 - iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' ';' | for
 '(' @ forCondition ')' statement )
  To #7:  forCondition
Status #5 - iterationStatement => ( while '(' @ expression ')' statement | do statement while '(' expression ')' ';' | f
or '(' forCondition ')' statement )
  To #8:  expression
Status #6 - iterationStatement => ( while '(' expression ')' statement | do statement @ while '(' expression ')' ';' | f
or '(' forCondition ')' statement )
  To #9:  while
Status #7 - iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' ';' | for
 '(' forCondition @ ')' statement )
  To #10:  ')'
Status #8 - iterationStatement => ( while '(' expression @ ')' statement | do statement while '(' expression ')' ';' | f
or '(' forCondition ')' statement )
  To #11:  ')'
Status #9 - iterationStatement => ( while '(' expression ')' statement | do statement while @ '(' expression ')' ';' | f
or '(' forCondition ')' statement )
  To #12:  '('
Status #10 - iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' ';' | fo
r '(' forCondition ')' @ statement )
  To #13:  statement
Status #11 - iterationStatement => ( while '(' expression ')' @ statement | do statement while '(' expression ')' ';' |
for '(' forCondition ')' statement )
  To #14:  statement
Status #12 - iterationStatement => ( while '(' expression ')' statement | do statement while '(' @ expression ')' ';' |
for '(' forCondition ')' statement )
  To #15:  expression
Status #13 [FINAL] - iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')'
';' | for '(' forCondition ')' statement @ )
Status #14 [FINAL] - iterationStatement => ( while '(' expression ')' statement @ | do statement while '(' expression ')
' ';' | for '(' forCondition ')' statement )
Status #15 - iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression @ ')' ';' |
for '(' forCondition ')' statement )
  To #16:  ')'
Status #16 - iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' @ ';' |
for '(' forCondition ')' statement )
  To #17:  ';'
Status #17 [FINAL] - iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')'
';' @ | for '(' forCondition ')' statement )

** Rule: jumpStatement => ( goto #identifier# ';' | continue ';' | break ';' | return [ expression ] ';' )
-- Tokens: goto continue return break
-- First-set tokens: break return continue goto
-- First-set rules:
Status #0 - jumpStatement => @ ( goto #identifier# ';' | continue ';' | break ';' | return [ expression ] ';' )
  To #1:  return
  To #2:  goto
  To #3:  continue
  To #4:  break
Status #1 - jumpStatement => ( goto #identifier# ';' | continue ';' | break ';' | return @ [ expression ] ';' )
  To #5:  ';'
  To #6:  expression
Status #2 - jumpStatement => ( goto @ #identifier# ';' | continue ';' | break ';' | return [ expression ] ';' )
  To #7:  #identifier#
Status #3 - jumpStatement => ( goto #identifier# ';' | continue @ ';' | break ';' | return [ expression ] ';' )
  To #8:  ';'
Status #4 - jumpStatement => ( goto #identifier# ';' | continue ';' | break @ ';' | return [ expression ] ';' )
  To #9:  ';'
Status #5 [FINAL] - jumpStatement => ( goto #identifier# ';' | continue ';' | break ';' | return [ expression ] ';' @ )
Status #6 - jumpStatement => ( goto #identifier# ';' | continue ';' | break ';' | return [ expression @ ] ';' )
  To #5:  ';'
Status #7 - jumpStatement => ( goto #identifier# @ ';' | continue ';' | break ';' | return [ expression ] ';' )
  To #10:  ';'
Status #8 [FINAL] - jumpStatement => ( goto #identifier# ';' | continue ';' @ | break ';' | return [ expression ] ';' )
Status #9 [FINAL] - jumpStatement => ( goto #identifier# ';' | continue ';' | break ';' @ | return [ expression ] ';' )
Status #10 [FINAL] - jumpStatement => ( goto #identifier# ';' @ | continue ';' | break ';' | return [ expression ] ';' )


** Rule: labeledStatement => ( #identifier# | case constantExpression | default ) '=' statement
-- Tokens: #identifier# default case
-- First-set tokens: case default #identifier#
-- First-set rules:
Status #0 - labeledStatement => @ ( #identifier# | case constantExpression | default ) '=' statement
  To #1:  default
  To #2:  #identifier#
  To #3:  case
Status #1 - labeledStatement => ( #identifier# | case constantExpression | default @ ) '=' statement
  To #4:  '='
Status #2 - labeledStatement => ( #identifier# @ | case constantExpression | default ) '=' statement
  To #4:  '='
Status #3 - labeledStatement => ( #identifier# | case @ constantExpression | default ) '=' statement
  To #5:  constantExpression
Status #4 - labeledStatement => ( #identifier# | case constantExpression | default ) '=' @ statement
  To #6:  statement
Status #5 - labeledStatement => ( #identifier# | case constantExpression @ | default ) '=' statement
  To #4:  '='
Status #6 [FINAL] - labeledStatement => ( #identifier# | case constantExpression | default ) '=' statement @

** Rule: logicalAndExpression => [ logicalAndExpression '&&' ] inclusiveOrExpression
-- Tokens: #double# '&' '*' #uint# '+' #uchar# #float# '~' #short# '(' '-' #ushort# '++' '--' '!' #int# #char# sizeof #s
tring# #identifier# #long# #ulong#
-- First-set tokens: #double# #uint# #uchar# #float# '~' '+' #short# '(' #ushort# '++' '--' '!' '-' #int# #char# sizeof
#string# '&' #identifier# '*' #long# #ulong#
-- First-set rules: inclusiveOrExpression logicalAndExpression
Status #0 - logicalAndExpression => [ @ logicalAndExpression '&&' ] inclusiveOrExpression
  To #1:  logicalAndExpression
  To #2:  inclusiveOrExpression
Status #1 - logicalAndExpression => [ logicalAndExpression @ '&&' ] inclusiveOrExpression
  To #3:  '&&'
Status #2 [FINAL] - logicalAndExpression => [ logicalAndExpression '&&' ] inclusiveOrExpression @
Status #3 - logicalAndExpression => [ logicalAndExpression '&&' @ ] inclusiveOrExpression
  To #2:  inclusiveOrExpression

** Rule: logicalOrExpression => [ logicalOrExpression '||' ] logicalAndExpression
-- Tokens: #double# '&' '*' #uint# '+' #uchar# #float# '~' #short# '(' '-' #ushort# '++' '--' '!' #int# #char# sizeof #s
tring# #identifier# #long# #ulong#
-- First-set tokens: #double# #uint# #uchar# #float# '~' '+' #short# '(' #ushort# '++' '--' '!' '-' #int# #char# sizeof
#string# '&' #identifier# '*' #long# #ulong#
-- First-set rules: logicalAndExpression logicalOrExpression
Status #0 - logicalOrExpression => [ @ logicalOrExpression '||' ] logicalAndExpression
  To #1:  logicalOrExpression
  To #2:  logicalAndExpression
Status #1 - logicalOrExpression => [ logicalOrExpression @ '||' ] logicalAndExpression
  To #3:  '||'
Status #2 [FINAL] - logicalOrExpression => [ logicalOrExpression '||' ] logicalAndExpression @
Status #3 - logicalOrExpression => [ logicalOrExpression '||' @ ] logicalAndExpression
  To #2:  logicalAndExpression

** Rule: multiplicativeExpression => ( castExpression | multiplicativeExpression ( '*' castExpression | '/' castExpressi
on | '%' castExpression ) )
-- Tokens: #double# '&' '*' #uint# '+' #uchar# #float# '~' #short# '(' '-' #ushort# '++' '--' '!' #int# #char# sizeof #s
tring# #identifier# #long# #ulong#
-- First-set tokens: #double# #uint# #uchar# #float# '~' '+' #short# '(' #ushort# '++' '--' '!' '-' #int# #char# sizeof
#string# '&' #identifier# '*' #long# #ulong#
-- First-set rules: multiplicativeExpression castExpression
Status #0 - multiplicativeExpression => @ ( castExpression | multiplicativeExpression ( '*' castExpression | '/' castExp
ression | '%' castExpression ) )
  To #1:  multiplicativeExpression
  To #2:  castExpression
Status #1 - multiplicativeExpression => ( castExpression | multiplicativeExpression @ ( '*' castExpression | '/' castExp
ression | '%' castExpression ) )
  To #3:  '%'
  To #4:  '*'
  To #5:  '/'
Status #2 [FINAL] - multiplicativeExpression => ( castExpression @ | multiplicativeExpression ( '*' castExpression | '/'
 castExpression | '%' castExpression ) )
Status #3 - multiplicativeExpression => ( castExpression | multiplicativeExpression ( '*' castExpression | '/' castExpre
ssion | '%' @ castExpression ) )
  To #6:  castExpression
Status #4 - multiplicativeExpression => ( castExpression | multiplicativeExpression ( '*' @ castExpression | '/' castExp
ression | '%' castExpression ) )
  To #7:  castExpression
Status #5 - multiplicativeExpression => ( castExpression | multiplicativeExpression ( '*' castExpression | '/' @ castExp
ression | '%' castExpression ) )
  To #8:  castExpression
Status #6 [FINAL] - multiplicativeExpression => ( castExpression | multiplicativeExpression ( '*' castExpression | '/' c
astExpression | '%' castExpression @ ) )
Status #7 [FINAL] - multiplicativeExpression => ( castExpression | multiplicativeExpression ( '*' castExpression @ | '/'
 castExpression | '%' castExpression ) )
Status #8 [FINAL] - multiplicativeExpression => ( castExpression | multiplicativeExpression ( '*' castExpression | '/' c
astExpression @ | '%' castExpression ) )

** Rule: parameterDeclaration => ( declarationSpecifiers declarator | declarationSpecifiers2 [ abstractDeclarator ] )
-- Tokens: register typedef extern static auto signed #identifier# volatile const short void double unsigned float long
char bool int enum struct union
-- First-set tokens: union struct enum int bool char long float unsigned double void short const volatile #identifier# s
igned auto static extern typedef register
-- First-set rules: declarationSpecifiers2 declarationSpecifiers
Status #0 - parameterDeclaration => @ ( declarationSpecifiers declarator | declarationSpecifiers2 [ abstractDeclarator ]
 )
  To #1:  declarationSpecifiers2
  To #2:  declarationSpecifiers
Status #1 [FINAL] - parameterDeclaration => ( declarationSpecifiers declarator | declarationSpecifiers2 @ [ abstractDecl
arator ] )
  To #3:  abstractDeclarator
Status #2 - parameterDeclaration => ( declarationSpecifiers @ declarator | declarationSpecifiers2 [ abstractDeclarator ]
 )
  To #4:  declarator
Status #3 [FINAL] - parameterDeclaration => ( declarationSpecifiers declarator | declarationSpecifiers2 [ abstractDeclar
ator @ ] )
Status #4 [FINAL] - parameterDeclaration => ( declarationSpecifiers declarator @ | declarationSpecifiers2 [ abstractDecl
arator ] )

** Rule: parameterList => [ parameterList ',' ] parameterDeclaration
-- Tokens: register typedef extern static auto signed #identifier# volatile const short void double unsigned float long
char bool int enum struct union
-- First-set tokens: register typedef extern static auto signed #identifier# volatile const short void double unsigned f
loat long char bool int enum struct union
-- First-set rules: parameterDeclaration parameterList
Status #0 - parameterList => [ @ parameterList ',' ] parameterDeclaration
  To #1:  parameterList
  To #2:  parameterDeclaration
Status #1 - parameterList => [ parameterList @ ',' ] parameterDeclaration
  To #3:  ','
Status #2 [FINAL] - parameterList => [ parameterList ',' ] parameterDeclaration @
Status #3 - parameterList => [ parameterList ',' @ ] parameterDeclaration
  To #2:  parameterDeclaration

** Rule: parameterTypeList => parameterList [ ',' '...' ]
-- Tokens: register typedef extern static auto signed #identifier# volatile const short void double unsigned float long
char bool int enum struct union
-- First-set tokens: union struct enum int bool char long float unsigned double void short const volatile #identifier# s
igned auto static extern typedef register
-- First-set rules: parameterList
Status #0 - parameterTypeList => @ parameterList [ ',' '...' ]
  To #1:  parameterList
Status #1 [FINAL] - parameterTypeList => parameterList @ [ ',' '...' ]
  To #2:  ','
Status #2 - parameterTypeList => parameterList [ ',' @ '...' ]
  To #3:  '...'
Status #3 [FINAL] - parameterTypeList => parameterList [ ',' '...' @ ]

** Rule: pointer => [ typeQualifierList ] [ pointer ] ( '*' | '^' )
-- Tokens: '*' '^' const volatile
-- First-set tokens: '*' '^' const volatile
-- First-set rules: pointer typeQualifierList
Status #0 - pointer => [ @ typeQualifierList ] [ pointer ] ( '*' | '^' )
  To #1:  typeQualifierList
  To #2:  pointer
  To #3:  '*'
  To #4:  '^'
Status #1 - pointer => [ typeQualifierList @ ] [ pointer ] ( '*' | '^' )
  To #4:  '^'
  To #2:  pointer
  To #3:  '*'
Status #2 - pointer => [ typeQualifierList ] [ pointer @ ] ( '*' | '^' )
  To #4:  '^'
  To #3:  '*'
Status #3 [FINAL] - pointer => [ typeQualifierList ] [ pointer ] ( '*' @ | '^' )
Status #4 [FINAL] - pointer => [ typeQualifierList ] [ pointer ] ( '*' | '^' @ )

** Rule: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpressionLis
t ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}' )
-- Tokens: '(' #string# #identifier# #ushort# #short# #uchar# #char# #int# #uint# #long# #ulong# #float# #double#
-- First-set tokens: '(' #string# #identifier# #ushort# #short# #uchar# #char# #int# #uint# #long# #ulong# #float# #doub
le#
-- First-set rules: postfixExpression primaryExpression
Status #0 - postfixExpression => @ ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpressi
onList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}' )

  To #1:  '('
  To #2:  primaryExpression
  To #3:  postfixExpression
Status #1 - postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpression
List ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' @ typeName ')' '{' initializerList [ ',' ] '}' )

  To #4:  typeName
Status #2 [FINAL] - postfixExpression => ( primaryExpression @ | postfixExpression ( '[' expression ']' | '(' [ argument
ExpressionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ','
 ] '}' )
Status #3 - postfixExpression => ( primaryExpression | postfixExpression @ ( '[' expression ']' | '(' [ argumentExpressi
onList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}' )

  To #5:  '--'
  To #6:  '['
  To #7:  '('
  To #8:  '.'
  To #9:  '->'
  To #10:  '++'
Status #4 - postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpression
List ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName @ ')' '{' initializerList [ ',' ] '}' )

  To #11:  ')'
Status #5 [FINAL] - postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentEx
pressionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' @ ) | '(' typeName ')' '{' initializerList [ ','
 ] '}' )
Status #6 - postfixExpression => ( primaryExpression | postfixExpression ( '[' @ expression ']' | '(' [ argumentExpressi
onList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}' )

  To #12:  expression
Status #7 - postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' @ [ argumentExpressi
onList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}' )

  To #13:  ')'
  To #14:  argumentExpressionList
Status #8 - postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpression
List ] ')' | '.' @ #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}' )

  To #15:  #identifier#
Status #9 - postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpression
List ] ')' | '.' #identifier# | '->' @ #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}' )

  To #16:  #identifier#
Status #10 [FINAL] - postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentE
xpressionList ] ')' | '.' #identifier# | '->' #identifier# | '++' @ | '--' ) | '(' typeName ')' '{' initializerList [ ',
' ] '}' )
Status #11 - postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpressio
nList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' @ '{' initializerList [ ',' ] '}'
)
  To #17:  '{'
Status #12 - postfixExpression => ( primaryExpression | postfixExpression ( '[' expression @ ']' | '(' [ argumentExpress
ionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}'
)
  To #18:  ']'
Status #13 [FINAL] - postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentE
xpressionList ] ')' @ | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',
' ] '}' )
Status #14 - postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpressio
nList @ ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}'
)
  To #13:  ')'
Status #15 [FINAL] - postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentE
xpressionList ] ')' | '.' #identifier# @ | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',
' ] '}' )
Status #16 [FINAL] - postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentE
xpressionList ] ')' | '.' #identifier# | '->' #identifier# @ | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',
' ] '}' )
Status #17 - postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpressio
nList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' @ initializerList [ ',' ] '}'
)
  To #19:  initializerList
Status #18 [FINAL] - postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' @ | '(' [ argumen
tExpressionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',
' ] '}' )
Status #19 - postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpressio
nList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList @ [ ',' ] '}'
)
  To #20:  '}'
  To #21:  ','
Status #20 [FINAL] - postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentE
xpressionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ','
] '}' @ )
Status #21 - postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpressio
nList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' @ ] '}'
)
  To #20:  '}'

** Rule: primaryExpression => ( #identifier# | constant | #string# | '(' expression ')' )
-- Tokens: #string# '(' #identifier# #ushort# #short# #uchar# #char# #int# #uint# #long# #ulong# #float# #double#
-- First-set tokens: #double# #float# #ulong# #long# #uint# #int# #char# #uchar# #short# #ushort# #identifier# '(' #stri
ng#
-- First-set rules: constant
Status #0 - primaryExpression => @ ( #identifier# | constant | #string# | '(' expression ')' )
  To #1:  '('
  To #2:  #identifier#
  To #3:  constant
  To #4:  #string#
Status #1 - primaryExpression => ( #identifier# | constant | #string# | '(' @ expression ')' )
  To #5:  expression
Status #2 [FINAL] - primaryExpression => ( #identifier# @ | constant | #string# | '(' expression ')' )
Status #3 [FINAL] - primaryExpression => ( #identifier# | constant @ | #string# | '(' expression ')' )
Status #4 [FINAL] - primaryExpression => ( #identifier# | constant | #string# @ | '(' expression ')' )
Status #5 - primaryExpression => ( #identifier# | constant | #string# | '(' expression @ ')' )
  To #6:  ')'
Status #6 [FINAL] - primaryExpression => ( #identifier# | constant | #string# | '(' expression ')' @ )

** Rule: program => compilationUnit
-- Tokens: static typedef auto signed #identifier# const short void double unsigned float long int enum struct union boo
l volatile char '(' register '^' extern ';' '*'
-- First-set tokens: '*' ';' extern '^' register '(' char volatile bool union struct enum int long float unsigned double
 void short const #identifier# signed auto typedef static
-- First-set rules: compilationUnit
Status #0 - program => @ compilationUnit
  To #1:  compilationUnit
Status #1 [FINAL] - program => compilationUnit @

** Rule: relationalExpression => [ relationalExpression ( '<' | '>' | '<=' | '>=' ) ] shiftExpression
-- Tokens: #double# '&' '*' #uint# '+' #uchar# #float# '~' #short# '(' '-' #ushort# '++' '--' '!' #int# #char# sizeof #s
tring# #identifier# #long# #ulong#
-- First-set tokens: #double# #uint# #uchar# #float# '~' '+' #short# '(' #ushort# '++' '--' '!' '-' #int# #char# sizeof
#string# '&' #identifier# '*' #long# #ulong#
-- First-set rules: shiftExpression relationalExpression
Status #0 - relationalExpression => [ @ relationalExpression ( '<' | '>' | '<=' | '>=' ) ] shiftExpression
  To #1:  relationalExpression
  To #2:  shiftExpression
Status #1 - relationalExpression => [ relationalExpression @ ( '<' | '>' | '<=' | '>=' ) ] shiftExpression
  To #3:  '>='
  To #4:  '<'
  To #5:  '>'
  To #6:  '<='
Status #2 [FINAL] - relationalExpression => [ relationalExpression ( '<' | '>' | '<=' | '>=' ) ] shiftExpression @
Status #3 - relationalExpression => [ relationalExpression ( '<' | '>' | '<=' | '>=' @ ) ] shiftExpression
  To #2:  shiftExpression
Status #4 - relationalExpression => [ relationalExpression ( '<' @ | '>' | '<=' | '>=' ) ] shiftExpression
  To #2:  shiftExpression
Status #5 - relationalExpression => [ relationalExpression ( '<' | '>' @ | '<=' | '>=' ) ] shiftExpression
  To #2:  shiftExpression
Status #6 - relationalExpression => [ relationalExpression ( '<' | '>' | '<=' @ | '>=' ) ] shiftExpression
  To #2:  shiftExpression

** Rule: selectionStatement => ( if '(' expression ')' statement [ else statement ] | switch '(' expression ')' statemen
t )
-- Tokens: if switch
-- First-set tokens: switch if
-- First-set rules:
Status #0 - selectionStatement => @ ( if '(' expression ')' statement [ else statement ] | switch '(' expression ')' sta
tement )
  To #1:  switch
  To #2:  if
Status #1 - selectionStatement => ( if '(' expression ')' statement [ else statement ] | switch @ '(' expression ')' sta
tement )
  To #3:  '('
Status #2 - selectionStatement => ( if @ '(' expression ')' statement [ else statement ] | switch '(' expression ')' sta
tement )
  To #4:  '('
Status #3 - selectionStatement => ( if '(' expression ')' statement [ else statement ] | switch '(' @ expression ')' sta
tement )
  To #5:  expression
Status #4 - selectionStatement => ( if '(' @ expression ')' statement [ else statement ] | switch '(' expression ')' sta
tement )
  To #6:  expression
Status #5 - selectionStatement => ( if '(' expression ')' statement [ else statement ] | switch '(' expression @ ')' sta
tement )
  To #7:  ')'
Status #6 - selectionStatement => ( if '(' expression @ ')' statement [ else statement ] | switch '(' expression ')' sta
tement )
  To #8:  ')'
Status #7 - selectionStatement => ( if '(' expression ')' statement [ else statement ] | switch '(' expression ')' @ sta
tement )
  To #9:  statement
Status #8 - selectionStatement => ( if '(' expression ')' @ statement [ else statement ] | switch '(' expression ')' sta
tement )
  To #10:  statement
Status #9 [FINAL] - selectionStatement => ( if '(' expression ')' statement [ else statement ] | switch '(' expression '
)' statement @ )
Status #10 [FINAL] - selectionStatement => ( if '(' expression ')' statement @ [ else statement ] | switch '(' expressio
n ')' statement )
  To #11:  else
Status #11 - selectionStatement => ( if '(' expression ')' statement [ else @ statement ] | switch '(' expression ')' st
atement )
  To #12:  statement
Status #12 [FINAL] - selectionStatement => ( if '(' expression ')' statement [ else statement @ ] | switch '(' expressio
n ')' statement )

** Rule: shiftExpression => [ shiftExpression ( '<<' | '>>' ) ] additiveExpression
-- Tokens: #double# '&' '*' #uint# '+' #uchar# #float# '~' #short# '(' '-' #ushort# '++' '--' '!' #int# #char# sizeof #s
tring# #identifier# #long# #ulong#
-- First-set tokens: #double# #uint# #uchar# #float# '~' '+' #short# '(' #ushort# '++' '--' '!' '-' #int# #char# sizeof
#string# '&' #identifier# '*' #long# #ulong#
-- First-set rules: additiveExpression shiftExpression
Status #0 - shiftExpression => [ @ shiftExpression ( '<<' | '>>' ) ] additiveExpression
  To #1:  shiftExpression
  To #2:  additiveExpression
Status #1 - shiftExpression => [ shiftExpression @ ( '<<' | '>>' ) ] additiveExpression
  To #3:  '>>'
  To #4:  '<<'
Status #2 [FINAL] - shiftExpression => [ shiftExpression ( '<<' | '>>' ) ] additiveExpression @
Status #3 - shiftExpression => [ shiftExpression ( '<<' | '>>' @ ) ] additiveExpression
  To #2:  additiveExpression
Status #4 - shiftExpression => [ shiftExpression ( '<<' @ | '>>' ) ] additiveExpression
  To #2:  additiveExpression

** Rule: specifierQualifierList => ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
-- Tokens: volatile const short signed #identifier# void unsigned float long char bool int enum double struct union
-- First-set tokens: union struct double enum int bool char long float unsigned void #identifier# signed short const vol
atile
-- First-set rules: typeQualifier typeSpecifier
Status #0 - specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
  To #1:  typeQualifier
  To #2:  typeSpecifier
Status #1 [FINAL] - specifierQualifierList => ( typeSpecifier | typeQualifier @ ) [ specifierQualifierList ]
  To #3:  specifierQualifierList
Status #2 [FINAL] - specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
  To #3:  specifierQualifierList
Status #3 [FINAL] - specifierQualifierList => ( typeSpecifier | typeQualifier ) [ specifierQualifierList @ ]

** Rule: statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationState
ment | jumpStatement )
-- Tokens: '{' switch return continue while '(' #identifier# default case ';' '*' #long# goto #float# for #ulong# #int#
break '-' '!' do '&' #char# '~' sizeof #string# '--' '++' #ushort# if #double# #short# '+' #uchar# #uint#
-- First-set tokens: #uint# #uchar# '+' #short# #double# #ushort# '++' '--' #string# sizeof #char# '!' '-' #int# #ulong#
 '~' #float# #long# '*' ';' case default '&' #identifier# '(' for do while goto continue return break switch if '{'
-- First-set rules: jumpStatement iterationStatement labeledStatement selectionStatement compoundStatement expressionSta
tement
Status #0 - statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iteration
Statement | jumpStatement )
  To #1:  jumpStatement
  To #2:  labeledStatement
  To #3:  compoundStatement
  To #4:  expressionStatement
  To #5:  selectionStatement
  To #6:  iterationStatement
Status #1 [FINAL] - statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | ite
rationStatement | jumpStatement @ )
Status #2 [FINAL] - statement => ( labeledStatement @ | compoundStatement | expressionStatement | selectionStatement | i
terationStatement | jumpStatement )
Status #3 [FINAL] - statement => ( labeledStatement | compoundStatement @ | expressionStatement | selectionStatement | i
terationStatement | jumpStatement )
Status #4 [FINAL] - statement => ( labeledStatement | compoundStatement | expressionStatement @ | selectionStatement | i
terationStatement | jumpStatement )
Status #5 [FINAL] - statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement @ | i
terationStatement | jumpStatement )
Status #6 [FINAL] - statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | ite
rationStatement @ | jumpStatement )

** Rule: storageClassSpecifier => ( typedef | extern | static | auto | register )
-- Tokens: auto static extern typedef register
-- First-set tokens: register typedef extern static auto
-- First-set rules:
Status #0 - storageClassSpecifier => @ ( typedef | extern | static | auto | register )
  To #1:  register
  To #2:  typedef
  To #3:  extern
  To #4:  static
  To #5:  auto
Status #1 [FINAL] - storageClassSpecifier => ( typedef | extern | static | auto | register @ )
Status #2 [FINAL] - storageClassSpecifier => ( typedef @ | extern | static | auto | register )
Status #3 [FINAL] - storageClassSpecifier => ( typedef | extern @ | static | auto | register )
Status #4 [FINAL] - storageClassSpecifier => ( typedef | extern | static @ | auto | register )
Status #5 [FINAL] - storageClassSpecifier => ( typedef | extern | static | auto @ | register )

** Rule: structDeclaration => specifierQualifierList [ structDeclaratorList ] ';'
-- Tokens: volatile const short signed #identifier# void unsigned float long char bool int enum double struct union
-- First-set tokens: union struct double enum int bool char long float unsigned void #identifier# signed short const vol
atile
-- First-set rules: specifierQualifierList
Status #0 - structDeclaration => @ specifierQualifierList [ structDeclaratorList ] ';'
  To #1:  specifierQualifierList
Status #1 - structDeclaration => specifierQualifierList @ [ structDeclaratorList ] ';'
  To #2:  ';'
  To #3:  structDeclaratorList
Status #2 [FINAL] - structDeclaration => specifierQualifierList [ structDeclaratorList ] ';' @
Status #3 - structDeclaration => specifierQualifierList [ structDeclaratorList @ ] ';'
  To #2:  ';'

** Rule: structDeclarationList => [ structDeclarationList ] structDeclaration
-- Tokens: volatile const short signed #identifier# void unsigned float long char bool int enum double struct union
-- First-set tokens: volatile const short signed void unsigned float long char bool #identifier# int enum double struct
union
-- First-set rules: structDeclaration structDeclarationList
Status #0 - structDeclarationList => [ @ structDeclarationList ] structDeclaration
  To #1:  structDeclarationList
  To #2:  structDeclaration
Status #1 - structDeclarationList => [ structDeclarationList @ ] structDeclaration
  To #2:  structDeclaration
Status #2 [FINAL] - structDeclarationList => [ structDeclarationList ] structDeclaration @

** Rule: structDeclarator => ( declarator | [ declarator ] '=' constantExpression )
-- Tokens: '=' '(' '*' #identifier# '^' const volatile
-- First-set tokens: volatile const '^' #identifier# '*' '(' '='
-- First-set rules: declarator
Status #0 - structDeclarator => @ ( declarator | [ declarator ] '=' constantExpression )
  To #1:  '='
  To #2:  declarator
  To #3:  declarator
Status #1 - structDeclarator => ( declarator | [ declarator ] '=' @ constantExpression )
  To #4:  constantExpression
Status #2 [FINAL] - structDeclarator => ( declarator @ | [ declarator ] '=' constantExpression )
Status #3 - structDeclarator => ( declarator | [ declarator @ ] '=' constantExpression )
  To #1:  '='
Status #4 [FINAL] - structDeclarator => ( declarator | [ declarator ] '=' constantExpression @ )

** Rule: structDeclaratorList => [ structDeclaratorList ',' ] structDeclarator
-- Tokens: '=' '(' '*' #identifier# '^' const volatile
-- First-set tokens: '=' '(' '*' #identifier# '^' const volatile
-- First-set rules: structDeclarator structDeclaratorList
Status #0 - structDeclaratorList => [ @ structDeclaratorList ',' ] structDeclarator
  To #1:  structDeclaratorList
  To #2:  structDeclarator
Status #1 - structDeclaratorList => [ structDeclaratorList @ ',' ] structDeclarator
  To #3:  ','
Status #2 [FINAL] - structDeclaratorList => [ structDeclaratorList ',' ] structDeclarator @
Status #3 - structDeclaratorList => [ structDeclaratorList ',' @ ] structDeclarator
  To #2:  structDeclarator

** Rule: structOrUnion => ( struct | union )
-- Tokens: struct union
-- First-set tokens: union struct
-- First-set rules:
Status #0 - structOrUnion => @ ( struct | union )
  To #1:  union
  To #2:  struct
Status #1 [FINAL] - structOrUnion => ( struct | union @ )
Status #2 [FINAL] - structOrUnion => ( struct @ | union )

** Rule: structOrUnionSpecifier => structOrUnion ( #identifier# | [ #identifier# ] '{' structDeclarationList '}' )
-- Tokens: struct union
-- First-set tokens: union struct
-- First-set rules: structOrUnion
Status #0 - structOrUnionSpecifier => @ structOrUnion ( #identifier# | [ #identifier# ] '{' structDeclarationList '}' )
  To #1:  structOrUnion
Status #1 - structOrUnionSpecifier => structOrUnion @ ( #identifier# | [ #identifier# ] '{' structDeclarationList '}' )
  To #2:  '{'
  To #3:  #identifier#
  To #4:  #identifier#
Status #2 - structOrUnionSpecifier => structOrUnion ( #identifier# | [ #identifier# ] '{' @ structDeclarationList '}' )
  To #5:  structDeclarationList
Status #3 [FINAL] - structOrUnionSpecifier => structOrUnion ( #identifier# @ | [ #identifier# ] '{' structDeclarationLis
t '}' )
Status #4 - structOrUnionSpecifier => structOrUnion ( #identifier# | [ #identifier# @ ] '{' structDeclarationList '}' )
  To #2:  '{'
Status #5 - structOrUnionSpecifier => structOrUnion ( #identifier# | [ #identifier# ] '{' structDeclarationList @ '}' )
  To #6:  '}'
Status #6 [FINAL] - structOrUnionSpecifier => structOrUnion ( #identifier# | [ #identifier# ] '{' structDeclarationList
'}' @ )

** Rule: translationUnit => [ translationUnit ] externalDeclaration
-- Tokens: static typedef auto signed #identifier# const short void double unsigned float long int enum struct union boo
l volatile char '(' register '^' extern ';' '*'
-- First-set tokens: static typedef auto signed const short void double unsigned float long int struct union bool #ident
ifier# volatile char '(' register '^' extern enum ';' '*'
-- First-set rules: externalDeclaration translationUnit
Status #0 - translationUnit => [ @ translationUnit ] externalDeclaration
  To #1:  translationUnit
  To #2:  externalDeclaration
Status #1 - translationUnit => [ translationUnit @ ] externalDeclaration
  To #2:  externalDeclaration
Status #2 [FINAL] - translationUnit => [ translationUnit ] externalDeclaration @

** Rule: typeName => specifierQualifierList [ abstractDeclarator ]
-- Tokens: volatile const short signed #identifier# void unsigned float long char bool int enum double struct union
-- First-set tokens: union struct double enum int bool char long float unsigned void #identifier# signed short const vol
atile
-- First-set rules: specifierQualifierList
Status #0 - typeName => @ specifierQualifierList [ abstractDeclarator ]
  To #1:  specifierQualifierList
Status #1 [FINAL] - typeName => specifierQualifierList @ [ abstractDeclarator ]
  To #2:  abstractDeclarator
Status #2 [FINAL] - typeName => specifierQualifierList [ abstractDeclarator @ ]

** Rule: typeQualifier => ( const | volatile )
-- Tokens: const volatile
-- First-set tokens: volatile const
-- First-set rules:
Status #0 - typeQualifier => @ ( const | volatile )
  To #1:  volatile
  To #2:  const
Status #1 [FINAL] - typeQualifier => ( const | volatile @ )
Status #2 [FINAL] - typeQualifier => ( const @ | volatile )

** Rule: typeQualifierList => [ typeQualifierList ] typeQualifier
-- Tokens: const volatile
-- First-set tokens: const volatile
-- First-set rules: typeQualifier typeQualifierList
Status #0 - typeQualifierList => [ @ typeQualifierList ] typeQualifier
  To #1:  typeQualifierList
  To #2:  typeQualifier
Status #1 - typeQualifierList => [ typeQualifierList @ ] typeQualifier
  To #2:  typeQualifier
Status #2 [FINAL] - typeQualifierList => [ typeQualifierList ] typeQualifier @

** Rule: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnion
Specifier | enumSpecifier | typedefName | typeSpecifier pointer )
-- Tokens: signed #identifier# void unsigned float long short char bool int enum double struct union
-- First-set tokens: bool signed #identifier# unsigned double void float long short char int enum struct union
-- First-set rules: typeSpecifier typedefName enumSpecifier structOrUnionSpecifier
Status #0 - typeSpecifier => @ ( void | char | short | int | long | float | double | signed | unsigned | bool | structOr
UnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
  To #1:  typeSpecifier
  To #2:  void
  To #3:  char
  To #4:  short
  To #5:  int
  To #6:  long
  To #7:  float
  To #8:  double
  To #9:  signed
  To #10:  unsigned
  To #11:  bool
  To #12:  structOrUnionSpecifier
  To #13:  enumSpecifier
  To #14:  typedefName
Status #1 - typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUn
ionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )
  To #15:  pointer
Status #2 [FINAL] - typeSpecifier => ( void @ | char | short | int | long | float | double | signed | unsigned | bool |
structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
Status #3 [FINAL] - typeSpecifier => ( void | char @ | short | int | long | float | double | signed | unsigned | bool |
structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
Status #4 [FINAL] - typeSpecifier => ( void | char | short @ | int | long | float | double | signed | unsigned | bool |
structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
Status #5 [FINAL] - typeSpecifier => ( void | char | short | int @ | long | float | double | signed | unsigned | bool |
structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
Status #6 [FINAL] - typeSpecifier => ( void | char | short | int | long @ | float | double | signed | unsigned | bool |
structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
Status #7 [FINAL] - typeSpecifier => ( void | char | short | int | long | float @ | double | signed | unsigned | bool |
structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
Status #8 [FINAL] - typeSpecifier => ( void | char | short | int | long | float | double @ | signed | unsigned | bool |
structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
Status #9 [FINAL] - typeSpecifier => ( void | char | short | int | long | float | double | signed @ | unsigned | bool |
structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
Status #10 [FINAL] - typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned @ | bool |
 structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
Status #11 [FINAL] - typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool @ |
 structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
Status #12 [FINAL] - typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | s
tructOrUnionSpecifier @ | enumSpecifier | typedefName | typeSpecifier pointer )
Status #13 [FINAL] - typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | s
tructOrUnionSpecifier | enumSpecifier @ | typedefName | typeSpecifier pointer )
Status #14 [FINAL] - typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | s
tructOrUnionSpecifier | enumSpecifier | typedefName @ | typeSpecifier pointer )
Status #15 [FINAL] - typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | s
tructOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer @ )

** Rule: typedefName => #identifier#
-- Tokens: #identifier#
-- First-set tokens: #identifier#
-- First-set rules:
Status #0 - typedefName => @ #identifier#
  To #1:  #identifier#
Status #1 [FINAL] - typedefName => #identifier# @

** Rule: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeo
f ( unaryExpression | '(' typeName ')' ) )
-- Tokens: '&' #double# '*' #uint# '+' #uchar# '~' #short# '-' '(' #ushort# '++' '--' '!' sizeof #string# #identifier# #
char# #int# #long# #ulong# #float#
-- First-set tokens: #float# #ulong# #long# #int# #char# #identifier# #string# sizeof '!' '--' '++' #ushort# '(' '-' #sh
ort# '~' #uchar# '+' #uint# '*' #double# '&'
-- First-set rules: unaryOperator postfixExpression
Status #0 - unaryExpression => @ ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression |
sizeof ( unaryExpression | '(' typeName ')' ) )
  To #1:  '--'
  To #2:  postfixExpression
  To #3:  unaryOperator
  To #4:  sizeof
  To #5:  '++'
Status #1 - unaryExpression => ( postfixExpression | ( '++' | '--' @ ) unaryExpression | unaryOperator castExpression |
sizeof ( unaryExpression | '(' typeName ')' ) )
  To #6:  unaryExpression
Status #2 [FINAL] - unaryExpression => ( postfixExpression @ | ( '++' | '--' ) unaryExpression | unaryOperator castExpre
ssion | sizeof ( unaryExpression | '(' typeName ')' ) )
Status #3 - unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator @ castExpression |
sizeof ( unaryExpression | '(' typeName ')' ) )
  To #7:  castExpression
Status #4 - unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | si
zeof @ ( unaryExpression | '(' typeName ')' ) )
  To #8:  '('
  To #9:  unaryExpression
Status #5 - unaryExpression => ( postfixExpression | ( '++' @ | '--' ) unaryExpression | unaryOperator castExpression |
sizeof ( unaryExpression | '(' typeName ')' ) )
  To #6:  unaryExpression
Status #6 [FINAL] - unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression @ | unaryOperator castExpre
ssion | sizeof ( unaryExpression | '(' typeName ')' ) )
Status #7 [FINAL] - unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpress
ion @ | sizeof ( unaryExpression | '(' typeName ')' ) )
Status #8 - unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | si
zeof ( unaryExpression | '(' @ typeName ')' ) )
  To #10:  typeName
Status #9 [FINAL] - unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpress
ion | sizeof ( unaryExpression @ | '(' typeName ')' ) )
Status #10 - unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | s
izeof ( unaryExpression | '(' typeName @ ')' ) )
  To #11:  ')'
Status #11 [FINAL] - unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpres
sion | sizeof ( unaryExpression | '(' typeName ')' @ ) )

** Rule: unaryOperator => ( '&' | '*' | '+' | '-' | '~' | '!' )
-- Tokens: '-' '~' '+' '*' '&' '!'
-- First-set tokens: '!' '&' '*' '+' '~' '-'
-- First-set rules:
Status #0 - unaryOperator => @ ( '&' | '*' | '+' | '-' | '~' | '!' )
  To #1:  '!'
  To #2:  '&'
  To #3:  '*'
  To #4:  '+'
  To #5:  '-'
  To #6:  '~'
Status #1 [FINAL] - unaryOperator => ( '&' | '*' | '+' | '-' | '~' | '!' @ )
Status #2 [FINAL] - unaryOperator => ( '&' @ | '*' | '+' | '-' | '~' | '!' )
Status #3 [FINAL] - unaryOperator => ( '&' | '*' @ | '+' | '-' | '~' | '!' )
Status #4 [FINAL] - unaryOperator => ( '&' | '*' | '+' @ | '-' | '~' | '!' )
Status #5 [FINAL] - unaryOperator => ( '&' | '*' | '+' | '-' @ | '~' | '!' )
Status #6 [FINAL] - unaryOperator => ( '&' | '*' | '+' | '-' | '~' @ | '!' )

==== PDA  ====
** [Initial] State: compilationUnit => @ translationUnit [ compilationUnit ]

** State #0: compilationUnit => @ translationUnit [ compilationUnit ]
    --> __________________
    --> #1: translationUnit => [ @ translationUnit ] externalDeclaration
    -->     Type: shift
    -->     LA: enum '*' ';' extern '^'
    -->     LA: register '(' char volatile bool
    -->     LA: union struct int long float
    -->     LA: unsigned double void short #identifier#
    -->     LA: const signed auto typedef static

** State #1: translationUnit => [ @ translationUnit ] externalDeclaration
    --> __________________
    --> #2: externalDeclaration => @ ( functionDefinition | declaration | ';' )
    -->     Type: shift
    -->     LA: static typedef auto signed #identifier#
    -->     LA: const short void double unsigned
    -->     LA: float long int enum struct
    -->     LA: union bool volatile char '('
    -->     LA: register '^' extern ';' '*'

** State #2: externalDeclaration => @ ( functionDefinition | declaration | ';' )
    --> __________________
    --> #3: externalDeclaration => ( functionDefinition | declaration | ';' @ )
    -->     Type: move
    -->     LA: ';'
    --> __________________
    --> #4: functionDefinition => [ @ declarationSpecifiers ] declarator [ declarationList ] compoundStatement
    -->     Type: shift
    -->     LA: volatile '(' char const #identifier#
    -->     LA: '^' register '*' extern union
    -->     LA: bool struct enum int long
    -->     LA: float unsigned double void short
    -->     LA: signed auto typedef static
    --> __________________
    --> #5: declaration => @ declarationSpecifiers [ initDeclaratorList ] ';'
    -->     Type: shift
    -->     LA: union struct enum int bool
    -->     LA: char long float unsigned double
    -->     LA: void short const volatile #identifier#
    -->     LA: signed auto static extern typedef
    -->     LA: register

** [FINAL] State #3: externalDeclaration => ( functionDefinition | declaration | ';' @ )
    --> __________________
    --> #6: translationUnit => [ translationUnit ] externalDeclaration @
    -->     Type: reduce
    -->     Reduce: translationUnit => [ @ translationUnit ] externalDeclaration
    --> __________________
    --> #6: translationUnit => [ translationUnit ] externalDeclaration @
    -->     Type: reduce
    -->     Reduce: translationUnit => [ translationUnit @ ] externalDeclaration

** State #4: functionDefinition => [ @ declarationSpecifiers ] declarator [ declarationList ] compoundStatement
    --> __________________
    --> #7: declarationSpecifiers => @ declarationSpecifier [ declarationSpecifiers ]
    -->     Type: shift
    -->     LA: union struct enum int bool
    -->     LA: char long float unsigned double
    -->     LA: void short const volatile #identifier#
    -->     LA: signed auto static extern typedef
    -->     LA: register
    --> __________________
    --> #8: declarator => [ @ pointer ] directDeclarator
    -->     Type: shift
    -->     LA: '(' '*' #identifier# '^' const
    -->     LA: volatile

** State #5: declaration => @ declarationSpecifiers [ initDeclaratorList ] ';'
    --> __________________
    --> #7: declarationSpecifiers => @ declarationSpecifier [ declarationSpecifiers ]
    -->     Type: shift
    -->     LA: union struct enum int bool
    -->     LA: char long float unsigned double
    -->     LA: void short const volatile #identifier#
    -->     LA: signed auto static extern typedef
    -->     LA: register

** [FINAL] State #6: translationUnit => [ translationUnit ] externalDeclaration @
    --> __________________
    --> #9: compilationUnit => translationUnit @ [ compilationUnit ]
    -->     Type: reduce
    -->     Reduce: compilationUnit => @ translationUnit [ compilationUnit ]
    --> __________________
    --> #10: translationUnit => [ translationUnit @ ] externalDeclaration
    -->     Type: recursion
    -->     LA: static typedef auto signed #identifier#
    -->     LA: const short void double unsigned
    -->     LA: float long int enum struct
    -->     LA: union bool volatile char '('
    -->     LA: register '^' extern ';' '*'

** State #7: declarationSpecifiers => @ declarationSpecifier [ declarationSpecifiers ]
    --> __________________
    --> #11: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    -->     Type: shift
    -->     LA: union struct enum int bool
    -->     LA: char long float unsigned double
    -->     LA: void short const volatile #identifier#
    -->     LA: signed auto static extern typedef
    -->     LA: register

** State #8: declarator => [ @ pointer ] directDeclarator
    --> __________________
    --> #12: pointer => [ @ typeQualifierList ] [ pointer ] ( '*' | '^' )
    -->     Type: shift
    -->     LA: volatile const '^' '*'
    --> __________________
    --> #13: directDeclarator => @ ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList ] (
assignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    -->     Type: shift
    -->     LA: #identifier# '('

** [FINAL] State #9: compilationUnit => translationUnit @ [ compilationUnit ]
    --> __________________
    --> #0: compilationUnit => @ translationUnit [ compilationUnit ]
    -->     Type: shift
    -->     LA: static typedef auto signed #identifier#
    -->     LA: const short void double unsigned
    -->     LA: float long int enum struct
    -->     LA: union bool volatile char '('
    -->     LA: register '^' extern ';' '*'
    --> __________________
    --> #14: compilationUnit => translationUnit [ compilationUnit @ ]
    -->     Type: reduce
    -->     Reduce: compilationUnit => translationUnit @ [ compilationUnit ]
    --> __________________
    --> #15: program => compilationUnit @
    -->     Type: reduce
    -->     Reduce: compilationUnit => @ translationUnit [ compilationUnit ]
    --> __________________
    --> #9: compilationUnit => translationUnit @ [ compilationUnit ]
    -->     Type: finish

** State #10: translationUnit => [ translationUnit @ ] externalDeclaration
    --> __________________
    --> #2: externalDeclaration => @ ( functionDefinition | declaration | ';' )
    -->     Type: shift
    -->     LA: static typedef auto signed #identifier#
    -->     LA: const short void double unsigned
    -->     LA: float long int enum struct
    -->     LA: union bool volatile char '('
    -->     LA: register '^' extern ';' '*'

** State #11: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #16: typeQualifier => @ ( const | volatile )
    -->     Type: shift
    -->     LA: const volatile
    --> __________________
    --> #17: storageClassSpecifier => @ ( typedef | extern | static | auto | register )
    -->     Type: shift
    -->     LA: auto static extern typedef register
    --> __________________
    --> #18: typeSpecifier => @ ( void | char | short | int | long | float | double | signed | unsigned | bool | structO
rUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    -->     Type: shift
    -->     LA: union enum char short long
    -->     LA: void struct double float unsigned
    -->     LA: #identifier# signed int bool

** State #12: pointer => [ @ typeQualifierList ] [ pointer ] ( '*' | '^' )
    --> __________________
    --> #19: typeQualifierList => [ @ typeQualifierList ] typeQualifier
    -->     Type: shift
    -->     LA: volatile const
    --> __________________
    --> #20: pointer => [ typeQualifierList ] [ pointer ] ( '*' @ | '^' )
    -->     Type: move
    -->     LA: '*'
    --> __________________
    --> #21: pointer => [ typeQualifierList ] [ pointer ] ( '*' | '^' @ )
    -->     Type: move
    -->     LA: '^'

** State #13: directDeclarator => @ ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList ] (
 assignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    --> __________________
    --> #22: directDeclarator => ( #identifier# @ | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList ] (
assignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    -->     Type: move
    -->     LA: #identifier#
    --> __________________
    --> #23: directDeclarator => ( #identifier# | '(' @ declarator ')' | directDeclarator ( '[' [ typeQualifierList ] (
assignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    -->     Type: move
    -->     LA: '('

** [FINAL] State #14: compilationUnit => translationUnit [ compilationUnit @ ]
    --> __________________
    --> #14: compilationUnit => translationUnit [ compilationUnit @ ]
    -->     Type: reduce
    -->     Reduce: compilationUnit => translationUnit @ [ compilationUnit ]
    --> __________________
    --> #15: program => compilationUnit @
    -->     Type: reduce
    -->     Reduce: compilationUnit => @ translationUnit [ compilationUnit ]
    --> __________________
    --> #14: compilationUnit => translationUnit [ compilationUnit @ ]
    -->     Type: finish

** [FINAL] State #15: program => compilationUnit @

** State #16: typeQualifier => @ ( const | volatile )
    --> __________________
    --> #24: typeQualifier => ( const | volatile @ )
    -->     Type: move
    -->     LA: volatile
    --> __________________
    --> #25: typeQualifier => ( const @ | volatile )
    -->     Type: move
    -->     LA: const

** State #17: storageClassSpecifier => @ ( typedef | extern | static | auto | register )
    --> __________________
    --> #26: storageClassSpecifier => ( typedef | extern | static | auto | register @ )
    -->     Type: move
    -->     LA: register
    --> __________________
    --> #27: storageClassSpecifier => ( typedef @ | extern | static | auto | register )
    -->     Type: move
    -->     LA: typedef
    --> __________________
    --> #28: storageClassSpecifier => ( typedef | extern @ | static | auto | register )
    -->     Type: move
    -->     LA: extern
    --> __________________
    --> #29: storageClassSpecifier => ( typedef | extern | static @ | auto | register )
    -->     Type: move
    -->     LA: static
    --> __________________
    --> #30: storageClassSpecifier => ( typedef | extern | static | auto @ | register )
    -->     Type: move
    -->     LA: auto

** State #18: typeSpecifier => @ ( void | char | short | int | long | float | double | signed | unsigned | bool | struct
OrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    --> __________________
    --> #31: typeSpecifier => ( void @ | char | short | int | long | float | double | signed | unsigned | bool | structO
rUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    -->     Type: move
    -->     LA: void
    --> __________________
    --> #32: typeSpecifier => ( void | char @ | short | int | long | float | double | signed | unsigned | bool | structO
rUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    -->     Type: move
    -->     LA: char
    --> __________________
    --> #33: typeSpecifier => ( void | char | short @ | int | long | float | double | signed | unsigned | bool | structO
rUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    -->     Type: move
    -->     LA: short
    --> __________________
    --> #34: typeSpecifier => ( void | char | short | int @ | long | float | double | signed | unsigned | bool | structO
rUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    -->     Type: move
    -->     LA: int
    --> __________________
    --> #35: typeSpecifier => ( void | char | short | int | long @ | float | double | signed | unsigned | bool | structO
rUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    -->     Type: move
    -->     LA: long
    --> __________________
    --> #36: typeSpecifier => ( void | char | short | int | long | float @ | double | signed | unsigned | bool | structO
rUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    -->     Type: move
    -->     LA: float
    --> __________________
    --> #37: typeSpecifier => ( void | char | short | int | long | float | double @ | signed | unsigned | bool | structO
rUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    -->     Type: move
    -->     LA: double
    --> __________________
    --> #38: typeSpecifier => ( void | char | short | int | long | float | double | signed @ | unsigned | bool | structO
rUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    -->     Type: move
    -->     LA: signed
    --> __________________
    --> #39: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned @ | bool | structO
rUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    -->     Type: move
    -->     LA: unsigned
    --> __________________
    --> #40: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool @ | structO
rUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    -->     Type: move
    -->     LA: bool
    --> __________________
    --> #41: structOrUnionSpecifier => @ structOrUnion ( #identifier# | [ #identifier# ] '{' structDeclarationList '}' )

    -->     Type: shift
    -->     LA: struct union
    --> __________________
    --> #42: enumSpecifier => @ enum ( [ #identifier# ] '{' enumeratorList [ ',' ] '{' | #identifier# )
    -->     Type: shift
    -->     LA: enum
    --> __________________
    --> #43: typedefName => @ #identifier#
    -->     Type: shift
    -->     LA: #identifier#

** State #19: typeQualifierList => [ @ typeQualifierList ] typeQualifier
    --> __________________
    --> #16: typeQualifier => @ ( const | volatile )
    -->     Type: shift
    -->     LA: const volatile

** [FINAL] State #20: pointer => [ typeQualifierList ] [ pointer ] ( '*' @ | '^' )
    --> __________________
    --> #44: abstractDeclarator => ( pointer @ | [ pointer ] directAbstractDeclarator )
    -->     Type: reduce
    -->     Reduce: abstractDeclarator => @ ( pointer | [ pointer ] directAbstractDeclarator )
    --> __________________
    --> #45: abstractDeclarator => ( pointer | [ pointer @ ] directAbstractDeclarator )
    -->     Type: reduce
    -->     Reduce: abstractDeclarator => @ ( pointer | [ pointer ] directAbstractDeclarator )
    --> __________________
    --> #46: declarator => [ pointer @ ] directDeclarator
    -->     Type: reduce
    -->     Reduce: declarator => [ @ pointer ] directDeclarator
    --> __________________
    --> #47: pointer => [ typeQualifierList ] [ pointer @ ] ( '*' | '^' )
    -->     Type: recursion
    -->     LA: '*' '^'
    --> __________________
    --> #47: pointer => [ typeQualifierList ] [ pointer @ ] ( '*' | '^' )
    -->     Type: reduce
    -->     Reduce: pointer => [ typeQualifierList @ ] [ pointer ] ( '*' | '^' )
    --> __________________
    --> #48: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrU
nionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer @ )
    -->     Type: reduce
    -->     Reduce: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | st
ructOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )

** [FINAL] State #21: pointer => [ typeQualifierList ] [ pointer ] ( '*' | '^' @ )
    --> __________________
    --> #44: abstractDeclarator => ( pointer @ | [ pointer ] directAbstractDeclarator )
    -->     Type: reduce
    -->     Reduce: abstractDeclarator => @ ( pointer | [ pointer ] directAbstractDeclarator )
    --> __________________
    --> #45: abstractDeclarator => ( pointer | [ pointer @ ] directAbstractDeclarator )
    -->     Type: reduce
    -->     Reduce: abstractDeclarator => @ ( pointer | [ pointer ] directAbstractDeclarator )
    --> __________________
    --> #46: declarator => [ pointer @ ] directDeclarator
    -->     Type: reduce
    -->     Reduce: declarator => [ @ pointer ] directDeclarator
    --> __________________
    --> #47: pointer => [ typeQualifierList ] [ pointer @ ] ( '*' | '^' )
    -->     Type: recursion
    -->     LA: '*' '^'
    --> __________________
    --> #47: pointer => [ typeQualifierList ] [ pointer @ ] ( '*' | '^' )
    -->     Type: reduce
    -->     Reduce: pointer => [ typeQualifierList @ ] [ pointer ] ( '*' | '^' )
    --> __________________
    --> #48: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrU
nionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer @ )
    -->     Type: reduce
    -->     Reduce: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | st
ructOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )

** [FINAL] State #22: directDeclarator => ( #identifier# @ | '(' declarator ')' | directDeclarator ( '[' [ typeQualifier
List ] ( assignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    --> __________________
    --> #49: declarator => [ pointer ] directDeclarator @
    -->     Type: reduce
    -->     Reduce: declarator => [ @ pointer ] directDeclarator
    --> __________________
    --> #49: declarator => [ pointer ] directDeclarator @
    -->     Type: reduce
    -->     Reduce: declarator => [ pointer @ ] directDeclarator
    --> __________________
    --> #50: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator @ ( '[' [ typeQualifierList ] (
assignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    -->     Type: recursion
    -->     LA: '[' '('

** State #23: directDeclarator => ( #identifier# | '(' @ declarator ')' | directDeclarator ( '[' [ typeQualifierList ] (
 assignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    --> __________________
    --> #8: declarator => [ @ pointer ] directDeclarator
    -->     Type: shift
    -->     LA: '(' '*' #identifier# '^' const
    -->     LA: volatile

** [FINAL] State #24: typeQualifier => ( const | volatile @ )
    --> __________________
    --> #51: declarationSpecifier => ( storageClassSpecifier | typeSpecifier | typeQualifier @ )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #52: specifierQualifierList => ( typeSpecifier | typeQualifier @ ) [ specifierQualifierList ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #53: typeQualifierList => [ typeQualifierList ] typeQualifier @
    -->     Type: reduce
    -->     Reduce: typeQualifierList => [ @ typeQualifierList ] typeQualifier
    --> __________________
    --> #53: typeQualifierList => [ typeQualifierList ] typeQualifier @
    -->     Type: reduce
    -->     Reduce: typeQualifierList => [ typeQualifierList @ ] typeQualifier

** [FINAL] State #25: typeQualifier => ( const @ | volatile )
    --> __________________
    --> #51: declarationSpecifier => ( storageClassSpecifier | typeSpecifier | typeQualifier @ )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #52: specifierQualifierList => ( typeSpecifier | typeQualifier @ ) [ specifierQualifierList ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #53: typeQualifierList => [ typeQualifierList ] typeQualifier @
    -->     Type: reduce
    -->     Reduce: typeQualifierList => [ @ typeQualifierList ] typeQualifier
    --> __________________
    --> #53: typeQualifierList => [ typeQualifierList ] typeQualifier @
    -->     Type: reduce
    -->     Reduce: typeQualifierList => [ typeQualifierList @ ] typeQualifier

** [FINAL] State #26: storageClassSpecifier => ( typedef | extern | static | auto | register @ )
    --> __________________
    --> #54: declarationSpecifier => ( storageClassSpecifier @ | typeSpecifier | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )

** [FINAL] State #27: storageClassSpecifier => ( typedef @ | extern | static | auto | register )
    --> __________________
    --> #54: declarationSpecifier => ( storageClassSpecifier @ | typeSpecifier | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )

** [FINAL] State #28: storageClassSpecifier => ( typedef | extern @ | static | auto | register )
    --> __________________
    --> #54: declarationSpecifier => ( storageClassSpecifier @ | typeSpecifier | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )

** [FINAL] State #29: storageClassSpecifier => ( typedef | extern | static @ | auto | register )
    --> __________________
    --> #54: declarationSpecifier => ( storageClassSpecifier @ | typeSpecifier | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )

** [FINAL] State #30: storageClassSpecifier => ( typedef | extern | static | auto @ | register )
    --> __________________
    --> #54: declarationSpecifier => ( storageClassSpecifier @ | typeSpecifier | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )

** [FINAL] State #31: typeSpecifier => ( void @ | char | short | int | long | float | double | signed | unsigned | bool
| structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    --> __________________
    --> #55: declarationSpecifier => ( storageClassSpecifier | typeSpecifier @ | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #56: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #57: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrU
nionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )
    -->     Type: recursion
    -->     LA: volatile const '^' '*'

** [FINAL] State #32: typeSpecifier => ( void | char @ | short | int | long | float | double | signed | unsigned | bool
| structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    --> __________________
    --> #55: declarationSpecifier => ( storageClassSpecifier | typeSpecifier @ | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #56: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #57: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrU
nionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )
    -->     Type: recursion
    -->     LA: volatile const '^' '*'

** [FINAL] State #33: typeSpecifier => ( void | char | short @ | int | long | float | double | signed | unsigned | bool
| structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    --> __________________
    --> #55: declarationSpecifier => ( storageClassSpecifier | typeSpecifier @ | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #56: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #57: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrU
nionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )
    -->     Type: recursion
    -->     LA: volatile const '^' '*'

** [FINAL] State #34: typeSpecifier => ( void | char | short | int @ | long | float | double | signed | unsigned | bool
| structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    --> __________________
    --> #55: declarationSpecifier => ( storageClassSpecifier | typeSpecifier @ | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #56: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #57: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrU
nionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )
    -->     Type: recursion
    -->     LA: volatile const '^' '*'

** [FINAL] State #35: typeSpecifier => ( void | char | short | int | long @ | float | double | signed | unsigned | bool
| structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    --> __________________
    --> #55: declarationSpecifier => ( storageClassSpecifier | typeSpecifier @ | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #56: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #57: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrU
nionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )
    -->     Type: recursion
    -->     LA: volatile const '^' '*'

** [FINAL] State #36: typeSpecifier => ( void | char | short | int | long | float @ | double | signed | unsigned | bool
| structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    --> __________________
    --> #55: declarationSpecifier => ( storageClassSpecifier | typeSpecifier @ | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #56: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #57: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrU
nionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )
    -->     Type: recursion
    -->     LA: volatile const '^' '*'

** [FINAL] State #37: typeSpecifier => ( void | char | short | int | long | float | double @ | signed | unsigned | bool
| structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    --> __________________
    --> #55: declarationSpecifier => ( storageClassSpecifier | typeSpecifier @ | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #56: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #57: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrU
nionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )
    -->     Type: recursion
    -->     LA: volatile const '^' '*'

** [FINAL] State #38: typeSpecifier => ( void | char | short | int | long | float | double | signed @ | unsigned | bool
| structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    --> __________________
    --> #55: declarationSpecifier => ( storageClassSpecifier | typeSpecifier @ | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #56: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #57: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrU
nionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )
    -->     Type: recursion
    -->     LA: volatile const '^' '*'

** [FINAL] State #39: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned @ | bool
| structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    --> __________________
    --> #55: declarationSpecifier => ( storageClassSpecifier | typeSpecifier @ | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #56: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #57: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrU
nionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )
    -->     Type: recursion
    -->     LA: volatile const '^' '*'

** [FINAL] State #40: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool @
| structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    --> __________________
    --> #55: declarationSpecifier => ( storageClassSpecifier | typeSpecifier @ | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #56: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #57: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrU
nionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )
    -->     Type: recursion
    -->     LA: volatile const '^' '*'

** State #41: structOrUnionSpecifier => @ structOrUnion ( #identifier# | [ #identifier# ] '{' structDeclarationList '}'
)
    --> __________________
    --> #58: structOrUnion => @ ( struct | union )
    -->     Type: shift
    -->     LA: struct union

** State #42: enumSpecifier => @ enum ( [ #identifier# ] '{' enumeratorList [ ',' ] '{' | #identifier# )
    --> __________________
    --> #59: enumSpecifier => enum @ ( [ #identifier# ] '{' enumeratorList [ ',' ] '{' | #identifier# )
    -->     Type: move
    -->     LA: enum

** State #43: typedefName => @ #identifier#
    --> __________________
    --> #60: typedefName => #identifier# @
    -->     Type: move
    -->     LA: #identifier#

** [FINAL] State #44: abstractDeclarator => ( pointer @ | [ pointer ] directAbstractDeclarator )
    --> __________________
    --> #61: directAbstractDeclarator => ( '(' abstractDeclarator @ ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQua
lifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: reduce
    -->     Reduce: directAbstractDeclarator => ( '(' @ abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [
typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #62: parameterDeclaration => ( declarationSpecifiers declarator | declarationSpecifiers2 [ abstractDeclarator @
] )
    -->     Type: reduce
    -->     Reduce: parameterDeclaration => ( declarationSpecifiers declarator | declarationSpecifiers2 @ [ abstractDecl
arator ] )
    --> __________________
    --> #63: typeName => specifierQualifierList [ abstractDeclarator @ ]
    -->     Type: reduce
    -->     Reduce: typeName => specifierQualifierList @ [ abstractDeclarator ]

** State #45: abstractDeclarator => ( pointer | [ pointer @ ] directAbstractDeclarator )
    --> __________________
    --> #64: directAbstractDeclarator => @ ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQua
lifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: shift
    -->     LA: '(' '['

** State #46: declarator => [ pointer @ ] directDeclarator
    --> __________________
    --> #13: directDeclarator => @ ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList ] (
assignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    -->     Type: shift
    -->     LA: #identifier# '('

** State #47: pointer => [ typeQualifierList ] [ pointer @ ] ( '*' | '^' )
    --> __________________
    --> #21: pointer => [ typeQualifierList ] [ pointer ] ( '*' | '^' @ )
    -->     Type: move
    -->     LA: '^'
    --> __________________
    --> #20: pointer => [ typeQualifierList ] [ pointer ] ( '*' @ | '^' )
    -->     Type: move
    -->     LA: '*'

** [FINAL] State #48: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool |
structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer @ )
    --> __________________
    --> #55: declarationSpecifier => ( storageClassSpecifier | typeSpecifier @ | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #56: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #57: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrU
nionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )
    -->     Type: recursion
    -->     LA: volatile const '^' '*'

** [FINAL] State #49: declarator => [ pointer ] directDeclarator @
    --> __________________
    --> #65: directDeclarator => ( #identifier# | '(' declarator @ ')' | directDeclarator ( '[' [ typeQualifierList ] (
assignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    -->     Type: reduce
    -->     Reduce: directDeclarator => ( #identifier# | '(' @ declarator ')' | directDeclarator ( '[' [ typeQualifierLi
st ] ( assignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    --> __________________
    --> #66: functionDefinition => [ declarationSpecifiers ] declarator @ [ declarationList ] compoundStatement
    -->     Type: reduce
    -->     Reduce: functionDefinition => [ @ declarationSpecifiers ] declarator [ declarationList ] compoundStatement
    --> __________________
    --> #66: functionDefinition => [ declarationSpecifiers ] declarator @ [ declarationList ] compoundStatement
    -->     Type: reduce
    -->     Reduce: functionDefinition => [ declarationSpecifiers @ ] declarator [ declarationList ] compoundStatement
    --> __________________
    --> #67: initDeclarator => declarator @ [ '=' initializer ]
    -->     Type: reduce
    -->     Reduce: initDeclarator => @ declarator [ '=' initializer ]
    --> __________________
    --> #68: parameterDeclaration => ( declarationSpecifiers declarator @ | declarationSpecifiers2 [ abstractDeclarator
] )
    -->     Type: reduce
    -->     Reduce: parameterDeclaration => ( declarationSpecifiers @ declarator | declarationSpecifiers2 [ abstractDecl
arator ] )
    --> __________________
    --> #69: structDeclarator => ( declarator @ | [ declarator ] '=' constantExpression )
    -->     Type: reduce
    -->     Reduce: structDeclarator => @ ( declarator | [ declarator ] '=' constantExpression )
    --> __________________
    --> #70: structDeclarator => ( declarator | [ declarator @ ] '=' constantExpression )
    -->     Type: reduce
    -->     Reduce: structDeclarator => @ ( declarator | [ declarator ] '=' constantExpression )

** State #50: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator @ ( '[' [ typeQualifierList ] (
 assignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    --> __________________
    --> #71: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList ] ( as
signmentExpression | '*' ) ']' | '(' @ ( parameterTypeList | [ identifierList ] ) ')' ) )
    -->     Type: move
    -->     LA: '('
    --> __________________
    --> #72: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' @ [ typeQualifierList ] (
assignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    -->     Type: move
    -->     LA: '['

** [FINAL] State #51: declarationSpecifier => ( storageClassSpecifier | typeSpecifier | typeQualifier @ )
    --> __________________
    --> #73: declarationSpecifiers => declarationSpecifier @ [ declarationSpecifiers ]
    -->     Type: reduce
    -->     Reduce: declarationSpecifiers => @ declarationSpecifier [ declarationSpecifiers ]
    --> __________________
    --> #74: declarationSpecifiers2 => declarationSpecifier @ [ declarationSpecifiers ]
    -->     Type: reduce
    -->     Reduce: declarationSpecifiers2 => @ declarationSpecifier [ declarationSpecifiers ]

** [FINAL] State #52: specifierQualifierList => ( typeSpecifier | typeQualifier @ ) [ specifierQualifierList ]
    --> __________________
    --> #75: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    -->     Type: shift
    -->     LA: volatile const short signed #identifier#
    -->     LA: void unsigned float long char
    -->     LA: bool int enum double struct
    -->     LA: union
    --> __________________
    --> #76: specifierQualifierList => ( typeSpecifier | typeQualifier ) [ specifierQualifierList @ ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => ( typeSpecifier | typeQualifier @ ) [ specifierQualifierList ]
    --> __________________
    --> #76: specifierQualifierList => ( typeSpecifier | typeQualifier ) [ specifierQualifierList @ ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #77: structDeclaration => specifierQualifierList @ [ structDeclaratorList ] ';'
    -->     Type: reduce
    -->     Reduce: structDeclaration => @ specifierQualifierList [ structDeclaratorList ] ';'
    --> __________________
    --> #78: typeName => specifierQualifierList @ [ abstractDeclarator ]
    -->     Type: reduce
    -->     Reduce: typeName => @ specifierQualifierList [ abstractDeclarator ]

** [FINAL] State #53: typeQualifierList => [ typeQualifierList ] typeQualifier @
    --> __________________
    --> #79: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQuali
fierList @ ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: reduce
    -->     Reduce: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' @ ( [
typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #80: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList @ ] (
assignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    -->     Type: reduce
    -->     Reduce: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' @ [ typeQualifierLi
st ] ( assignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    --> __________________
    --> #81: pointer => [ typeQualifierList @ ] [ pointer ] ( '*' | '^' )
    -->     Type: reduce
    -->     Reduce: pointer => [ @ typeQualifierList ] [ pointer ] ( '*' | '^' )
    --> __________________
    --> #82: typeQualifierList => [ typeQualifierList @ ] typeQualifier
    -->     Type: recursion
    -->     LA: const volatile

** [FINAL] State #54: declarationSpecifier => ( storageClassSpecifier @ | typeSpecifier | typeQualifier )
    --> __________________
    --> #73: declarationSpecifiers => declarationSpecifier @ [ declarationSpecifiers ]
    -->     Type: reduce
    -->     Reduce: declarationSpecifiers => @ declarationSpecifier [ declarationSpecifiers ]
    --> __________________
    --> #74: declarationSpecifiers2 => declarationSpecifier @ [ declarationSpecifiers ]
    -->     Type: reduce
    -->     Reduce: declarationSpecifiers2 => @ declarationSpecifier [ declarationSpecifiers ]

** [FINAL] State #55: declarationSpecifier => ( storageClassSpecifier | typeSpecifier @ | typeQualifier )
    --> __________________
    --> #73: declarationSpecifiers => declarationSpecifier @ [ declarationSpecifiers ]
    -->     Type: reduce
    -->     Reduce: declarationSpecifiers => @ declarationSpecifier [ declarationSpecifiers ]
    --> __________________
    --> #74: declarationSpecifiers2 => declarationSpecifier @ [ declarationSpecifiers ]
    -->     Type: reduce
    -->     Reduce: declarationSpecifiers2 => @ declarationSpecifier [ declarationSpecifiers ]

** [FINAL] State #56: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #75: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    -->     Type: shift
    -->     LA: volatile const short signed #identifier#
    -->     LA: void unsigned float long char
    -->     LA: bool int enum double struct
    -->     LA: union
    --> __________________
    --> #76: specifierQualifierList => ( typeSpecifier | typeQualifier ) [ specifierQualifierList @ ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => ( typeSpecifier | typeQualifier @ ) [ specifierQualifierList ]
    --> __________________
    --> #76: specifierQualifierList => ( typeSpecifier | typeQualifier ) [ specifierQualifierList @ ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #77: structDeclaration => specifierQualifierList @ [ structDeclaratorList ] ';'
    -->     Type: reduce
    -->     Reduce: structDeclaration => @ specifierQualifierList [ structDeclaratorList ] ';'
    --> __________________
    --> #78: typeName => specifierQualifierList @ [ abstractDeclarator ]
    -->     Type: reduce
    -->     Reduce: typeName => @ specifierQualifierList [ abstractDeclarator ]

** State #57: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOr
UnionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )
    --> __________________
    --> #12: pointer => [ @ typeQualifierList ] [ pointer ] ( '*' | '^' )
    -->     Type: shift
    -->     LA: volatile const '^' '*'

** State #58: structOrUnion => @ ( struct | union )
    --> __________________
    --> #83: structOrUnion => ( struct | union @ )
    -->     Type: move
    -->     LA: union
    --> __________________
    --> #84: structOrUnion => ( struct @ | union )
    -->     Type: move
    -->     LA: struct

** State #59: enumSpecifier => enum @ ( [ #identifier# ] '{' enumeratorList [ ',' ] '{' | #identifier# )
    --> __________________
    --> #85: enumSpecifier => enum ( [ #identifier# ] '{' @ enumeratorList [ ',' ] '{' | #identifier# )
    -->     Type: move
    -->     LA: '{'
    --> __________________
    --> #86: enumSpecifier => enum ( [ #identifier# @ ] '{' enumeratorList [ ',' ] '{' | #identifier# )
    -->     Type: move
    -->     LA: #identifier#
    --> __________________
    --> #87: enumSpecifier => enum ( [ #identifier# ] '{' enumeratorList [ ',' ] '{' | #identifier# @ )
    -->     Type: move
    -->     LA: #identifier#

** [FINAL] State #60: typedefName => #identifier# @
    --> __________________
    --> #88: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrU
nionSpecifier | enumSpecifier | typedefName @ | typeSpecifier pointer )
    -->     Type: reduce
    -->     Reduce: typeSpecifier => @ ( void | char | short | int | long | float | double | signed | unsigned | bool |
structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )

** State #61: directAbstractDeclarator => ( '(' abstractDeclarator @ ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQu
alifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #89: directAbstractDeclarator => ( '(' abstractDeclarator ')' @ | [ directAbstractDeclarator ] ( '[' ( [ typeQua
lifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: move
    -->     LA: ')'

** [FINAL] State #62: parameterDeclaration => ( declarationSpecifiers declarator | declarationSpecifiers2 [ abstractDecl
arator @ ] )
    --> __________________
    --> #90: parameterList => [ parameterList ',' ] parameterDeclaration @
    -->     Type: reduce
    -->     Reduce: parameterList => [ @ parameterList ',' ] parameterDeclaration
    --> __________________
    --> #90: parameterList => [ parameterList ',' ] parameterDeclaration @
    -->     Type: reduce
    -->     Reduce: parameterList => [ parameterList ',' @ ] parameterDeclaration

** [FINAL] State #63: typeName => specifierQualifierList [ abstractDeclarator @ ]
    --> __________________
    --> #91: castExpression => ( '(' typeName @ ')' castExpression | unaryExpression )
    -->     Type: reduce
    -->     Reduce: castExpression => ( '(' @ typeName ')' castExpression | unaryExpression )
    --> __________________
    --> #92: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpressio
nList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName @ ')' '{' initializerList [ ',' ] '}'
)
    -->     Type: reduce
    -->     Reduce: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentEx
pressionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' @ typeName ')' '{' initializerList [ ','
 ] '}' )
    --> __________________
    --> #93: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | s
izeof ( unaryExpression | '(' typeName @ ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpress
ion | sizeof ( unaryExpression | '(' @ typeName ')' ) )

** State #64: directAbstractDeclarator => @ ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQu
alifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #94: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQuali
fierList ] [ assignmentExpression ] | '*' ) ']' | '(' @ [ parameterTypeList ] ')' ) )
    -->     Type: move
    -->     LA: '('
    --> __________________
    --> #95: directAbstractDeclarator => ( '(' @ abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQua
lifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: move
    -->     LA: '('
    --> __________________
    --> #96: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' @ ( [ typeQua
lifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: move
    -->     LA: '['

** State #65: directDeclarator => ( #identifier# | '(' declarator @ ')' | directDeclarator ( '[' [ typeQualifierList ] (
 assignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    --> __________________
    --> #97: directDeclarator => ( #identifier# | '(' declarator ')' @ | directDeclarator ( '[' [ typeQualifierList ] (
assignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    -->     Type: move
    -->     LA: ')'

** State #66: functionDefinition => [ declarationSpecifiers ] declarator @ [ declarationList ] compoundStatement
    --> __________________
    --> #98: compoundStatement => @ '{' [ blockItemList ] '}'
    -->     Type: shift
    -->     LA: '{'
    --> __________________
    --> #99: declarationList => [ @ declarationList ] declaration
    -->     Type: shift
    -->     LA: register typedef extern static auto
    -->     LA: signed #identifier# volatile const short
    -->     LA: void double unsigned float long
    -->     LA: char bool int enum struct
    -->     LA: union

** [FINAL] State #67: initDeclarator => declarator @ [ '=' initializer ]
    --> __________________
    --> #100: initDeclarator => declarator [ '=' @ initializer ]
    -->     Type: move
    -->     LA: '='
    --> __________________
    --> #101: initDeclaratorList => [ initDeclaratorList ',' ] initDeclarator @
    -->     Type: reduce
    -->     Reduce: initDeclaratorList => [ @ initDeclaratorList ',' ] initDeclarator
    --> __________________
    --> #101: initDeclaratorList => [ initDeclaratorList ',' ] initDeclarator @
    -->     Type: reduce
    -->     Reduce: initDeclaratorList => [ initDeclaratorList ',' @ ] initDeclarator

** [FINAL] State #68: parameterDeclaration => ( declarationSpecifiers declarator @ | declarationSpecifiers2 [ abstractDe
clarator ] )
    --> __________________
    --> #90: parameterList => [ parameterList ',' ] parameterDeclaration @
    -->     Type: reduce
    -->     Reduce: parameterList => [ @ parameterList ',' ] parameterDeclaration
    --> __________________
    --> #90: parameterList => [ parameterList ',' ] parameterDeclaration @
    -->     Type: reduce
    -->     Reduce: parameterList => [ parameterList ',' @ ] parameterDeclaration

** [FINAL] State #69: structDeclarator => ( declarator @ | [ declarator ] '=' constantExpression )
    --> __________________
    --> #102: structDeclaratorList => [ structDeclaratorList ',' ] structDeclarator @
    -->     Type: reduce
    -->     Reduce: structDeclaratorList => [ @ structDeclaratorList ',' ] structDeclarator
    --> __________________
    --> #102: structDeclaratorList => [ structDeclaratorList ',' ] structDeclarator @
    -->     Type: reduce
    -->     Reduce: structDeclaratorList => [ structDeclaratorList ',' @ ] structDeclarator

** State #70: structDeclarator => ( declarator | [ declarator @ ] '=' constantExpression )
    --> __________________
    --> #103: structDeclarator => ( declarator | [ declarator ] '=' @ constantExpression )
    -->     Type: move
    -->     LA: '='

** State #71: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList ] ( a
ssignmentExpression | '*' ) ']' | '(' @ ( parameterTypeList | [ identifierList ] ) ')' ) )
    --> __________________
    --> #104: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList ] ( a
ssignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' @ ) )
    -->     Type: move
    -->     LA: ')'
    --> __________________
    --> #105: parameterTypeList => @ parameterList [ ',' '...' ]
    -->     Type: shift
    -->     LA: register typedef extern static auto
    -->     LA: signed #identifier# volatile const short
    -->     LA: void double unsigned float long
    -->     LA: char bool int enum struct
    -->     LA: union
    --> __________________
    --> #106: identifierList => [ @ identifierList ',' ] #identifier#
    -->     Type: shift
    -->     LA: #identifier#

** State #72: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' @ [ typeQualifierList ] (
 assignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    --> __________________
    --> #107: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList ] ( a
ssignmentExpression | '*' @ ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    -->     Type: move
    -->     LA: '*'
    --> __________________
    --> #19: typeQualifierList => [ @ typeQualifierList ] typeQualifier
    -->     Type: shift
    -->     LA: volatile const
    --> __________________
    --> #108: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExpressio
n )
    -->     Type: shift
    -->     LA: #float# #ulong# #long# #int# #char#
    -->     LA: #identifier# #string# sizeof '!' '--'
    -->     LA: '++' '-' #ushort# '(' #short#
    -->     LA: '~' '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** [FINAL] State #73: declarationSpecifiers => declarationSpecifier @ [ declarationSpecifiers ]
    --> __________________
    --> #7: declarationSpecifiers => @ declarationSpecifier [ declarationSpecifiers ]
    -->     Type: shift
    -->     LA: union struct enum int bool
    -->     LA: char long float unsigned double
    -->     LA: void short const volatile #identifier#
    -->     LA: signed auto static extern typedef
    -->     LA: register
    --> __________________
    --> #109: declaration => declarationSpecifiers @ [ initDeclaratorList ] ';'
    -->     Type: reduce
    -->     Reduce: declaration => @ declarationSpecifiers [ initDeclaratorList ] ';'
    --> __________________
    --> #110: declarationSpecifiers => declarationSpecifier [ declarationSpecifiers @ ]
    -->     Type: reduce
    -->     Reduce: declarationSpecifiers => declarationSpecifier @ [ declarationSpecifiers ]
    --> __________________
    --> #111: declarationSpecifiers2 => declarationSpecifier [ declarationSpecifiers @ ]
    -->     Type: reduce
    -->     Reduce: declarationSpecifiers2 => declarationSpecifier @ [ declarationSpecifiers ]
    --> __________________
    --> #112: forDeclaration => declarationSpecifiers @ [ initDeclaratorList ]
    -->     Type: reduce
    -->     Reduce: forDeclaration => @ declarationSpecifiers [ initDeclaratorList ]
    --> __________________
    --> #113: functionDefinition => [ declarationSpecifiers @ ] declarator [ declarationList ] compoundStatement
    -->     Type: reduce
    -->     Reduce: functionDefinition => [ @ declarationSpecifiers ] declarator [ declarationList ] compoundStatement
    --> __________________
    --> #114: parameterDeclaration => ( declarationSpecifiers @ declarator | declarationSpecifiers2 [ abstractDeclarator
 ] )
    -->     Type: reduce
    -->     Reduce: parameterDeclaration => @ ( declarationSpecifiers declarator | declarationSpecifiers2 [ abstractDecl
arator ] )

** [FINAL] State #74: declarationSpecifiers2 => declarationSpecifier @ [ declarationSpecifiers ]
    --> __________________
    --> #7: declarationSpecifiers => @ declarationSpecifier [ declarationSpecifiers ]
    -->     Type: shift
    -->     LA: union struct enum int bool
    -->     LA: char long float unsigned double
    -->     LA: void short const volatile #identifier#
    -->     LA: signed auto static extern typedef
    -->     LA: register
    --> __________________
    --> #115: parameterDeclaration => ( declarationSpecifiers declarator | declarationSpecifiers2 @ [ abstractDeclarator
 ] )
    -->     Type: reduce
    -->     Reduce: parameterDeclaration => @ ( declarationSpecifiers declarator | declarationSpecifiers2 [ abstractDecl
arator ] )

** State #75: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #16: typeQualifier => @ ( const | volatile )
    -->     Type: shift
    -->     LA: const volatile
    --> __________________
    --> #18: typeSpecifier => @ ( void | char | short | int | long | float | double | signed | unsigned | bool | structO
rUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    -->     Type: shift
    -->     LA: union enum char short long
    -->     LA: void struct double float unsigned
    -->     LA: #identifier# signed int bool

** [FINAL] State #76: specifierQualifierList => ( typeSpecifier | typeQualifier ) [ specifierQualifierList @ ]
    --> __________________
    --> #76: specifierQualifierList => ( typeSpecifier | typeQualifier ) [ specifierQualifierList @ ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => ( typeSpecifier | typeQualifier @ ) [ specifierQualifierList ]
    --> __________________
    --> #76: specifierQualifierList => ( typeSpecifier | typeQualifier ) [ specifierQualifierList @ ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #77: structDeclaration => specifierQualifierList @ [ structDeclaratorList ] ';'
    -->     Type: reduce
    -->     Reduce: structDeclaration => @ specifierQualifierList [ structDeclaratorList ] ';'
    --> __________________
    --> #78: typeName => specifierQualifierList @ [ abstractDeclarator ]
    -->     Type: reduce
    -->     Reduce: typeName => @ specifierQualifierList [ abstractDeclarator ]

** State #77: structDeclaration => specifierQualifierList @ [ structDeclaratorList ] ';'
    --> __________________
    --> #116: structDeclaration => specifierQualifierList [ structDeclaratorList ] ';' @
    -->     Type: move
    -->     LA: ';'
    --> __________________
    --> #117: structDeclaratorList => [ @ structDeclaratorList ',' ] structDeclarator
    -->     Type: shift
    -->     LA: volatile const '^' #identifier# '*'
    -->     LA: '(' '='

** [FINAL] State #78: typeName => specifierQualifierList @ [ abstractDeclarator ]
    --> __________________
    --> #118: abstractDeclarator => @ ( pointer | [ pointer ] directAbstractDeclarator )
    -->     Type: shift
    -->     LA: '[' '(' '*' '^' const
    -->     LA: volatile
    --> __________________
    --> #91: castExpression => ( '(' typeName @ ')' castExpression | unaryExpression )
    -->     Type: reduce
    -->     Reduce: castExpression => ( '(' @ typeName ')' castExpression | unaryExpression )
    --> __________________
    --> #92: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpressio
nList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName @ ')' '{' initializerList [ ',' ] '}'
)
    -->     Type: reduce
    -->     Reduce: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentEx
pressionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' @ typeName ')' '{' initializerList [ ','
 ] '}' )
    --> __________________
    --> #93: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | s
izeof ( unaryExpression | '(' typeName @ ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpress
ion | sizeof ( unaryExpression | '(' @ typeName ')' ) )

** State #79: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQual
ifierList @ ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #119: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQual
ifierList ] [ assignmentExpression ] | '*' ) ']' @ | '(' [ parameterTypeList ] ')' ) )
    -->     Type: move
    -->     LA: ']'
    --> __________________
    --> #108: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExpressio
n )
    -->     Type: shift
    -->     LA: #float# #ulong# #long# #int# #char#
    -->     LA: #identifier# #string# sizeof '!' '--'
    -->     LA: '++' '-' #ushort# '(' #short#
    -->     LA: '~' '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #80: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList @ ] (
 assignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    --> __________________
    --> #107: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList ] ( a
ssignmentExpression | '*' @ ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    -->     Type: move
    -->     LA: '*'
    --> __________________
    --> #108: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExpressio
n )
    -->     Type: shift
    -->     LA: #float# #ulong# #long# #int# #char#
    -->     LA: #identifier# #string# sizeof '!' '--'
    -->     LA: '++' '-' #ushort# '(' #short#
    -->     LA: '~' '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #81: pointer => [ typeQualifierList @ ] [ pointer ] ( '*' | '^' )
    --> __________________
    --> #21: pointer => [ typeQualifierList ] [ pointer ] ( '*' | '^' @ )
    -->     Type: move
    -->     LA: '^'
    --> __________________
    --> #12: pointer => [ @ typeQualifierList ] [ pointer ] ( '*' | '^' )
    -->     Type: shift
    -->     LA: volatile const '^' '*'
    --> __________________
    --> #20: pointer => [ typeQualifierList ] [ pointer ] ( '*' @ | '^' )
    -->     Type: move
    -->     LA: '*'

** State #82: typeQualifierList => [ typeQualifierList @ ] typeQualifier
    --> __________________
    --> #16: typeQualifier => @ ( const | volatile )
    -->     Type: shift
    -->     LA: const volatile

** [FINAL] State #83: structOrUnion => ( struct | union @ )
    --> __________________
    --> #120: structOrUnionSpecifier => structOrUnion @ ( #identifier# | [ #identifier# ] '{' structDeclarationList '}'
)
    -->     Type: reduce
    -->     Reduce: structOrUnionSpecifier => @ structOrUnion ( #identifier# | [ #identifier# ] '{' structDeclarationLis
t '}' )

** [FINAL] State #84: structOrUnion => ( struct @ | union )
    --> __________________
    --> #120: structOrUnionSpecifier => structOrUnion @ ( #identifier# | [ #identifier# ] '{' structDeclarationList '}'
)
    -->     Type: reduce
    -->     Reduce: structOrUnionSpecifier => @ structOrUnion ( #identifier# | [ #identifier# ] '{' structDeclarationLis
t '}' )

** State #85: enumSpecifier => enum ( [ #identifier# ] '{' @ enumeratorList [ ',' ] '{' | #identifier# )
    --> __________________
    --> #121: enumeratorList => [ @ enumeratorList ',' ] enumerator
    -->     Type: shift
    -->     LA: #identifier#

** State #86: enumSpecifier => enum ( [ #identifier# @ ] '{' enumeratorList [ ',' ] '{' | #identifier# )
    --> __________________
    --> #85: enumSpecifier => enum ( [ #identifier# ] '{' @ enumeratorList [ ',' ] '{' | #identifier# )
    -->     Type: move
    -->     LA: '{'

** [FINAL] State #87: enumSpecifier => enum ( [ #identifier# ] '{' enumeratorList [ ',' ] '{' | #identifier# @ )
    --> __________________
    --> #122: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOr
UnionSpecifier | enumSpecifier @ | typedefName | typeSpecifier pointer )
    -->     Type: reduce
    -->     Reduce: typeSpecifier => @ ( void | char | short | int | long | float | double | signed | unsigned | bool |
structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )

** [FINAL] State #88: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool |
structOrUnionSpecifier | enumSpecifier | typedefName @ | typeSpecifier pointer )
    --> __________________
    --> #55: declarationSpecifier => ( storageClassSpecifier | typeSpecifier @ | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #56: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #57: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrU
nionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )
    -->     Type: recursion
    -->     LA: volatile const '^' '*'

** [FINAL] State #89: directAbstractDeclarator => ( '(' abstractDeclarator ')' @ | [ directAbstractDeclarator ] ( '[' (
[ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #123: abstractDeclarator => ( pointer | [ pointer ] directAbstractDeclarator @ )
    -->     Type: reduce
    -->     Reduce: abstractDeclarator => @ ( pointer | [ pointer ] directAbstractDeclarator )
    --> __________________
    --> #123: abstractDeclarator => ( pointer | [ pointer ] directAbstractDeclarator @ )
    -->     Type: reduce
    -->     Reduce: abstractDeclarator => ( pointer | [ pointer @ ] directAbstractDeclarator )
    --> __________________
    --> #124: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator @ ] ( '[' ( [ typeQu
alifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: recursion
    -->     LA: '[' '('

** [FINAL] State #90: parameterList => [ parameterList ',' ] parameterDeclaration @
    --> __________________
    --> #125: parameterList => [ parameterList @ ',' ] parameterDeclaration
    -->     Type: recursion
    -->     LA: ','
    --> __________________
    --> #126: parameterTypeList => parameterList @ [ ',' '...' ]
    -->     Type: reduce
    -->     Reduce: parameterTypeList => @ parameterList [ ',' '...' ]

** State #91: castExpression => ( '(' typeName @ ')' castExpression | unaryExpression )
    --> __________________
    --> #127: castExpression => ( '(' typeName ')' @ castExpression | unaryExpression )
    -->     Type: move
    -->     LA: ')'

** State #92: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpressi
onList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName @ ')' '{' initializerList [ ',' ] '}'
 )
    --> __________________
    --> #128: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpressi
onList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' @ '{' initializerList [ ',' ] '}'
 )
    -->     Type: move
    -->     LA: ')'

** State #93: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression |
sizeof ( unaryExpression | '(' typeName @ ')' ) )
    --> __________________
    --> #129: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression |
sizeof ( unaryExpression | '(' typeName ')' @ ) )
    -->     Type: move
    -->     LA: ')'

** State #94: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQual
ifierList ] [ assignmentExpression ] | '*' ) ']' | '(' @ [ parameterTypeList ] ')' ) )
    --> __________________
    --> #130: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQual
ifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' @ ) )
    -->     Type: move
    -->     LA: ')'
    --> __________________
    --> #105: parameterTypeList => @ parameterList [ ',' '...' ]
    -->     Type: shift
    -->     LA: register typedef extern static auto
    -->     LA: signed #identifier# volatile const short
    -->     LA: void double unsigned float long
    -->     LA: char bool int enum struct
    -->     LA: union

** State #95: directAbstractDeclarator => ( '(' @ abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQu
alifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #118: abstractDeclarator => @ ( pointer | [ pointer ] directAbstractDeclarator )
    -->     Type: shift
    -->     LA: '[' '(' '*' '^' const
    -->     LA: volatile

** State #96: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' @ ( [ typeQu
alifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #119: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQual
ifierList ] [ assignmentExpression ] | '*' ) ']' @ | '(' [ parameterTypeList ] ')' ) )
    -->     Type: move
    -->     LA: ']'
    --> __________________
    --> #19: typeQualifierList => [ @ typeQualifierList ] typeQualifier
    -->     Type: shift
    -->     LA: volatile const
    --> __________________
    --> #131: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQual
ifierList ] [ assignmentExpression ] | '*' @ ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: move
    -->     LA: '*'
    --> __________________
    --> #108: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExpressio
n )
    -->     Type: shift
    -->     LA: #float# #ulong# #long# #int# #char#
    -->     LA: #identifier# #string# sizeof '!' '--'
    -->     LA: '++' '-' #ushort# '(' #short#
    -->     LA: '~' '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** [FINAL] State #97: directDeclarator => ( #identifier# | '(' declarator ')' @ | directDeclarator ( '[' [ typeQualifier
List ] ( assignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    --> __________________
    --> #49: declarator => [ pointer ] directDeclarator @
    -->     Type: reduce
    -->     Reduce: declarator => [ @ pointer ] directDeclarator
    --> __________________
    --> #49: declarator => [ pointer ] directDeclarator @
    -->     Type: reduce
    -->     Reduce: declarator => [ pointer @ ] directDeclarator
    --> __________________
    --> #50: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator @ ( '[' [ typeQualifierList ] (
assignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    -->     Type: recursion
    -->     LA: '[' '('

** State #98: compoundStatement => @ '{' [ blockItemList ] '}'
    --> __________________
    --> #132: compoundStatement => '{' @ [ blockItemList ] '}'
    -->     Type: move
    -->     LA: '{'

** State #99: declarationList => [ @ declarationList ] declaration
    --> __________________
    --> #5: declaration => @ declarationSpecifiers [ initDeclaratorList ] ';'
    -->     Type: shift
    -->     LA: union struct enum int bool
    -->     LA: char long float unsigned double
    -->     LA: void short const volatile #identifier#
    -->     LA: signed auto static extern typedef
    -->     LA: register

** State #100: initDeclarator => declarator [ '=' @ initializer ]
    --> __________________
    --> #133: initializer => @ ( assignmentExpression | '{' initializerList [ ',' ] '}' )
    -->     Type: shift
    -->     LA: '{' #string# #float# '~' #ulong#
    -->     LA: #long# #int# '!' #char# sizeof
    -->     LA: #identifier# '--' '++' '-' #ushort#
    -->     LA: '(' #double# #short# '+' #uchar#
    -->     LA: '*' #uint# '&'

** [FINAL] State #101: initDeclaratorList => [ initDeclaratorList ',' ] initDeclarator @
    --> __________________
    --> #134: declaration => declarationSpecifiers [ initDeclaratorList @ ] ';'
    -->     Type: reduce
    -->     Reduce: declaration => declarationSpecifiers @ [ initDeclaratorList ] ';'
    --> __________________
    --> #135: forDeclaration => declarationSpecifiers [ initDeclaratorList @ ]
    -->     Type: reduce
    -->     Reduce: forDeclaration => declarationSpecifiers @ [ initDeclaratorList ]
    --> __________________
    --> #136: initDeclaratorList => [ initDeclaratorList @ ',' ] initDeclarator
    -->     Type: recursion
    -->     LA: ','

** [FINAL] State #102: structDeclaratorList => [ structDeclaratorList ',' ] structDeclarator @
    --> __________________
    --> #137: structDeclaration => specifierQualifierList [ structDeclaratorList @ ] ';'
    -->     Type: reduce
    -->     Reduce: structDeclaration => specifierQualifierList @ [ structDeclaratorList ] ';'
    --> __________________
    --> #138: structDeclaratorList => [ structDeclaratorList @ ',' ] structDeclarator
    -->     Type: recursion
    -->     LA: ','

** State #103: structDeclarator => ( declarator | [ declarator ] '=' @ constantExpression )
    --> __________________
    --> #139: constantExpression => @ conditionalExpression
    -->     Type: shift
    -->     LA: #double# '&' '*' #uint# '+'
    -->     LA: #uchar# #float# '~' #short# '('
    -->     LA: '-' #ushort# '++' '--' '!'
    -->     LA: #int# #char# sizeof #string# #identifier#
    -->     LA: #long# #ulong#

** [FINAL] State #104: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierL
ist ] ( assignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' @ ) )
    --> __________________
    --> #49: declarator => [ pointer ] directDeclarator @
    -->     Type: reduce
    -->     Reduce: declarator => [ @ pointer ] directDeclarator
    --> __________________
    --> #49: declarator => [ pointer ] directDeclarator @
    -->     Type: reduce
    -->     Reduce: declarator => [ pointer @ ] directDeclarator
    --> __________________
    --> #50: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator @ ( '[' [ typeQualifierList ] (
assignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    -->     Type: recursion
    -->     LA: '[' '('

** State #105: parameterTypeList => @ parameterList [ ',' '...' ]
    --> __________________
    --> #140: parameterList => [ @ parameterList ',' ] parameterDeclaration
    -->     Type: shift
    -->     LA: union struct enum int bool
    -->     LA: char long float unsigned double
    -->     LA: void short const volatile #identifier#
    -->     LA: signed auto static extern typedef
    -->     LA: register

** State #106: identifierList => [ @ identifierList ',' ] #identifier#
    --> __________________
    --> #141: identifierList => [ identifierList ',' ] #identifier# @
    -->     Type: move
    -->     LA: #identifier#

** State #107: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList ] (
assignmentExpression | '*' @ ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    --> __________________
    --> #142: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList ] ( a
ssignmentExpression | '*' ) ']' @ | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    -->     Type: move
    -->     LA: ']'

** State #108: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExpressi
on )
    --> __________________
    --> #143: unaryExpression => @ ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: shift
    -->     LA: '&' #double# '*' #uint# '+'
    -->     LA: #uchar# '~' #short# '-' '('
    -->     LA: #ushort# '++' '--' '!' sizeof
    -->     LA: #string# #identifier# #char# #int# #long#
    -->     LA: #ulong# #float#
    --> __________________
    --> #144: conditionalExpression => @ logicalOrExpression [ '?' expression '=' conditionalExpression ]
    -->     Type: shift
    -->     LA: #double# '&' '*' #uint# '+'
    -->     LA: #uchar# #float# '~' #short# '('
    -->     LA: '-' #ushort# '++' '--' '!'
    -->     LA: #int# #char# sizeof #string# #identifier#
    -->     LA: #long# #ulong#

** State #109: declaration => declarationSpecifiers @ [ initDeclaratorList ] ';'
    --> __________________
    --> #145: declaration => declarationSpecifiers [ initDeclaratorList ] ';' @
    -->     Type: move
    -->     LA: ';'
    --> __________________
    --> #146: initDeclaratorList => [ @ initDeclaratorList ',' ] initDeclarator
    -->     Type: shift
    -->     LA: volatile const '^' #identifier# '*'
    -->     LA: '('

** [FINAL] State #110: declarationSpecifiers => declarationSpecifier [ declarationSpecifiers @ ]
    --> __________________
    --> #109: declaration => declarationSpecifiers @ [ initDeclaratorList ] ';'
    -->     Type: reduce
    -->     Reduce: declaration => @ declarationSpecifiers [ initDeclaratorList ] ';'
    --> __________________
    --> #110: declarationSpecifiers => declarationSpecifier [ declarationSpecifiers @ ]
    -->     Type: reduce
    -->     Reduce: declarationSpecifiers => declarationSpecifier @ [ declarationSpecifiers ]
    --> __________________
    --> #111: declarationSpecifiers2 => declarationSpecifier [ declarationSpecifiers @ ]
    -->     Type: reduce
    -->     Reduce: declarationSpecifiers2 => declarationSpecifier @ [ declarationSpecifiers ]
    --> __________________
    --> #112: forDeclaration => declarationSpecifiers @ [ initDeclaratorList ]
    -->     Type: reduce
    -->     Reduce: forDeclaration => @ declarationSpecifiers [ initDeclaratorList ]
    --> __________________
    --> #113: functionDefinition => [ declarationSpecifiers @ ] declarator [ declarationList ] compoundStatement
    -->     Type: reduce
    -->     Reduce: functionDefinition => [ @ declarationSpecifiers ] declarator [ declarationList ] compoundStatement
    --> __________________
    --> #114: parameterDeclaration => ( declarationSpecifiers @ declarator | declarationSpecifiers2 [ abstractDeclarator
 ] )
    -->     Type: reduce
    -->     Reduce: parameterDeclaration => @ ( declarationSpecifiers declarator | declarationSpecifiers2 [ abstractDecl
arator ] )

** [FINAL] State #111: declarationSpecifiers2 => declarationSpecifier [ declarationSpecifiers @ ]
    --> __________________
    --> #115: parameterDeclaration => ( declarationSpecifiers declarator | declarationSpecifiers2 @ [ abstractDeclarator
 ] )
    -->     Type: reduce
    -->     Reduce: parameterDeclaration => @ ( declarationSpecifiers declarator | declarationSpecifiers2 [ abstractDecl
arator ] )

** [FINAL] State #112: forDeclaration => declarationSpecifiers @ [ initDeclaratorList ]
    --> __________________
    --> #146: initDeclaratorList => [ @ initDeclaratorList ',' ] initDeclarator
    -->     Type: shift
    -->     LA: volatile const '^' #identifier# '*'
    -->     LA: '('
    --> __________________
    --> #147: forCondition => ( forDeclaration @ | [ expression ] ) ';' [ forExpression ] ';' [ forExpression ]
    -->     Type: reduce
    -->     Reduce: forCondition => @ ( forDeclaration | [ expression ] ) ';' [ forExpression ] ';' [ forExpression ]

** State #113: functionDefinition => [ declarationSpecifiers @ ] declarator [ declarationList ] compoundStatement
    --> __________________
    --> #8: declarator => [ @ pointer ] directDeclarator
    -->     Type: shift
    -->     LA: '(' '*' #identifier# '^' const
    -->     LA: volatile

** State #114: parameterDeclaration => ( declarationSpecifiers @ declarator | declarationSpecifiers2 [ abstractDeclarato
r ] )
    --> __________________
    --> #8: declarator => [ @ pointer ] directDeclarator
    -->     Type: shift
    -->     LA: '(' '*' #identifier# '^' const
    -->     LA: volatile

** [FINAL] State #115: parameterDeclaration => ( declarationSpecifiers declarator | declarationSpecifiers2 @ [ abstractD
eclarator ] )
    --> __________________
    --> #118: abstractDeclarator => @ ( pointer | [ pointer ] directAbstractDeclarator )
    -->     Type: shift
    -->     LA: '[' '(' '*' '^' const
    -->     LA: volatile
    --> __________________
    --> #90: parameterList => [ parameterList ',' ] parameterDeclaration @
    -->     Type: reduce
    -->     Reduce: parameterList => [ @ parameterList ',' ] parameterDeclaration
    --> __________________
    --> #90: parameterList => [ parameterList ',' ] parameterDeclaration @
    -->     Type: reduce
    -->     Reduce: parameterList => [ parameterList ',' @ ] parameterDeclaration

** [FINAL] State #116: structDeclaration => specifierQualifierList [ structDeclaratorList ] ';' @
    --> __________________
    --> #148: structDeclarationList => [ structDeclarationList ] structDeclaration @
    -->     Type: reduce
    -->     Reduce: structDeclarationList => [ @ structDeclarationList ] structDeclaration
    --> __________________
    --> #148: structDeclarationList => [ structDeclarationList ] structDeclaration @
    -->     Type: reduce
    -->     Reduce: structDeclarationList => [ structDeclarationList @ ] structDeclaration

** State #117: structDeclaratorList => [ @ structDeclaratorList ',' ] structDeclarator
    --> __________________
    --> #149: structDeclarator => @ ( declarator | [ declarator ] '=' constantExpression )
    -->     Type: shift
    -->     LA: '=' '(' '*' #identifier# '^'
    -->     LA: const volatile

** State #118: abstractDeclarator => @ ( pointer | [ pointer ] directAbstractDeclarator )
    --> __________________
    --> #64: directAbstractDeclarator => @ ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQua
lifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: shift
    -->     LA: '(' '['
    --> __________________
    --> #12: pointer => [ @ typeQualifierList ] [ pointer ] ( '*' | '^' )
    -->     Type: shift
    -->     LA: volatile const '^' '*'
    --> __________________
    --> #12: pointer => [ @ typeQualifierList ] [ pointer ] ( '*' | '^' )
    -->     Type: shift
    -->     LA: volatile const '^' '*'

** [FINAL] State #119: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [
 typeQualifierList ] [ assignmentExpression ] | '*' ) ']' @ | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #123: abstractDeclarator => ( pointer | [ pointer ] directAbstractDeclarator @ )
    -->     Type: reduce
    -->     Reduce: abstractDeclarator => @ ( pointer | [ pointer ] directAbstractDeclarator )
    --> __________________
    --> #123: abstractDeclarator => ( pointer | [ pointer ] directAbstractDeclarator @ )
    -->     Type: reduce
    -->     Reduce: abstractDeclarator => ( pointer | [ pointer @ ] directAbstractDeclarator )
    --> __________________
    --> #124: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator @ ] ( '[' ( [ typeQu
alifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: recursion
    -->     LA: '[' '('

** State #120: structOrUnionSpecifier => structOrUnion @ ( #identifier# | [ #identifier# ] '{' structDeclarationList '}'
 )
    --> __________________
    --> #150: structOrUnionSpecifier => structOrUnion ( #identifier# | [ #identifier# ] '{' @ structDeclarationList '}'
)
    -->     Type: move
    -->     LA: '{'
    --> __________________
    --> #151: structOrUnionSpecifier => structOrUnion ( #identifier# @ | [ #identifier# ] '{' structDeclarationList '}'
)
    -->     Type: move
    -->     LA: #identifier#
    --> __________________
    --> #152: structOrUnionSpecifier => structOrUnion ( #identifier# | [ #identifier# @ ] '{' structDeclarationList '}'
)
    -->     Type: move
    -->     LA: #identifier#

** State #121: enumeratorList => [ @ enumeratorList ',' ] enumerator
    --> __________________
    --> #153: enumerator => @ enumerationConstant [ '=' constantExpression ]
    -->     Type: shift
    -->     LA: #identifier#

** [FINAL] State #122: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool |
 structOrUnionSpecifier | enumSpecifier @ | typedefName | typeSpecifier pointer )
    --> __________________
    --> #55: declarationSpecifier => ( storageClassSpecifier | typeSpecifier @ | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #56: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #57: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrU
nionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )
    -->     Type: recursion
    -->     LA: volatile const '^' '*'

** [FINAL] State #123: abstractDeclarator => ( pointer | [ pointer ] directAbstractDeclarator @ )
    --> __________________
    --> #61: directAbstractDeclarator => ( '(' abstractDeclarator @ ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQua
lifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: reduce
    -->     Reduce: directAbstractDeclarator => ( '(' @ abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [
typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #62: parameterDeclaration => ( declarationSpecifiers declarator | declarationSpecifiers2 [ abstractDeclarator @
] )
    -->     Type: reduce
    -->     Reduce: parameterDeclaration => ( declarationSpecifiers declarator | declarationSpecifiers2 @ [ abstractDecl
arator ] )
    --> __________________
    --> #63: typeName => specifierQualifierList [ abstractDeclarator @ ]
    -->     Type: reduce
    -->     Reduce: typeName => specifierQualifierList @ [ abstractDeclarator ]

** State #124: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator @ ] ( '[' ( [ typeQ
ualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #94: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQuali
fierList ] [ assignmentExpression ] | '*' ) ']' | '(' @ [ parameterTypeList ] ')' ) )
    -->     Type: move
    -->     LA: '('
    --> __________________
    --> #96: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' @ ( [ typeQua
lifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: move
    -->     LA: '['

** State #125: parameterList => [ parameterList @ ',' ] parameterDeclaration
    --> __________________
    --> #154: parameterList => [ parameterList ',' @ ] parameterDeclaration
    -->     Type: move
    -->     LA: ','

** [FINAL] State #126: parameterTypeList => parameterList @ [ ',' '...' ]
    --> __________________
    --> #155: parameterTypeList => parameterList [ ',' @ '...' ]
    -->     Type: move
    -->     LA: ','
    --> __________________
    --> #156: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQual
ifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList @ ] ')' ) )
    -->     Type: reduce
    -->     Reduce: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ ty
peQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' @ [ parameterTypeList ] ')' ) )
    --> __________________
    --> #157: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList ] ( a
ssignmentExpression | '*' ) ']' | '(' ( parameterTypeList @ | [ identifierList ] ) ')' ) )
    -->     Type: reduce
    -->     Reduce: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList
 ] ( assignmentExpression | '*' ) ']' | '(' @ ( parameterTypeList | [ identifierList ] ) ')' ) )

** State #127: castExpression => ( '(' typeName ')' @ castExpression | unaryExpression )
    --> __________________
    --> #158: castExpression => @ ( '(' typeName ')' castExpression | unaryExpression )
    -->     Type: shift
    -->     LA: #double# '&' '*' #uint# '+'
    -->     LA: #uchar# #float# '~' #short# '('
    -->     LA: '-' #ushort# '++' '--' '!'
    -->     LA: #int# #char# sizeof #string# #identifier#
    -->     LA: #long# #ulong#

** State #128: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpress
ionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' @ '{' initializerList [ ',' ] '}
' )
    --> __________________
    --> #159: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpressi
onList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' @ initializerList [ ',' ] '}'
 )
    -->     Type: move
    -->     LA: '{'

** [FINAL] State #129: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpr
ession | sizeof ( unaryExpression | '(' typeName ')' @ ) )
    --> __________________
    --> #160: assignmentExpression => ( conditionalExpression | unaryExpression @ assignmentOperator assignmentExpressio
n )
    -->     Type: reduce
    -->     Reduce: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExp
ression )
    --> __________________
    --> #161: castExpression => ( '(' typeName ')' castExpression | unaryExpression @ )
    -->     Type: reduce
    -->     Reduce: castExpression => @ ( '(' typeName ')' castExpression | unaryExpression )
    --> __________________
    --> #162: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression @ | unaryOperator castExpression
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => ( postfixExpression | ( '++' | '--' @ ) unaryExpression | unaryOperator castExpre
ssion | sizeof ( unaryExpression | '(' typeName ')' ) )
    --> __________________
    --> #163: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression |
sizeof ( unaryExpression @ | '(' typeName ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpress
ion | sizeof @ ( unaryExpression | '(' typeName ')' ) )
    --> __________________
    --> #162: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression @ | unaryOperator castExpression
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => ( postfixExpression | ( '++' @ | '--' ) unaryExpression | unaryOperator castExpre
ssion | sizeof ( unaryExpression | '(' typeName ')' ) )

** [FINAL] State #130: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [
 typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' @ ) )
    --> __________________
    --> #123: abstractDeclarator => ( pointer | [ pointer ] directAbstractDeclarator @ )
    -->     Type: reduce
    -->     Reduce: abstractDeclarator => @ ( pointer | [ pointer ] directAbstractDeclarator )
    --> __________________
    --> #123: abstractDeclarator => ( pointer | [ pointer ] directAbstractDeclarator @ )
    -->     Type: reduce
    -->     Reduce: abstractDeclarator => ( pointer | [ pointer @ ] directAbstractDeclarator )
    --> __________________
    --> #124: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator @ ] ( '[' ( [ typeQu
alifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: recursion
    -->     LA: '[' '('

** State #131: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQua
lifierList ] [ assignmentExpression ] | '*' @ ) ']' | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #119: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQual
ifierList ] [ assignmentExpression ] | '*' ) ']' @ | '(' [ parameterTypeList ] ')' ) )
    -->     Type: move
    -->     LA: ']'

** State #132: compoundStatement => '{' @ [ blockItemList ] '}'
    --> __________________
    --> #164: compoundStatement => '{' [ blockItemList ] '}' @
    -->     Type: move
    -->     LA: '}'
    --> __________________
    --> #165: blockItemList => [ @ blockItemList ] blockItem
    -->     Type: shift
    -->     LA: #uint# '+' if '++' #uchar#
    -->     LA: sizeof '&' do '!' '-'
    -->     LA: '~' break for goto '*'
    -->     LA: default case '(' #string# while
    -->     LA: continue return #int# switch #ulong#
    -->     LA: union #ushort# struct ';' enum
    -->     LA: int bool char long '--'
    -->     LA: float #float# unsigned double #double#
    -->     LA: void short '{' const volatile
    -->     LA: #identifier# #char# signed auto #short#
    -->     LA: static extern #long# typedef register

** State #133: initializer => @ ( assignmentExpression | '{' initializerList [ ',' ] '}' )
    --> __________________
    --> #166: initializer => ( assignmentExpression | '{' @ initializerList [ ',' ] '}' )
    -->     Type: move
    -->     LA: '{'
    --> __________________
    --> #108: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExpressio
n )
    -->     Type: shift
    -->     LA: #float# #ulong# #long# #int# #char#
    -->     LA: #identifier# #string# sizeof '!' '--'
    -->     LA: '++' '-' #ushort# '(' #short#
    -->     LA: '~' '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #134: declaration => declarationSpecifiers [ initDeclaratorList @ ] ';'
    --> __________________
    --> #145: declaration => declarationSpecifiers [ initDeclaratorList ] ';' @
    -->     Type: move
    -->     LA: ';'

** [FINAL] State #135: forDeclaration => declarationSpecifiers [ initDeclaratorList @ ]
    --> __________________
    --> #147: forCondition => ( forDeclaration @ | [ expression ] ) ';' [ forExpression ] ';' [ forExpression ]
    -->     Type: reduce
    -->     Reduce: forCondition => @ ( forDeclaration | [ expression ] ) ';' [ forExpression ] ';' [ forExpression ]

** State #136: initDeclaratorList => [ initDeclaratorList @ ',' ] initDeclarator
    --> __________________
    --> #167: initDeclaratorList => [ initDeclaratorList ',' @ ] initDeclarator
    -->     Type: move
    -->     LA: ','

** State #137: structDeclaration => specifierQualifierList [ structDeclaratorList @ ] ';'
    --> __________________
    --> #116: structDeclaration => specifierQualifierList [ structDeclaratorList ] ';' @
    -->     Type: move
    -->     LA: ';'

** State #138: structDeclaratorList => [ structDeclaratorList @ ',' ] structDeclarator
    --> __________________
    --> #168: structDeclaratorList => [ structDeclaratorList ',' @ ] structDeclarator
    -->     Type: move
    -->     LA: ','

** State #139: constantExpression => @ conditionalExpression
    --> __________________
    --> #144: conditionalExpression => @ logicalOrExpression [ '?' expression '=' conditionalExpression ]
    -->     Type: shift
    -->     LA: #double# '&' '*' #uint# '+'
    -->     LA: #uchar# #float# '~' #short# '('
    -->     LA: '-' #ushort# '++' '--' '!'
    -->     LA: #int# #char# sizeof #string# #identifier#
    -->     LA: #long# #ulong#

** State #140: parameterList => [ @ parameterList ',' ] parameterDeclaration
    --> __________________
    --> #169: parameterDeclaration => @ ( declarationSpecifiers declarator | declarationSpecifiers2 [ abstractDeclarator
 ] )
    -->     Type: shift
    -->     LA: register typedef extern static auto
    -->     LA: signed #identifier# volatile const short
    -->     LA: void double unsigned float long
    -->     LA: char bool int enum struct
    -->     LA: union

** [FINAL] State #141: identifierList => [ identifierList ',' ] #identifier# @
    --> __________________
    --> #170: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList ] ( a
ssignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList @ ] ) ')' ) )
    -->     Type: reduce
    -->     Reduce: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList
 ] ( assignmentExpression | '*' ) ']' | '(' @ ( parameterTypeList | [ identifierList ] ) ')' ) )
    --> __________________
    --> #171: identifierList => [ identifierList @ ',' ] #identifier#
    -->     Type: recursion
    -->     LA: ','

** [FINAL] State #142: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierL
ist ] ( assignmentExpression | '*' ) ']' @ | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    --> __________________
    --> #49: declarator => [ pointer ] directDeclarator @
    -->     Type: reduce
    -->     Reduce: declarator => [ @ pointer ] directDeclarator
    --> __________________
    --> #49: declarator => [ pointer ] directDeclarator @
    -->     Type: reduce
    -->     Reduce: declarator => [ pointer @ ] directDeclarator
    --> __________________
    --> #50: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator @ ( '[' [ typeQualifierList ] (
assignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    -->     Type: recursion
    -->     LA: '[' '('

** State #143: unaryExpression => @ ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression
 | sizeof ( unaryExpression | '(' typeName ')' ) )
    --> __________________
    --> #172: unaryExpression => ( postfixExpression | ( '++' | '--' @ ) unaryExpression | unaryOperator castExpression
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: move
    -->     LA: '--'
    --> __________________
    --> #173: postfixExpression => @ ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpres
sionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}'
 )
    -->     Type: shift
    -->     LA: #double# #float# #ulong# #long# #uint#
    -->     LA: #int# #char# #uchar# #short# #ushort#
    -->     LA: #identifier# #string# '('
    --> __________________
    --> #174: unaryOperator => @ ( '&' | '*' | '+' | '-' | '~' | '!' )
    -->     Type: shift
    -->     LA: '-' '~' '+' '*' '&'
    -->     LA: '!'
    --> __________________
    --> #175: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression |
sizeof @ ( unaryExpression | '(' typeName ')' ) )
    -->     Type: move
    -->     LA: sizeof
    --> __________________
    --> #176: unaryExpression => ( postfixExpression | ( '++' @ | '--' ) unaryExpression | unaryOperator castExpression
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: move
    -->     LA: '++'

** State #144: conditionalExpression => @ logicalOrExpression [ '?' expression '=' conditionalExpression ]
    --> __________________
    --> #177: logicalOrExpression => [ @ logicalOrExpression '||' ] logicalAndExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** [FINAL] State #145: declaration => declarationSpecifiers [ initDeclaratorList ] ';' @
    --> __________________
    --> #178: blockItem => ( statement | declaration @ )
    -->     Type: reduce
    -->     Reduce: blockItem => @ ( statement | declaration )
    --> __________________
    --> #179: declarationList => [ declarationList ] declaration @
    -->     Type: reduce
    -->     Reduce: declarationList => [ @ declarationList ] declaration
    --> __________________
    --> #179: declarationList => [ declarationList ] declaration @
    -->     Type: reduce
    -->     Reduce: declarationList => [ declarationList @ ] declaration
    --> __________________
    --> #180: externalDeclaration => ( functionDefinition | declaration @ | ';' )
    -->     Type: reduce
    -->     Reduce: externalDeclaration => @ ( functionDefinition | declaration | ';' )

** State #146: initDeclaratorList => [ @ initDeclaratorList ',' ] initDeclarator
    --> __________________
    --> #181: initDeclarator => @ declarator [ '=' initializer ]
    -->     Type: shift
    -->     LA: '(' '*' #identifier# '^' const
    -->     LA: volatile

** State #147: forCondition => ( forDeclaration @ | [ expression ] ) ';' [ forExpression ] ';' [ forExpression ]
    --> __________________
    --> #182: forCondition => ( forDeclaration | [ expression ] ) ';' @ [ forExpression ] ';' [ forExpression ]
    -->     Type: move
    -->     LA: ';'

** [FINAL] State #148: structDeclarationList => [ structDeclarationList ] structDeclaration @
    --> __________________
    --> #183: structDeclarationList => [ structDeclarationList @ ] structDeclaration
    -->     Type: recursion
    -->     LA: volatile const short signed #identifier#
    -->     LA: void unsigned float long char
    -->     LA: bool int enum double struct
    -->     LA: union
    --> __________________
    --> #184: structOrUnionSpecifier => structOrUnion ( #identifier# | [ #identifier# ] '{' structDeclarationList @ '}'
)
    -->     Type: reduce
    -->     Reduce: structOrUnionSpecifier => structOrUnion ( #identifier# | [ #identifier# ] '{' @ structDeclarationLis
t '}' )

** State #149: structDeclarator => @ ( declarator | [ declarator ] '=' constantExpression )
    --> __________________
    --> #103: structDeclarator => ( declarator | [ declarator ] '=' @ constantExpression )
    -->     Type: move
    -->     LA: '='
    --> __________________
    --> #8: declarator => [ @ pointer ] directDeclarator
    -->     Type: shift
    -->     LA: '(' '*' #identifier# '^' const
    -->     LA: volatile
    --> __________________
    --> #8: declarator => [ @ pointer ] directDeclarator
    -->     Type: shift
    -->     LA: '(' '*' #identifier# '^' const
    -->     LA: volatile

** State #150: structOrUnionSpecifier => structOrUnion ( #identifier# | [ #identifier# ] '{' @ structDeclarationList '}'
 )
    --> __________________
    --> #185: structDeclarationList => [ @ structDeclarationList ] structDeclaration
    -->     Type: shift
    -->     LA: union struct double enum #identifier#
    -->     LA: int bool char long float
    -->     LA: unsigned void signed short const
    -->     LA: volatile

** [FINAL] State #151: structOrUnionSpecifier => structOrUnion ( #identifier# @ | [ #identifier# ] '{' structDeclaration
List '}' )
    --> __________________
    --> #186: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOr
UnionSpecifier @ | enumSpecifier | typedefName | typeSpecifier pointer )
    -->     Type: reduce
    -->     Reduce: typeSpecifier => @ ( void | char | short | int | long | float | double | signed | unsigned | bool |
structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )

** State #152: structOrUnionSpecifier => structOrUnion ( #identifier# | [ #identifier# @ ] '{' structDeclarationList '}'
 )
    --> __________________
    --> #150: structOrUnionSpecifier => structOrUnion ( #identifier# | [ #identifier# ] '{' @ structDeclarationList '}'
)
    -->     Type: move
    -->     LA: '{'

** State #153: enumerator => @ enumerationConstant [ '=' constantExpression ]
    --> __________________
    --> #187: enumerationConstant => @ #identifier#
    -->     Type: shift
    -->     LA: #identifier#

** State #154: parameterList => [ parameterList ',' @ ] parameterDeclaration
    --> __________________
    --> #169: parameterDeclaration => @ ( declarationSpecifiers declarator | declarationSpecifiers2 [ abstractDeclarator
 ] )
    -->     Type: shift
    -->     LA: register typedef extern static auto
    -->     LA: signed #identifier# volatile const short
    -->     LA: void double unsigned float long
    -->     LA: char bool int enum struct
    -->     LA: union

** State #155: parameterTypeList => parameterList [ ',' @ '...' ]
    --> __________________
    --> #188: parameterTypeList => parameterList [ ',' '...' @ ]
    -->     Type: move
    -->     LA: '...'

** State #156: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQua
lifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList @ ] ')' ) )
    --> __________________
    --> #130: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQual
ifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' @ ) )
    -->     Type: move
    -->     LA: ')'

** State #157: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList ] (
assignmentExpression | '*' ) ']' | '(' ( parameterTypeList @ | [ identifierList ] ) ')' ) )
    --> __________________
    --> #104: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList ] ( a
ssignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' @ ) )
    -->     Type: move
    -->     LA: ')'

** State #158: castExpression => @ ( '(' typeName ')' castExpression | unaryExpression )
    --> __________________
    --> #143: unaryExpression => @ ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: shift
    -->     LA: '&' #double# '*' #uint# '+'
    -->     LA: #uchar# '~' #short# '-' '('
    -->     LA: #ushort# '++' '--' '!' sizeof
    -->     LA: #string# #identifier# #char# #int# #long#
    -->     LA: #ulong# #float#
    --> __________________
    --> #189: castExpression => ( '(' @ typeName ')' castExpression | unaryExpression )
    -->     Type: move
    -->     LA: '('

** State #159: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpress
ionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' @ initializerList [ ',' ] '}
' )
    --> __________________
    --> #190: initializerList => [ @ initializerList ',' ] [ designation ] initializer
    -->     Type: shift
    -->     LA: '.' '&' #uint# '*' #uchar#
    -->     LA: '[' '+' #short# #double# '('
    -->     LA: #ushort# '-' '++' '--' #identifier#
    -->     LA: sizeof #char# '!' #int# #long#
    -->     LA: #ulong# '~' #float# #string# '{'

** State #160: assignmentExpression => ( conditionalExpression | unaryExpression @ assignmentOperator assignmentExpressi
on )
    --> __________________
    --> #191: assignmentOperator => @ ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' )
    -->     Type: shift
    -->     LA: '/=' '%=' '*=' '=' '<<='
    -->     LA: '+=' '-=' '>>='

** [FINAL] State #161: castExpression => ( '(' typeName ')' castExpression | unaryExpression @ )
    --> __________________
    --> #192: castExpression => ( '(' typeName ')' castExpression @ | unaryExpression )
    -->     Type: reduce
    -->     Reduce: castExpression => ( '(' typeName ')' @ castExpression | unaryExpression )
    --> __________________
    --> #193: multiplicativeExpression => ( castExpression @ | multiplicativeExpression ( '*' castExpression | '/' castE
xpression | '%' castExpression ) )
    -->     Type: reduce
    -->     Reduce: multiplicativeExpression => @ ( castExpression | multiplicativeExpression ( '*' castExpression | '/'
 castExpression | '%' castExpression ) )
    --> __________________
    --> #194: multiplicativeExpression => ( castExpression | multiplicativeExpression ( '*' castExpression | '/' castExp
ression | '%' castExpression @ ) )
    -->     Type: reduce
    -->     Reduce: multiplicativeExpression => ( castExpression | multiplicativeExpression ( '*' castExpression | '/' c
astExpression | '%' @ castExpression ) )
    --> __________________
    --> #195: multiplicativeExpression => ( castExpression | multiplicativeExpression ( '*' castExpression @ | '/' castE
xpression | '%' castExpression ) )
    -->     Type: reduce
    -->     Reduce: multiplicativeExpression => ( castExpression | multiplicativeExpression ( '*' @ castExpression | '/'
 castExpression | '%' castExpression ) )
    --> __________________
    --> #196: multiplicativeExpression => ( castExpression | multiplicativeExpression ( '*' castExpression | '/' castExp
ression @ | '%' castExpression ) )
    -->     Type: reduce
    -->     Reduce: multiplicativeExpression => ( castExpression | multiplicativeExpression ( '*' castExpression | '/' @
 castExpression | '%' castExpression ) )
    --> __________________
    --> #197: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression @
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator @ castExpre
ssion | sizeof ( unaryExpression | '(' typeName ')' ) )

** [FINAL] State #162: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression @ | unaryOperator castEx
pression | sizeof ( unaryExpression | '(' typeName ')' ) )
    --> __________________
    --> #160: assignmentExpression => ( conditionalExpression | unaryExpression @ assignmentOperator assignmentExpressio
n )
    -->     Type: reduce
    -->     Reduce: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExp
ression )
    --> __________________
    --> #161: castExpression => ( '(' typeName ')' castExpression | unaryExpression @ )
    -->     Type: reduce
    -->     Reduce: castExpression => @ ( '(' typeName ')' castExpression | unaryExpression )
    --> __________________
    --> #162: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression @ | unaryOperator castExpression
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => ( postfixExpression | ( '++' | '--' @ ) unaryExpression | unaryOperator castExpre
ssion | sizeof ( unaryExpression | '(' typeName ')' ) )
    --> __________________
    --> #163: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression |
sizeof ( unaryExpression @ | '(' typeName ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpress
ion | sizeof @ ( unaryExpression | '(' typeName ')' ) )
    --> __________________
    --> #162: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression @ | unaryOperator castExpression
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => ( postfixExpression | ( '++' @ | '--' ) unaryExpression | unaryOperator castExpre
ssion | sizeof ( unaryExpression | '(' typeName ')' ) )

** [FINAL] State #163: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpr
ession | sizeof ( unaryExpression @ | '(' typeName ')' ) )
    --> __________________
    --> #160: assignmentExpression => ( conditionalExpression | unaryExpression @ assignmentOperator assignmentExpressio
n )
    -->     Type: reduce
    -->     Reduce: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExp
ression )
    --> __________________
    --> #161: castExpression => ( '(' typeName ')' castExpression | unaryExpression @ )
    -->     Type: reduce
    -->     Reduce: castExpression => @ ( '(' typeName ')' castExpression | unaryExpression )
    --> __________________
    --> #162: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression @ | unaryOperator castExpression
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => ( postfixExpression | ( '++' | '--' @ ) unaryExpression | unaryOperator castExpre
ssion | sizeof ( unaryExpression | '(' typeName ')' ) )
    --> __________________
    --> #163: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression |
sizeof ( unaryExpression @ | '(' typeName ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpress
ion | sizeof @ ( unaryExpression | '(' typeName ')' ) )
    --> __________________
    --> #162: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression @ | unaryOperator castExpression
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => ( postfixExpression | ( '++' @ | '--' ) unaryExpression | unaryOperator castExpre
ssion | sizeof ( unaryExpression | '(' typeName ')' ) )

** [FINAL] State #164: compoundStatement => '{' [ blockItemList ] '}' @
    --> __________________
    --> #198: functionDefinition => [ declarationSpecifiers ] declarator [ declarationList ] compoundStatement @
    -->     Type: reduce
    -->     Reduce: functionDefinition => [ declarationSpecifiers ] declarator @ [ declarationList ] compoundStatement
    --> __________________
    --> #198: functionDefinition => [ declarationSpecifiers ] declarator [ declarationList ] compoundStatement @
    -->     Type: reduce
    -->     Reduce: functionDefinition => [ declarationSpecifiers ] declarator [ declarationList @ ] compoundStatement
    --> __________________
    --> #199: statement => ( labeledStatement | compoundStatement @ | expressionStatement | selectionStatement | iterati
onStatement | jumpStatement )
    -->     Type: reduce
    -->     Reduce: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | i
terationStatement | jumpStatement )

** State #165: blockItemList => [ @ blockItemList ] blockItem
    --> __________________
    --> #200: blockItem => @ ( statement | declaration )
    -->     Type: shift
    -->     LA: register typedef #long# extern static
    -->     LA: #short# auto signed #char# #identifier#
    -->     LA: volatile const '{' short void
    -->     LA: #double# double unsigned #float# float
    -->     LA: '--' long char bool int
    -->     LA: enum ';' struct #ushort# union
    -->     LA: #ulong# switch #int# return continue
    -->     LA: while #string# '(' case default
    -->     LA: '*' goto for break '~'
    -->     LA: '-' '!' do '&' sizeof
    -->     LA: #uchar# '++' if '+' #uint#

** State #166: initializer => ( assignmentExpression | '{' @ initializerList [ ',' ] '}' )
    --> __________________
    --> #190: initializerList => [ @ initializerList ',' ] [ designation ] initializer
    -->     Type: shift
    -->     LA: '.' '&' #uint# '*' #uchar#
    -->     LA: '[' '+' #short# #double# '('
    -->     LA: #ushort# '-' '++' '--' #identifier#
    -->     LA: sizeof #char# '!' #int# #long#
    -->     LA: #ulong# '~' #float# #string# '{'

** State #167: initDeclaratorList => [ initDeclaratorList ',' @ ] initDeclarator
    --> __________________
    --> #181: initDeclarator => @ declarator [ '=' initializer ]
    -->     Type: shift
    -->     LA: '(' '*' #identifier# '^' const
    -->     LA: volatile

** State #168: structDeclaratorList => [ structDeclaratorList ',' @ ] structDeclarator
    --> __________________
    --> #149: structDeclarator => @ ( declarator | [ declarator ] '=' constantExpression )
    -->     Type: shift
    -->     LA: '=' '(' '*' #identifier# '^'
    -->     LA: const volatile

** State #169: parameterDeclaration => @ ( declarationSpecifiers declarator | declarationSpecifiers2 [ abstractDeclarato
r ] )
    --> __________________
    --> #201: declarationSpecifiers2 => @ declarationSpecifier [ declarationSpecifiers ]
    -->     Type: shift
    -->     LA: union struct enum int bool
    -->     LA: char long float unsigned double
    -->     LA: void short const volatile #identifier#
    -->     LA: signed auto static extern typedef
    -->     LA: register
    --> __________________
    --> #7: declarationSpecifiers => @ declarationSpecifier [ declarationSpecifiers ]
    -->     Type: shift
    -->     LA: union struct enum int bool
    -->     LA: char long float unsigned double
    -->     LA: void short const volatile #identifier#
    -->     LA: signed auto static extern typedef
    -->     LA: register

** State #170: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList ] (
assignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList @ ] ) ')' ) )
    --> __________________
    --> #104: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList ] ( a
ssignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' @ ) )
    -->     Type: move
    -->     LA: ')'

** State #171: identifierList => [ identifierList @ ',' ] #identifier#
    --> __________________
    --> #202: identifierList => [ identifierList ',' @ ] #identifier#
    -->     Type: move
    -->     LA: ','

** State #172: unaryExpression => ( postfixExpression | ( '++' | '--' @ ) unaryExpression | unaryOperator castExpression
 | sizeof ( unaryExpression | '(' typeName ')' ) )
    --> __________________
    --> #143: unaryExpression => @ ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: shift
    -->     LA: '&' #double# '*' #uint# '+'
    -->     LA: #uchar# '~' #short# '-' '('
    -->     LA: #ushort# '++' '--' '!' sizeof
    -->     LA: #string# #identifier# #char# #int# #long#
    -->     LA: #ulong# #float#

** State #173: postfixExpression => @ ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpre
ssionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}
' )
    --> __________________
    --> #203: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpressi
onList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' @ typeName ')' '{' initializerList [ ',' ] '}'
 )
    -->     Type: move
    -->     LA: '('
    --> __________________
    --> #204: primaryExpression => @ ( #identifier# | constant | #string# | '(' expression ')' )
    -->     Type: shift
    -->     LA: #string# '(' #identifier# #ushort# #short#
    -->     LA: #uchar# #char# #int# #uint# #long#
    -->     LA: #ulong# #float# #double#

** State #174: unaryOperator => @ ( '&' | '*' | '+' | '-' | '~' | '!' )
    --> __________________
    --> #205: unaryOperator => ( '&' | '*' | '+' | '-' | '~' | '!' @ )
    -->     Type: move
    -->     LA: '!'
    --> __________________
    --> #206: unaryOperator => ( '&' @ | '*' | '+' | '-' | '~' | '!' )
    -->     Type: move
    -->     LA: '&'
    --> __________________
    --> #207: unaryOperator => ( '&' | '*' @ | '+' | '-' | '~' | '!' )
    -->     Type: move
    -->     LA: '*'
    --> __________________
    --> #208: unaryOperator => ( '&' | '*' | '+' @ | '-' | '~' | '!' )
    -->     Type: move
    -->     LA: '+'
    --> __________________
    --> #209: unaryOperator => ( '&' | '*' | '+' | '-' @ | '~' | '!' )
    -->     Type: move
    -->     LA: '-'
    --> __________________
    --> #210: unaryOperator => ( '&' | '*' | '+' | '-' | '~' @ | '!' )
    -->     Type: move
    -->     LA: '~'

** State #175: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression |
 sizeof @ ( unaryExpression | '(' typeName ')' ) )
    --> __________________
    --> #211: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression |
sizeof ( unaryExpression | '(' @ typeName ')' ) )
    -->     Type: move
    -->     LA: '('
    --> __________________
    --> #143: unaryExpression => @ ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: shift
    -->     LA: '&' #double# '*' #uint# '+'
    -->     LA: #uchar# '~' #short# '-' '('
    -->     LA: #ushort# '++' '--' '!' sizeof
    -->     LA: #string# #identifier# #char# #int# #long#
    -->     LA: #ulong# #float#

** State #176: unaryExpression => ( postfixExpression | ( '++' @ | '--' ) unaryExpression | unaryOperator castExpression
 | sizeof ( unaryExpression | '(' typeName ')' ) )
    --> __________________
    --> #143: unaryExpression => @ ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: shift
    -->     LA: '&' #double# '*' #uint# '+'
    -->     LA: #uchar# '~' #short# '-' '('
    -->     LA: #ushort# '++' '--' '!' sizeof
    -->     LA: #string# #identifier# #char# #int# #long#
    -->     LA: #ulong# #float#

** State #177: logicalOrExpression => [ @ logicalOrExpression '||' ] logicalAndExpression
    --> __________________
    --> #212: logicalAndExpression => [ @ logicalAndExpression '&&' ] inclusiveOrExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** [FINAL] State #178: blockItem => ( statement | declaration @ )
    --> __________________
    --> #213: blockItemList => [ blockItemList ] blockItem @
    -->     Type: reduce
    -->     Reduce: blockItemList => [ @ blockItemList ] blockItem
    --> __________________
    --> #213: blockItemList => [ blockItemList ] blockItem @
    -->     Type: reduce
    -->     Reduce: blockItemList => [ blockItemList @ ] blockItem

** [FINAL] State #179: declarationList => [ declarationList ] declaration @
    --> __________________
    --> #214: declarationList => [ declarationList @ ] declaration
    -->     Type: recursion
    -->     LA: union struct enum int bool
    -->     LA: char long float unsigned double
    -->     LA: void short const volatile #identifier#
    -->     LA: signed auto static extern typedef
    -->     LA: register
    --> __________________
    --> #215: functionDefinition => [ declarationSpecifiers ] declarator [ declarationList @ ] compoundStatement
    -->     Type: reduce
    -->     Reduce: functionDefinition => [ declarationSpecifiers ] declarator @ [ declarationList ] compoundStatement

** [FINAL] State #180: externalDeclaration => ( functionDefinition | declaration @ | ';' )
    --> __________________
    --> #6: translationUnit => [ translationUnit ] externalDeclaration @
    -->     Type: reduce
    -->     Reduce: translationUnit => [ @ translationUnit ] externalDeclaration
    --> __________________
    --> #6: translationUnit => [ translationUnit ] externalDeclaration @
    -->     Type: reduce
    -->     Reduce: translationUnit => [ translationUnit @ ] externalDeclaration

** State #181: initDeclarator => @ declarator [ '=' initializer ]
    --> __________________
    --> #8: declarator => [ @ pointer ] directDeclarator
    -->     Type: shift
    -->     LA: '(' '*' #identifier# '^' const
    -->     LA: volatile

** State #182: forCondition => ( forDeclaration | [ expression ] ) ';' @ [ forExpression ] ';' [ forExpression ]
    --> __________________
    --> #216: forCondition => ( forDeclaration | [ expression ] ) ';' [ forExpression ] ';' @ [ forExpression ]
    -->     Type: move
    -->     LA: ';'
    --> __________________
    --> #217: forExpression => [ @ forExpression ',' ] assignmentExpression
    -->     Type: shift
    -->     LA: #double# '&' #identifier# #uint# '*'
    -->     LA: #long# #uchar# '+' #short# '~'
    -->     LA: '(' #ushort# '-' #int# '++'
    -->     LA: '--' '!' sizeof #string# #char#
    -->     LA: #ulong# #float#

** State #183: structDeclarationList => [ structDeclarationList @ ] structDeclaration
    --> __________________
    --> #218: structDeclaration => @ specifierQualifierList [ structDeclaratorList ] ';'
    -->     Type: shift
    -->     LA: volatile const short signed #identifier#
    -->     LA: void unsigned float long char
    -->     LA: bool int enum double struct
    -->     LA: union

** State #184: structOrUnionSpecifier => structOrUnion ( #identifier# | [ #identifier# ] '{' structDeclarationList @ '}'
 )
    --> __________________
    --> #219: structOrUnionSpecifier => structOrUnion ( #identifier# | [ #identifier# ] '{' structDeclarationList '}' @
)
    -->     Type: move
    -->     LA: '}'

** State #185: structDeclarationList => [ @ structDeclarationList ] structDeclaration
    --> __________________
    --> #218: structDeclaration => @ specifierQualifierList [ structDeclaratorList ] ';'
    -->     Type: shift
    -->     LA: volatile const short signed #identifier#
    -->     LA: void unsigned float long char
    -->     LA: bool int enum double struct
    -->     LA: union

** [FINAL] State #186: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool |
 structOrUnionSpecifier @ | enumSpecifier | typedefName | typeSpecifier pointer )
    --> __________________
    --> #55: declarationSpecifier => ( storageClassSpecifier | typeSpecifier @ | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #56: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #57: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrU
nionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )
    -->     Type: recursion
    -->     LA: volatile const '^' '*'

** State #187: enumerationConstant => @ #identifier#
    --> __________________
    --> #220: enumerationConstant => #identifier# @
    -->     Type: move
    -->     LA: #identifier#

** [FINAL] State #188: parameterTypeList => parameterList [ ',' '...' @ ]
    --> __________________
    --> #156: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQual
ifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList @ ] ')' ) )
    -->     Type: reduce
    -->     Reduce: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ ty
peQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' @ [ parameterTypeList ] ')' ) )
    --> __________________
    --> #157: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList ] ( a
ssignmentExpression | '*' ) ']' | '(' ( parameterTypeList @ | [ identifierList ] ) ')' ) )
    -->     Type: reduce
    -->     Reduce: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList
 ] ( assignmentExpression | '*' ) ']' | '(' @ ( parameterTypeList | [ identifierList ] ) ')' ) )

** State #189: castExpression => ( '(' @ typeName ')' castExpression | unaryExpression )
    --> __________________
    --> #221: typeName => @ specifierQualifierList [ abstractDeclarator ]
    -->     Type: shift
    -->     LA: volatile const short signed #identifier#
    -->     LA: void unsigned float long char
    -->     LA: bool int enum double struct
    -->     LA: union

** State #190: initializerList => [ @ initializerList ',' ] [ designation ] initializer
    --> __________________
    --> #222: designation => @ designatorList '='
    -->     Type: shift
    -->     LA: '[' '.'
    --> __________________
    --> #133: initializer => @ ( assignmentExpression | '{' initializerList [ ',' ] '}' )
    -->     Type: shift
    -->     LA: '{' #string# #float# '~' #ulong#
    -->     LA: #long# #int# '!' #char# sizeof
    -->     LA: #identifier# '--' '++' '-' #ushort#
    -->     LA: '(' #double# #short# '+' #uchar#
    -->     LA: '*' #uint# '&'

** State #191: assignmentOperator => @ ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' )
    --> __________________
    --> #223: assignmentOperator => ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' @ )
    -->     Type: move
    -->     LA: '>>='
    --> __________________
    --> #224: assignmentOperator => ( '=' @ | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' )
    -->     Type: move
    -->     LA: '='
    --> __________________
    --> #225: assignmentOperator => ( '=' | '*=' @ | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' )
    -->     Type: move
    -->     LA: '*='
    --> __________________
    --> #226: assignmentOperator => ( '=' | '*=' | '/=' @ | '%=' | '+=' | '-=' | '<<=' | '>>=' )
    -->     Type: move
    -->     LA: '/='
    --> __________________
    --> #227: assignmentOperator => ( '=' | '*=' | '/=' | '%=' @ | '+=' | '-=' | '<<=' | '>>=' )
    -->     Type: move
    -->     LA: '%='
    --> __________________
    --> #228: assignmentOperator => ( '=' | '*=' | '/=' | '%=' | '+=' @ | '-=' | '<<=' | '>>=' )
    -->     Type: move
    -->     LA: '+='
    --> __________________
    --> #229: assignmentOperator => ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' @ | '<<=' | '>>=' )
    -->     Type: move
    -->     LA: '-='
    --> __________________
    --> #230: assignmentOperator => ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' @ | '>>=' )
    -->     Type: move
    -->     LA: '<<='

** [FINAL] State #192: castExpression => ( '(' typeName ')' castExpression @ | unaryExpression )
    --> __________________
    --> #192: castExpression => ( '(' typeName ')' castExpression @ | unaryExpression )
    -->     Type: reduce
    -->     Reduce: castExpression => ( '(' typeName ')' @ castExpression | unaryExpression )
    --> __________________
    --> #193: multiplicativeExpression => ( castExpression @ | multiplicativeExpression ( '*' castExpression | '/' castE
xpression | '%' castExpression ) )
    -->     Type: reduce
    -->     Reduce: multiplicativeExpression => @ ( castExpression | multiplicativeExpression ( '*' castExpression | '/'
 castExpression | '%' castExpression ) )
    --> __________________
    --> #194: multiplicativeExpression => ( castExpression | multiplicativeExpression ( '*' castExpression | '/' castExp
ression | '%' castExpression @ ) )
    -->     Type: reduce
    -->     Reduce: multiplicativeExpression => ( castExpression | multiplicativeExpression ( '*' castExpression | '/' c
astExpression | '%' @ castExpression ) )
    --> __________________
    --> #195: multiplicativeExpression => ( castExpression | multiplicativeExpression ( '*' castExpression @ | '/' castE
xpression | '%' castExpression ) )
    -->     Type: reduce
    -->     Reduce: multiplicativeExpression => ( castExpression | multiplicativeExpression ( '*' @ castExpression | '/'
 castExpression | '%' castExpression ) )
    --> __________________
    --> #196: multiplicativeExpression => ( castExpression | multiplicativeExpression ( '*' castExpression | '/' castExp
ression @ | '%' castExpression ) )
    -->     Type: reduce
    -->     Reduce: multiplicativeExpression => ( castExpression | multiplicativeExpression ( '*' castExpression | '/' @
 castExpression | '%' castExpression ) )
    --> __________________
    --> #197: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression @
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator @ castExpre
ssion | sizeof ( unaryExpression | '(' typeName ')' ) )

** [FINAL] State #193: multiplicativeExpression => ( castExpression @ | multiplicativeExpression ( '*' castExpression |
'/' castExpression | '%' castExpression ) )
    --> __________________
    --> #231: additiveExpression => [ additiveExpression ( '+' | '-' ) ] multiplicativeExpression @
    -->     Type: reduce
    -->     Reduce: additiveExpression => [ @ additiveExpression ( '+' | '-' ) ] multiplicativeExpression
    --> __________________
    --> #231: additiveExpression => [ additiveExpression ( '+' | '-' ) ] multiplicativeExpression @
    -->     Type: reduce
    -->     Reduce: additiveExpression => [ additiveExpression ( '+' | '-' @ ) ] multiplicativeExpression
    --> __________________
    --> #231: additiveExpression => [ additiveExpression ( '+' | '-' ) ] multiplicativeExpression @
    -->     Type: reduce
    -->     Reduce: additiveExpression => [ additiveExpression ( '+' @ | '-' ) ] multiplicativeExpression
    --> __________________
    --> #232: multiplicativeExpression => ( castExpression | multiplicativeExpression @ ( '*' castExpression | '/' castE
xpression | '%' castExpression ) )
    -->     Type: recursion
    -->     LA: '/' '*' '%'

** [FINAL] State #194: multiplicativeExpression => ( castExpression | multiplicativeExpression ( '*' castExpression | '/
' castExpression | '%' castExpression @ ) )
    --> __________________
    --> #231: additiveExpression => [ additiveExpression ( '+' | '-' ) ] multiplicativeExpression @
    -->     Type: reduce
    -->     Reduce: additiveExpression => [ @ additiveExpression ( '+' | '-' ) ] multiplicativeExpression
    --> __________________
    --> #231: additiveExpression => [ additiveExpression ( '+' | '-' ) ] multiplicativeExpression @
    -->     Type: reduce
    -->     Reduce: additiveExpression => [ additiveExpression ( '+' | '-' @ ) ] multiplicativeExpression
    --> __________________
    --> #231: additiveExpression => [ additiveExpression ( '+' | '-' ) ] multiplicativeExpression @
    -->     Type: reduce
    -->     Reduce: additiveExpression => [ additiveExpression ( '+' @ | '-' ) ] multiplicativeExpression
    --> __________________
    --> #232: multiplicativeExpression => ( castExpression | multiplicativeExpression @ ( '*' castExpression | '/' castE
xpression | '%' castExpression ) )
    -->     Type: recursion
    -->     LA: '/' '*' '%'

** [FINAL] State #195: multiplicativeExpression => ( castExpression | multiplicativeExpression ( '*' castExpression @ |
'/' castExpression | '%' castExpression ) )
    --> __________________
    --> #231: additiveExpression => [ additiveExpression ( '+' | '-' ) ] multiplicativeExpression @
    -->     Type: reduce
    -->     Reduce: additiveExpression => [ @ additiveExpression ( '+' | '-' ) ] multiplicativeExpression
    --> __________________
    --> #231: additiveExpression => [ additiveExpression ( '+' | '-' ) ] multiplicativeExpression @
    -->     Type: reduce
    -->     Reduce: additiveExpression => [ additiveExpression ( '+' | '-' @ ) ] multiplicativeExpression
    --> __________________
    --> #231: additiveExpression => [ additiveExpression ( '+' | '-' ) ] multiplicativeExpression @
    -->     Type: reduce
    -->     Reduce: additiveExpression => [ additiveExpression ( '+' @ | '-' ) ] multiplicativeExpression
    --> __________________
    --> #232: multiplicativeExpression => ( castExpression | multiplicativeExpression @ ( '*' castExpression | '/' castE
xpression | '%' castExpression ) )
    -->     Type: recursion
    -->     LA: '/' '*' '%'

** [FINAL] State #196: multiplicativeExpression => ( castExpression | multiplicativeExpression ( '*' castExpression | '/
' castExpression @ | '%' castExpression ) )
    --> __________________
    --> #231: additiveExpression => [ additiveExpression ( '+' | '-' ) ] multiplicativeExpression @
    -->     Type: reduce
    -->     Reduce: additiveExpression => [ @ additiveExpression ( '+' | '-' ) ] multiplicativeExpression
    --> __________________
    --> #231: additiveExpression => [ additiveExpression ( '+' | '-' ) ] multiplicativeExpression @
    -->     Type: reduce
    -->     Reduce: additiveExpression => [ additiveExpression ( '+' | '-' @ ) ] multiplicativeExpression
    --> __________________
    --> #231: additiveExpression => [ additiveExpression ( '+' | '-' ) ] multiplicativeExpression @
    -->     Type: reduce
    -->     Reduce: additiveExpression => [ additiveExpression ( '+' @ | '-' ) ] multiplicativeExpression
    --> __________________
    --> #232: multiplicativeExpression => ( castExpression | multiplicativeExpression @ ( '*' castExpression | '/' castE
xpression | '%' castExpression ) )
    -->     Type: recursion
    -->     LA: '/' '*' '%'

** [FINAL] State #197: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpr
ession @ | sizeof ( unaryExpression | '(' typeName ')' ) )
    --> __________________
    --> #160: assignmentExpression => ( conditionalExpression | unaryExpression @ assignmentOperator assignmentExpressio
n )
    -->     Type: reduce
    -->     Reduce: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExp
ression )
    --> __________________
    --> #161: castExpression => ( '(' typeName ')' castExpression | unaryExpression @ )
    -->     Type: reduce
    -->     Reduce: castExpression => @ ( '(' typeName ')' castExpression | unaryExpression )
    --> __________________
    --> #162: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression @ | unaryOperator castExpression
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => ( postfixExpression | ( '++' | '--' @ ) unaryExpression | unaryOperator castExpre
ssion | sizeof ( unaryExpression | '(' typeName ')' ) )
    --> __________________
    --> #163: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression |
sizeof ( unaryExpression @ | '(' typeName ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpress
ion | sizeof @ ( unaryExpression | '(' typeName ')' ) )
    --> __________________
    --> #162: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression @ | unaryOperator castExpression
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => ( postfixExpression | ( '++' @ | '--' ) unaryExpression | unaryOperator castExpre
ssion | sizeof ( unaryExpression | '(' typeName ')' ) )

** [FINAL] State #198: functionDefinition => [ declarationSpecifiers ] declarator [ declarationList ] compoundStatement
@
    --> __________________
    --> #233: externalDeclaration => ( functionDefinition @ | declaration | ';' )
    -->     Type: reduce
    -->     Reduce: externalDeclaration => @ ( functionDefinition | declaration | ';' )

** [FINAL] State #199: statement => ( labeledStatement | compoundStatement @ | expressionStatement | selectionStatement
| iterationStatement | jumpStatement )
    --> __________________
    --> #234: blockItem => ( statement @ | declaration )
    -->     Type: reduce
    -->     Reduce: blockItem => @ ( statement | declaration )
    --> __________________
    --> #235: iterationStatement => ( while '(' expression ')' statement | do statement @ while '(' expression ')' ';' |
 for '(' forCondition ')' statement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while '(' expression ')' statement | do @ statement while '(' expression ')'
 ';' | for '(' forCondition ')' statement )
    --> __________________
    --> #236: iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' ';' | f
or '(' forCondition ')' statement @ )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' '
;' | for '(' forCondition ')' @ statement )
    --> __________________
    --> #237: iterationStatement => ( while '(' expression ')' statement @ | do statement while '(' expression ')' ';' |
 for '(' forCondition ')' statement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while '(' expression ')' @ statement | do statement while '(' expression ')'
 ';' | for '(' forCondition ')' statement )
    --> __________________
    --> #238: labeledStatement => ( #identifier# | case constantExpression | default ) '=' statement @
    -->     Type: reduce
    -->     Reduce: labeledStatement => ( #identifier# | case constantExpression | default ) '=' @ statement
    --> __________________
    --> #239: selectionStatement => ( if '(' expression ')' statement [ else statement ] | switch '(' expression ')' sta
tement @ )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if '(' expression ')' statement [ else statement ] | switch '(' expression '
)' @ statement )
    --> __________________
    --> #240: selectionStatement => ( if '(' expression ')' statement @ [ else statement ] | switch '(' expression ')' s
tatement )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if '(' expression ')' @ statement [ else statement ] | switch '(' expression
 ')' statement )
    --> __________________
    --> #241: selectionStatement => ( if '(' expression ')' statement [ else statement @ ] | switch '(' expression ')' s
tatement )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if '(' expression ')' statement [ else @ statement ] | switch '(' expression
 ')' statement )

** State #200: blockItem => @ ( statement | declaration )
    --> __________________
    --> #5: declaration => @ declarationSpecifiers [ initDeclaratorList ] ';'
    -->     Type: shift
    -->     LA: union struct enum int bool
    -->     LA: char long float unsigned double
    -->     LA: void short const volatile #identifier#
    -->     LA: signed auto static extern typedef
    -->     LA: register
    --> __________________
    --> #242: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterati
onStatement | jumpStatement )
    -->     Type: shift
    -->     LA: '{' switch return continue while
    -->     LA: '(' #identifier# default case ';'
    -->     LA: '*' #long# goto #float# for
    -->     LA: #ulong# #int# break '-' '!'
    -->     LA: do '&' #char# '~' sizeof
    -->     LA: #string# '--' '++' #ushort# if
    -->     LA: #double# #short# '+' #uchar# #uint#

** State #201: declarationSpecifiers2 => @ declarationSpecifier [ declarationSpecifiers ]
    --> __________________
    --> #11: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    -->     Type: shift
    -->     LA: union struct enum int bool
    -->     LA: char long float unsigned double
    -->     LA: void short const volatile #identifier#
    -->     LA: signed auto static extern typedef
    -->     LA: register

** State #202: identifierList => [ identifierList ',' @ ] #identifier#
    --> __________________
    --> #141: identifierList => [ identifierList ',' ] #identifier# @
    -->     Type: move
    -->     LA: #identifier#

** State #203: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpress
ionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' @ typeName ')' '{' initializerList [ ',' ] '}
' )
    --> __________________
    --> #221: typeName => @ specifierQualifierList [ abstractDeclarator ]
    -->     Type: shift
    -->     LA: volatile const short signed #identifier#
    -->     LA: void unsigned float long char
    -->     LA: bool int enum double struct
    -->     LA: union

** State #204: primaryExpression => @ ( #identifier# | constant | #string# | '(' expression ')' )
    --> __________________
    --> #243: primaryExpression => ( #identifier# | constant | #string# | '(' @ expression ')' )
    -->     Type: move
    -->     LA: '('
    --> __________________
    --> #244: primaryExpression => ( #identifier# @ | constant | #string# | '(' expression ')' )
    -->     Type: move
    -->     LA: #identifier#
    --> __________________
    --> #245: constant => @ ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #float# | #dou
ble# )
    -->     Type: shift
    -->     LA: #ushort# #short# #uchar# #char# #int#
    -->     LA: #uint# #long# #ulong# #float# #double#
    --> __________________
    --> #246: primaryExpression => ( #identifier# | constant | #string# @ | '(' expression ')' )
    -->     Type: move
    -->     LA: #string#

** [FINAL] State #205: unaryOperator => ( '&' | '*' | '+' | '-' | '~' | '!' @ )
    --> __________________
    --> #247: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator @ castExpression
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => @ ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpre
ssion | sizeof ( unaryExpression | '(' typeName ')' ) )

** [FINAL] State #206: unaryOperator => ( '&' @ | '*' | '+' | '-' | '~' | '!' )
    --> __________________
    --> #247: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator @ castExpression
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => @ ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpre
ssion | sizeof ( unaryExpression | '(' typeName ')' ) )

** [FINAL] State #207: unaryOperator => ( '&' | '*' @ | '+' | '-' | '~' | '!' )
    --> __________________
    --> #247: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator @ castExpression
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => @ ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpre
ssion | sizeof ( unaryExpression | '(' typeName ')' ) )

** [FINAL] State #208: unaryOperator => ( '&' | '*' | '+' @ | '-' | '~' | '!' )
    --> __________________
    --> #247: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator @ castExpression
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => @ ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpre
ssion | sizeof ( unaryExpression | '(' typeName ')' ) )

** [FINAL] State #209: unaryOperator => ( '&' | '*' | '+' | '-' @ | '~' | '!' )
    --> __________________
    --> #247: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator @ castExpression
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => @ ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpre
ssion | sizeof ( unaryExpression | '(' typeName ')' ) )

** [FINAL] State #210: unaryOperator => ( '&' | '*' | '+' | '-' | '~' @ | '!' )
    --> __________________
    --> #247: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator @ castExpression
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => @ ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpre
ssion | sizeof ( unaryExpression | '(' typeName ')' ) )

** State #211: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression |
 sizeof ( unaryExpression | '(' @ typeName ')' ) )
    --> __________________
    --> #221: typeName => @ specifierQualifierList [ abstractDeclarator ]
    -->     Type: shift
    -->     LA: volatile const short signed #identifier#
    -->     LA: void unsigned float long char
    -->     LA: bool int enum double struct
    -->     LA: union

** State #212: logicalAndExpression => [ @ logicalAndExpression '&&' ] inclusiveOrExpression
    --> __________________
    --> #248: inclusiveOrExpression => [ @ inclusiveOrExpression '|' ] exclusiveOrExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** [FINAL] State #213: blockItemList => [ blockItemList ] blockItem @
    --> __________________
    --> #249: blockItemList => [ blockItemList @ ] blockItem
    -->     Type: recursion
    -->     LA: register typedef #long# extern static
    -->     LA: #short# auto signed #char# #identifier#
    -->     LA: volatile const '{' short void
    -->     LA: #double# double unsigned #float# float
    -->     LA: '--' long char bool int
    -->     LA: enum ';' struct #ushort# union
    -->     LA: #ulong# switch #int# return continue
    -->     LA: while #string# '(' case default
    -->     LA: '*' goto for break '~'
    -->     LA: '-' '!' do '&' sizeof
    -->     LA: #uchar# '++' if '+' #uint#
    --> __________________
    --> #250: compoundStatement => '{' [ blockItemList @ ] '}'
    -->     Type: reduce
    -->     Reduce: compoundStatement => '{' @ [ blockItemList ] '}'

** State #214: declarationList => [ declarationList @ ] declaration
    --> __________________
    --> #5: declaration => @ declarationSpecifiers [ initDeclaratorList ] ';'
    -->     Type: shift
    -->     LA: union struct enum int bool
    -->     LA: char long float unsigned double
    -->     LA: void short const volatile #identifier#
    -->     LA: signed auto static extern typedef
    -->     LA: register

** State #215: functionDefinition => [ declarationSpecifiers ] declarator [ declarationList @ ] compoundStatement
    --> __________________
    --> #98: compoundStatement => @ '{' [ blockItemList ] '}'
    -->     Type: shift
    -->     LA: '{'

** [FINAL] State #216: forCondition => ( forDeclaration | [ expression ] ) ';' [ forExpression ] ';' @ [ forExpression ]

    --> __________________
    --> #217: forExpression => [ @ forExpression ',' ] assignmentExpression
    -->     Type: shift
    -->     LA: #double# '&' #identifier# #uint# '*'
    -->     LA: #long# #uchar# '+' #short# '~'
    -->     LA: '(' #ushort# '-' #int# '++'
    -->     LA: '--' '!' sizeof #string# #char#
    -->     LA: #ulong# #float#
    --> __________________
    --> #251: iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' ';' | f
or '(' forCondition @ ')' statement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' '
;' | for '(' @ forCondition ')' statement )

** State #217: forExpression => [ @ forExpression ',' ] assignmentExpression
    --> __________________
    --> #108: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExpressio
n )
    -->     Type: shift
    -->     LA: #float# #ulong# #long# #int# #char#
    -->     LA: #identifier# #string# sizeof '!' '--'
    -->     LA: '++' '-' #ushort# '(' #short#
    -->     LA: '~' '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #218: structDeclaration => @ specifierQualifierList [ structDeclaratorList ] ';'
    --> __________________
    --> #75: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    -->     Type: shift
    -->     LA: volatile const short signed #identifier#
    -->     LA: void unsigned float long char
    -->     LA: bool int enum double struct
    -->     LA: union

** [FINAL] State #219: structOrUnionSpecifier => structOrUnion ( #identifier# | [ #identifier# ] '{' structDeclarationLi
st '}' @ )
    --> __________________
    --> #186: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOr
UnionSpecifier @ | enumSpecifier | typedefName | typeSpecifier pointer )
    -->     Type: reduce
    -->     Reduce: typeSpecifier => @ ( void | char | short | int | long | float | double | signed | unsigned | bool |
structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )

** [FINAL] State #220: enumerationConstant => #identifier# @
    --> __________________
    --> #252: enumerator => enumerationConstant @ [ '=' constantExpression ]
    -->     Type: reduce
    -->     Reduce: enumerator => @ enumerationConstant [ '=' constantExpression ]

** State #221: typeName => @ specifierQualifierList [ abstractDeclarator ]
    --> __________________
    --> #75: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    -->     Type: shift
    -->     LA: volatile const short signed #identifier#
    -->     LA: void unsigned float long char
    -->     LA: bool int enum double struct
    -->     LA: union

** State #222: designation => @ designatorList '='
    --> __________________
    --> #253: designatorList => [ @ designatorList ] designator
    -->     Type: shift
    -->     LA: '.' '['

** [FINAL] State #223: assignmentOperator => ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' @ )
    --> __________________
    --> #254: assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator @ assignmentExpressio
n )
    -->     Type: reduce
    -->     Reduce: assignmentExpression => ( conditionalExpression | unaryExpression @ assignmentOperator assignmentExp
ression )

** [FINAL] State #224: assignmentOperator => ( '=' @ | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' )
    --> __________________
    --> #254: assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator @ assignmentExpressio
n )
    -->     Type: reduce
    -->     Reduce: assignmentExpression => ( conditionalExpression | unaryExpression @ assignmentOperator assignmentExp
ression )

** [FINAL] State #225: assignmentOperator => ( '=' | '*=' @ | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' )
    --> __________________
    --> #254: assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator @ assignmentExpressio
n )
    -->     Type: reduce
    -->     Reduce: assignmentExpression => ( conditionalExpression | unaryExpression @ assignmentOperator assignmentExp
ression )

** [FINAL] State #226: assignmentOperator => ( '=' | '*=' | '/=' @ | '%=' | '+=' | '-=' | '<<=' | '>>=' )
    --> __________________
    --> #254: assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator @ assignmentExpressio
n )
    -->     Type: reduce
    -->     Reduce: assignmentExpression => ( conditionalExpression | unaryExpression @ assignmentOperator assignmentExp
ression )

** [FINAL] State #227: assignmentOperator => ( '=' | '*=' | '/=' | '%=' @ | '+=' | '-=' | '<<=' | '>>=' )
    --> __________________
    --> #254: assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator @ assignmentExpressio
n )
    -->     Type: reduce
    -->     Reduce: assignmentExpression => ( conditionalExpression | unaryExpression @ assignmentOperator assignmentExp
ression )

** [FINAL] State #228: assignmentOperator => ( '=' | '*=' | '/=' | '%=' | '+=' @ | '-=' | '<<=' | '>>=' )
    --> __________________
    --> #254: assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator @ assignmentExpressio
n )
    -->     Type: reduce
    -->     Reduce: assignmentExpression => ( conditionalExpression | unaryExpression @ assignmentOperator assignmentExp
ression )

** [FINAL] State #229: assignmentOperator => ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' @ | '<<=' | '>>=' )
    --> __________________
    --> #254: assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator @ assignmentExpressio
n )
    -->     Type: reduce
    -->     Reduce: assignmentExpression => ( conditionalExpression | unaryExpression @ assignmentOperator assignmentExp
ression )

** [FINAL] State #230: assignmentOperator => ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' @ | '>>=' )
    --> __________________
    --> #254: assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator @ assignmentExpressio
n )
    -->     Type: reduce
    -->     Reduce: assignmentExpression => ( conditionalExpression | unaryExpression @ assignmentOperator assignmentExp
ression )

** [FINAL] State #231: additiveExpression => [ additiveExpression ( '+' | '-' ) ] multiplicativeExpression @
    --> __________________
    --> #255: additiveExpression => [ additiveExpression @ ( '+' | '-' ) ] multiplicativeExpression
    -->     Type: recursion
    -->     LA: '+' '-'
    --> __________________
    --> #256: shiftExpression => [ shiftExpression ( '<<' | '>>' ) ] additiveExpression @
    -->     Type: reduce
    -->     Reduce: shiftExpression => [ @ shiftExpression ( '<<' | '>>' ) ] additiveExpression
    --> __________________
    --> #256: shiftExpression => [ shiftExpression ( '<<' | '>>' ) ] additiveExpression @
    -->     Type: reduce
    -->     Reduce: shiftExpression => [ shiftExpression ( '<<' | '>>' @ ) ] additiveExpression
    --> __________________
    --> #256: shiftExpression => [ shiftExpression ( '<<' | '>>' ) ] additiveExpression @
    -->     Type: reduce
    -->     Reduce: shiftExpression => [ shiftExpression ( '<<' @ | '>>' ) ] additiveExpression

** State #232: multiplicativeExpression => ( castExpression | multiplicativeExpression @ ( '*' castExpression | '/' cast
Expression | '%' castExpression ) )
    --> __________________
    --> #257: multiplicativeExpression => ( castExpression | multiplicativeExpression ( '*' castExpression | '/' castExp
ression | '%' @ castExpression ) )
    -->     Type: move
    -->     LA: '%'
    --> __________________
    --> #258: multiplicativeExpression => ( castExpression | multiplicativeExpression ( '*' @ castExpression | '/' castE
xpression | '%' castExpression ) )
    -->     Type: move
    -->     LA: '*'
    --> __________________
    --> #259: multiplicativeExpression => ( castExpression | multiplicativeExpression ( '*' castExpression | '/' @ castE
xpression | '%' castExpression ) )
    -->     Type: move
    -->     LA: '/'

** [FINAL] State #233: externalDeclaration => ( functionDefinition @ | declaration | ';' )
    --> __________________
    --> #6: translationUnit => [ translationUnit ] externalDeclaration @
    -->     Type: reduce
    -->     Reduce: translationUnit => [ @ translationUnit ] externalDeclaration
    --> __________________
    --> #6: translationUnit => [ translationUnit ] externalDeclaration @
    -->     Type: reduce
    -->     Reduce: translationUnit => [ translationUnit @ ] externalDeclaration

** [FINAL] State #234: blockItem => ( statement @ | declaration )
    --> __________________
    --> #213: blockItemList => [ blockItemList ] blockItem @
    -->     Type: reduce
    -->     Reduce: blockItemList => [ @ blockItemList ] blockItem
    --> __________________
    --> #213: blockItemList => [ blockItemList ] blockItem @
    -->     Type: reduce
    -->     Reduce: blockItemList => [ blockItemList @ ] blockItem

** State #235: iterationStatement => ( while '(' expression ')' statement | do statement @ while '(' expression ')' ';'
| for '(' forCondition ')' statement )
    --> __________________
    --> #260: iterationStatement => ( while '(' expression ')' statement | do statement while @ '(' expression ')' ';' |
 for '(' forCondition ')' statement )
    -->     Type: move
    -->     LA: while

** [FINAL] State #236: iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')
' ';' | for '(' forCondition ')' statement @ )
    --> __________________
    --> #261: statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iteration
Statement @ | jumpStatement )
    -->     Type: reduce
    -->     Reduce: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | i
terationStatement | jumpStatement )

** [FINAL] State #237: iterationStatement => ( while '(' expression ')' statement @ | do statement while '(' expression
')' ';' | for '(' forCondition ')' statement )
    --> __________________
    --> #261: statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iteration
Statement @ | jumpStatement )
    -->     Type: reduce
    -->     Reduce: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | i
terationStatement | jumpStatement )

** [FINAL] State #238: labeledStatement => ( #identifier# | case constantExpression | default ) '=' statement @
    --> __________________
    --> #262: statement => ( labeledStatement @ | compoundStatement | expressionStatement | selectionStatement | iterati
onStatement | jumpStatement )
    -->     Type: reduce
    -->     Reduce: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | i
terationStatement | jumpStatement )

** [FINAL] State #239: selectionStatement => ( if '(' expression ')' statement [ else statement ] | switch '(' expressio
n ')' statement @ )
    --> __________________
    --> #263: statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement @ | iterati
onStatement | jumpStatement )
    -->     Type: reduce
    -->     Reduce: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | i
terationStatement | jumpStatement )

** [FINAL] State #240: selectionStatement => ( if '(' expression ')' statement @ [ else statement ] | switch '(' express
ion ')' statement )
    --> __________________
    --> #264: selectionStatement => ( if '(' expression ')' statement [ else @ statement ] | switch '(' expression ')' s
tatement )
    -->     Type: move
    -->     LA: else
    --> __________________
    --> #263: statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement @ | iterati
onStatement | jumpStatement )
    -->     Type: reduce
    -->     Reduce: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | i
terationStatement | jumpStatement )

** [FINAL] State #241: selectionStatement => ( if '(' expression ')' statement [ else statement @ ] | switch '(' express
ion ')' statement )
    --> __________________
    --> #263: statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement @ | iterati
onStatement | jumpStatement )
    -->     Type: reduce
    -->     Reduce: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | i
terationStatement | jumpStatement )

** State #242: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterat
ionStatement | jumpStatement )
    --> __________________
    --> #265: jumpStatement => @ ( goto #identifier# ';' | continue ';' | break ';' | return [ expression ] ';' )
    -->     Type: shift
    -->     LA: goto continue return break
    --> __________________
    --> #266: labeledStatement => @ ( #identifier# | case constantExpression | default ) '=' statement
    -->     Type: shift
    -->     LA: #identifier# default case
    --> __________________
    --> #98: compoundStatement => @ '{' [ blockItemList ] '}'
    -->     Type: shift
    -->     LA: '{'
    --> __________________
    --> #267: expressionStatement => [ @ expression ] ';'
    -->     Type: shift
    -->     LA: ';' '*' #float# '~' #ulong#
    -->     LA: #long# #int# '!' #char# sizeof
    -->     LA: #identifier# #string# '--' '++' '-'
    -->     LA: #ushort# '(' #double# #short# '+'
    -->     LA: #uchar# #uint# '&'
    --> __________________
    --> #268: selectionStatement => @ ( if '(' expression ')' statement [ else statement ] | switch '(' expression ')' s
tatement )
    -->     Type: shift
    -->     LA: if switch
    --> __________________
    --> #269: iterationStatement => @ ( while '(' expression ')' statement | do statement while '(' expression ')' ';' |
 for '(' forCondition ')' statement )
    -->     Type: shift
    -->     LA: while do for

** State #243: primaryExpression => ( #identifier# | constant | #string# | '(' @ expression ')' )
    --> __________________
    --> #270: expression => [ @ expression ',' ] assignmentExpression
    -->     Type: shift
    -->     LA: #double# '&' #identifier# #uint# '*'
    -->     LA: #long# #uchar# '+' #short# '~'
    -->     LA: '(' #ushort# '-' #int# '++'
    -->     LA: '--' '!' sizeof #string# #char#
    -->     LA: #ulong# #float#

** [FINAL] State #244: primaryExpression => ( #identifier# @ | constant | #string# | '(' expression ')' )
    --> __________________
    --> #271: postfixExpression => ( primaryExpression @ | postfixExpression ( '[' expression ']' | '(' [ argumentExpres
sionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}'
 )
    -->     Type: reduce
    -->     Reduce: postfixExpression => @ ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argument
ExpressionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ','
 ] '}' )

** State #245: constant => @ ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #float# | #do
uble# )
    --> __________________
    --> #272: constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #float# | #doubl
e# @ )
    -->     Type: move
    -->     LA: #double#
    --> __________________
    --> #273: constant => ( #char# @ | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #float# | #dou
ble# )
    -->     Type: move
    -->     LA: #char#
    --> __________________
    --> #274: constant => ( #char# | #uchar# @ | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #float# | #dou
ble# )
    -->     Type: move
    -->     LA: #uchar#
    --> __________________
    --> #275: constant => ( #char# | #uchar# | #short# @ | #ushort# | #int# | #uint# | #long# | #ulong# | #float# | #dou
ble# )
    -->     Type: move
    -->     LA: #short#
    --> __________________
    --> #276: constant => ( #char# | #uchar# | #short# | #ushort# @ | #int# | #uint# | #long# | #ulong# | #float# | #dou
ble# )
    -->     Type: move
    -->     LA: #ushort#
    --> __________________
    --> #277: constant => ( #char# | #uchar# | #short# | #ushort# | #int# @ | #uint# | #long# | #ulong# | #float# | #dou
ble# )
    -->     Type: move
    -->     LA: #int#
    --> __________________
    --> #278: constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# @ | #long# | #ulong# | #float# | #dou
ble# )
    -->     Type: move
    -->     LA: #uint#
    --> __________________
    --> #279: constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# @ | #ulong# | #float# | #dou
ble# )
    -->     Type: move
    -->     LA: #long#
    --> __________________
    --> #280: constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# @ | #float# | #dou
ble# )
    -->     Type: move
    -->     LA: #ulong#
    --> __________________
    --> #281: constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #float# @ | #dou
ble# )
    -->     Type: move
    -->     LA: #float#

** [FINAL] State #246: primaryExpression => ( #identifier# | constant | #string# @ | '(' expression ')' )
    --> __________________
    --> #271: postfixExpression => ( primaryExpression @ | postfixExpression ( '[' expression ']' | '(' [ argumentExpres
sionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}'
 )
    -->     Type: reduce
    -->     Reduce: postfixExpression => @ ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argument
ExpressionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ','
 ] '}' )

** State #247: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator @ castExpression
 | sizeof ( unaryExpression | '(' typeName ')' ) )
    --> __________________
    --> #158: castExpression => @ ( '(' typeName ')' castExpression | unaryExpression )
    -->     Type: shift
    -->     LA: #double# '&' '*' #uint# '+'
    -->     LA: #uchar# #float# '~' #short# '('
    -->     LA: '-' #ushort# '++' '--' '!'
    -->     LA: #int# #char# sizeof #string# #identifier#
    -->     LA: #long# #ulong#

** State #248: inclusiveOrExpression => [ @ inclusiveOrExpression '|' ] exclusiveOrExpression
    --> __________________
    --> #282: exclusiveOrExpression => [ @ exclusiveOrExpression '^' ] andExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #249: blockItemList => [ blockItemList @ ] blockItem
    --> __________________
    --> #200: blockItem => @ ( statement | declaration )
    -->     Type: shift
    -->     LA: register typedef #long# extern static
    -->     LA: #short# auto signed #char# #identifier#
    -->     LA: volatile const '{' short void
    -->     LA: #double# double unsigned #float# float
    -->     LA: '--' long char bool int
    -->     LA: enum ';' struct #ushort# union
    -->     LA: #ulong# switch #int# return continue
    -->     LA: while #string# '(' case default
    -->     LA: '*' goto for break '~'
    -->     LA: '-' '!' do '&' sizeof
    -->     LA: #uchar# '++' if '+' #uint#

** State #250: compoundStatement => '{' [ blockItemList @ ] '}'
    --> __________________
    --> #164: compoundStatement => '{' [ blockItemList ] '}' @
    -->     Type: move
    -->     LA: '}'

** State #251: iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' ';' |
for '(' forCondition @ ')' statement )
    --> __________________
    --> #283: iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' ';' | f
or '(' forCondition ')' @ statement )
    -->     Type: move
    -->     LA: ')'

** [FINAL] State #252: enumerator => enumerationConstant @ [ '=' constantExpression ]
    --> __________________
    --> #284: enumerator => enumerationConstant [ '=' @ constantExpression ]
    -->     Type: move
    -->     LA: '='
    --> __________________
    --> #285: enumeratorList => [ enumeratorList ',' ] enumerator @
    -->     Type: reduce
    -->     Reduce: enumeratorList => [ @ enumeratorList ',' ] enumerator
    --> __________________
    --> #285: enumeratorList => [ enumeratorList ',' ] enumerator @
    -->     Type: reduce
    -->     Reduce: enumeratorList => [ enumeratorList ',' @ ] enumerator

** State #253: designatorList => [ @ designatorList ] designator
    --> __________________
    --> #286: designator => @ ( '[' constantExpression ']' | '.' #identifier# )
    -->     Type: shift
    -->     LA: '[' '.'

** State #254: assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator @ assignmentExpressi
on )
    --> __________________
    --> #108: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExpressio
n )
    -->     Type: shift
    -->     LA: #float# #ulong# #long# #int# #char#
    -->     LA: #identifier# #string# sizeof '!' '--'
    -->     LA: '++' '-' #ushort# '(' #short#
    -->     LA: '~' '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #255: additiveExpression => [ additiveExpression @ ( '+' | '-' ) ] multiplicativeExpression
    --> __________________
    --> #287: additiveExpression => [ additiveExpression ( '+' | '-' @ ) ] multiplicativeExpression
    -->     Type: move
    -->     LA: '-'
    --> __________________
    --> #288: additiveExpression => [ additiveExpression ( '+' @ | '-' ) ] multiplicativeExpression
    -->     Type: move
    -->     LA: '+'

** [FINAL] State #256: shiftExpression => [ shiftExpression ( '<<' | '>>' ) ] additiveExpression @
    --> __________________
    --> #289: relationalExpression => [ relationalExpression ( '<' | '>' | '<=' | '>=' ) ] shiftExpression @
    -->     Type: reduce
    -->     Reduce: relationalExpression => [ @ relationalExpression ( '<' | '>' | '<=' | '>=' ) ] shiftExpression
    --> __________________
    --> #289: relationalExpression => [ relationalExpression ( '<' | '>' | '<=' | '>=' ) ] shiftExpression @
    -->     Type: reduce
    -->     Reduce: relationalExpression => [ relationalExpression ( '<' | '>' | '<=' | '>=' @ ) ] shiftExpression
    --> __________________
    --> #289: relationalExpression => [ relationalExpression ( '<' | '>' | '<=' | '>=' ) ] shiftExpression @
    -->     Type: reduce
    -->     Reduce: relationalExpression => [ relationalExpression ( '<' @ | '>' | '<=' | '>=' ) ] shiftExpression
    --> __________________
    --> #289: relationalExpression => [ relationalExpression ( '<' | '>' | '<=' | '>=' ) ] shiftExpression @
    -->     Type: reduce
    -->     Reduce: relationalExpression => [ relationalExpression ( '<' | '>' @ | '<=' | '>=' ) ] shiftExpression
    --> __________________
    --> #289: relationalExpression => [ relationalExpression ( '<' | '>' | '<=' | '>=' ) ] shiftExpression @
    -->     Type: reduce
    -->     Reduce: relationalExpression => [ relationalExpression ( '<' | '>' | '<=' @ | '>=' ) ] shiftExpression
    --> __________________
    --> #290: shiftExpression => [ shiftExpression @ ( '<<' | '>>' ) ] additiveExpression
    -->     Type: recursion
    -->     LA: '<<' '>>'

** State #257: multiplicativeExpression => ( castExpression | multiplicativeExpression ( '*' castExpression | '/' castEx
pression | '%' @ castExpression ) )
    --> __________________
    --> #158: castExpression => @ ( '(' typeName ')' castExpression | unaryExpression )
    -->     Type: shift
    -->     LA: #double# '&' '*' #uint# '+'
    -->     LA: #uchar# #float# '~' #short# '('
    -->     LA: '-' #ushort# '++' '--' '!'
    -->     LA: #int# #char# sizeof #string# #identifier#
    -->     LA: #long# #ulong#

** State #258: multiplicativeExpression => ( castExpression | multiplicativeExpression ( '*' @ castExpression | '/' cast
Expression | '%' castExpression ) )
    --> __________________
    --> #158: castExpression => @ ( '(' typeName ')' castExpression | unaryExpression )
    -->     Type: shift
    -->     LA: #double# '&' '*' #uint# '+'
    -->     LA: #uchar# #float# '~' #short# '('
    -->     LA: '-' #ushort# '++' '--' '!'
    -->     LA: #int# #char# sizeof #string# #identifier#
    -->     LA: #long# #ulong#

** State #259: multiplicativeExpression => ( castExpression | multiplicativeExpression ( '*' castExpression | '/' @ cast
Expression | '%' castExpression ) )
    --> __________________
    --> #158: castExpression => @ ( '(' typeName ')' castExpression | unaryExpression )
    -->     Type: shift
    -->     LA: #double# '&' '*' #uint# '+'
    -->     LA: #uchar# #float# '~' #short# '('
    -->     LA: '-' #ushort# '++' '--' '!'
    -->     LA: #int# #char# sizeof #string# #identifier#
    -->     LA: #long# #ulong#

** State #260: iterationStatement => ( while '(' expression ')' statement | do statement while @ '(' expression ')' ';'
| for '(' forCondition ')' statement )
    --> __________________
    --> #291: iterationStatement => ( while '(' expression ')' statement | do statement while '(' @ expression ')' ';' |
 for '(' forCondition ')' statement )
    -->     Type: move
    -->     LA: '('

** [FINAL] State #261: statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement |
iterationStatement @ | jumpStatement )
    --> __________________
    --> #234: blockItem => ( statement @ | declaration )
    -->     Type: reduce
    -->     Reduce: blockItem => @ ( statement | declaration )
    --> __________________
    --> #235: iterationStatement => ( while '(' expression ')' statement | do statement @ while '(' expression ')' ';' |
 for '(' forCondition ')' statement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while '(' expression ')' statement | do @ statement while '(' expression ')'
 ';' | for '(' forCondition ')' statement )
    --> __________________
    --> #236: iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' ';' | f
or '(' forCondition ')' statement @ )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' '
;' | for '(' forCondition ')' @ statement )
    --> __________________
    --> #237: iterationStatement => ( while '(' expression ')' statement @ | do statement while '(' expression ')' ';' |
 for '(' forCondition ')' statement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while '(' expression ')' @ statement | do statement while '(' expression ')'
 ';' | for '(' forCondition ')' statement )
    --> __________________
    --> #238: labeledStatement => ( #identifier# | case constantExpression | default ) '=' statement @
    -->     Type: reduce
    -->     Reduce: labeledStatement => ( #identifier# | case constantExpression | default ) '=' @ statement
    --> __________________
    --> #239: selectionStatement => ( if '(' expression ')' statement [ else statement ] | switch '(' expression ')' sta
tement @ )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if '(' expression ')' statement [ else statement ] | switch '(' expression '
)' @ statement )
    --> __________________
    --> #240: selectionStatement => ( if '(' expression ')' statement @ [ else statement ] | switch '(' expression ')' s
tatement )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if '(' expression ')' @ statement [ else statement ] | switch '(' expression
 ')' statement )
    --> __________________
    --> #241: selectionStatement => ( if '(' expression ')' statement [ else statement @ ] | switch '(' expression ')' s
tatement )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if '(' expression ')' statement [ else @ statement ] | switch '(' expression
 ')' statement )

** [FINAL] State #262: statement => ( labeledStatement @ | compoundStatement | expressionStatement | selectionStatement
| iterationStatement | jumpStatement )
    --> __________________
    --> #234: blockItem => ( statement @ | declaration )
    -->     Type: reduce
    -->     Reduce: blockItem => @ ( statement | declaration )
    --> __________________
    --> #235: iterationStatement => ( while '(' expression ')' statement | do statement @ while '(' expression ')' ';' |
 for '(' forCondition ')' statement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while '(' expression ')' statement | do @ statement while '(' expression ')'
 ';' | for '(' forCondition ')' statement )
    --> __________________
    --> #236: iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' ';' | f
or '(' forCondition ')' statement @ )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' '
;' | for '(' forCondition ')' @ statement )
    --> __________________
    --> #237: iterationStatement => ( while '(' expression ')' statement @ | do statement while '(' expression ')' ';' |
 for '(' forCondition ')' statement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while '(' expression ')' @ statement | do statement while '(' expression ')'
 ';' | for '(' forCondition ')' statement )
    --> __________________
    --> #238: labeledStatement => ( #identifier# | case constantExpression | default ) '=' statement @
    -->     Type: reduce
    -->     Reduce: labeledStatement => ( #identifier# | case constantExpression | default ) '=' @ statement
    --> __________________
    --> #239: selectionStatement => ( if '(' expression ')' statement [ else statement ] | switch '(' expression ')' sta
tement @ )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if '(' expression ')' statement [ else statement ] | switch '(' expression '
)' @ statement )
    --> __________________
    --> #240: selectionStatement => ( if '(' expression ')' statement @ [ else statement ] | switch '(' expression ')' s
tatement )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if '(' expression ')' @ statement [ else statement ] | switch '(' expression
 ')' statement )
    --> __________________
    --> #241: selectionStatement => ( if '(' expression ')' statement [ else statement @ ] | switch '(' expression ')' s
tatement )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if '(' expression ')' statement [ else @ statement ] | switch '(' expression
 ')' statement )

** [FINAL] State #263: statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement @
| iterationStatement | jumpStatement )
    --> __________________
    --> #234: blockItem => ( statement @ | declaration )
    -->     Type: reduce
    -->     Reduce: blockItem => @ ( statement | declaration )
    --> __________________
    --> #235: iterationStatement => ( while '(' expression ')' statement | do statement @ while '(' expression ')' ';' |
 for '(' forCondition ')' statement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while '(' expression ')' statement | do @ statement while '(' expression ')'
 ';' | for '(' forCondition ')' statement )
    --> __________________
    --> #236: iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' ';' | f
or '(' forCondition ')' statement @ )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' '
;' | for '(' forCondition ')' @ statement )
    --> __________________
    --> #237: iterationStatement => ( while '(' expression ')' statement @ | do statement while '(' expression ')' ';' |
 for '(' forCondition ')' statement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while '(' expression ')' @ statement | do statement while '(' expression ')'
 ';' | for '(' forCondition ')' statement )
    --> __________________
    --> #238: labeledStatement => ( #identifier# | case constantExpression | default ) '=' statement @
    -->     Type: reduce
    -->     Reduce: labeledStatement => ( #identifier# | case constantExpression | default ) '=' @ statement
    --> __________________
    --> #239: selectionStatement => ( if '(' expression ')' statement [ else statement ] | switch '(' expression ')' sta
tement @ )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if '(' expression ')' statement [ else statement ] | switch '(' expression '
)' @ statement )
    --> __________________
    --> #240: selectionStatement => ( if '(' expression ')' statement @ [ else statement ] | switch '(' expression ')' s
tatement )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if '(' expression ')' @ statement [ else statement ] | switch '(' expression
 ')' statement )
    --> __________________
    --> #241: selectionStatement => ( if '(' expression ')' statement [ else statement @ ] | switch '(' expression ')' s
tatement )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if '(' expression ')' statement [ else @ statement ] | switch '(' expression
 ')' statement )

** State #264: selectionStatement => ( if '(' expression ')' statement [ else @ statement ] | switch '(' expression ')'
statement )
    --> __________________
    --> #242: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterati
onStatement | jumpStatement )
    -->     Type: shift
    -->     LA: '{' switch return continue while
    -->     LA: '(' #identifier# default case ';'
    -->     LA: '*' #long# goto #float# for
    -->     LA: #ulong# #int# break '-' '!'
    -->     LA: do '&' #char# '~' sizeof
    -->     LA: #string# '--' '++' #ushort# if
    -->     LA: #double# #short# '+' #uchar# #uint#

** State #265: jumpStatement => @ ( goto #identifier# ';' | continue ';' | break ';' | return [ expression ] ';' )
    --> __________________
    --> #292: jumpStatement => ( goto #identifier# ';' | continue ';' | break ';' | return @ [ expression ] ';' )
    -->     Type: move
    -->     LA: return
    --> __________________
    --> #293: jumpStatement => ( goto @ #identifier# ';' | continue ';' | break ';' | return [ expression ] ';' )
    -->     Type: move
    -->     LA: goto
    --> __________________
    --> #294: jumpStatement => ( goto #identifier# ';' | continue @ ';' | break ';' | return [ expression ] ';' )
    -->     Type: move
    -->     LA: continue
    --> __________________
    --> #295: jumpStatement => ( goto #identifier# ';' | continue ';' | break @ ';' | return [ expression ] ';' )
    -->     Type: move
    -->     LA: break

** State #266: labeledStatement => @ ( #identifier# | case constantExpression | default ) '=' statement
    --> __________________
    --> #296: labeledStatement => ( #identifier# | case constantExpression | default @ ) '=' statement
    -->     Type: move
    -->     LA: default
    --> __________________
    --> #297: labeledStatement => ( #identifier# @ | case constantExpression | default ) '=' statement
    -->     Type: move
    -->     LA: #identifier#
    --> __________________
    --> #298: labeledStatement => ( #identifier# | case @ constantExpression | default ) '=' statement
    -->     Type: move
    -->     LA: case

** State #267: expressionStatement => [ @ expression ] ';'
    --> __________________
    --> #270: expression => [ @ expression ',' ] assignmentExpression
    -->     Type: shift
    -->     LA: #double# '&' #identifier# #uint# '*'
    -->     LA: #long# #uchar# '+' #short# '~'
    -->     LA: '(' #ushort# '-' #int# '++'
    -->     LA: '--' '!' sizeof #string# #char#
    -->     LA: #ulong# #float#
    --> __________________
    --> #299: expressionStatement => [ expression ] ';' @
    -->     Type: move
    -->     LA: ';'

** State #268: selectionStatement => @ ( if '(' expression ')' statement [ else statement ] | switch '(' expression ')'
statement )
    --> __________________
    --> #300: selectionStatement => ( if '(' expression ')' statement [ else statement ] | switch @ '(' expression ')' s
tatement )
    -->     Type: move
    -->     LA: switch
    --> __________________
    --> #301: selectionStatement => ( if @ '(' expression ')' statement [ else statement ] | switch '(' expression ')' s
tatement )
    -->     Type: move
    -->     LA: if

** State #269: iterationStatement => @ ( while '(' expression ')' statement | do statement while '(' expression ')' ';'
| for '(' forCondition ')' statement )
    --> __________________
    --> #302: iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' ';' | f
or @ '(' forCondition ')' statement )
    -->     Type: move
    -->     LA: for
    --> __________________
    --> #303: iterationStatement => ( while @ '(' expression ')' statement | do statement while '(' expression ')' ';' |
 for '(' forCondition ')' statement )
    -->     Type: move
    -->     LA: while
    --> __________________
    --> #304: iterationStatement => ( while '(' expression ')' statement | do @ statement while '(' expression ')' ';' |
 for '(' forCondition ')' statement )
    -->     Type: move
    -->     LA: do

** State #270: expression => [ @ expression ',' ] assignmentExpression
    --> __________________
    --> #108: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExpressio
n )
    -->     Type: shift
    -->     LA: #float# #ulong# #long# #int# #char#
    -->     LA: #identifier# #string# sizeof '!' '--'
    -->     LA: '++' '-' #ushort# '(' #short#
    -->     LA: '~' '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** [FINAL] State #271: postfixExpression => ( primaryExpression @ | postfixExpression ( '[' expression ']' | '(' [ argum
entExpressionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [
',' ] '}' )
    --> __________________
    --> #305: postfixExpression => ( primaryExpression | postfixExpression @ ( '[' expression ']' | '(' [ argumentExpres
sionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}'
 )
    -->     Type: recursion
    --> __________________
    --> #306: unaryExpression => ( postfixExpression @ | ( '++' | '--' ) unaryExpression | unaryOperator castExpression
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => @ ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpre
ssion | sizeof ( unaryExpression | '(' typeName ')' ) )

** [FINAL] State #272: constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #float#
 | #double# @ )
    --> __________________
    --> #307: primaryExpression => ( #identifier# | constant @ | #string# | '(' expression ')' )
    -->     Type: reduce
    -->     Reduce: primaryExpression => @ ( #identifier# | constant | #string# | '(' expression ')' )

** [FINAL] State #273: constant => ( #char# @ | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #floa
t# | #double# )
    --> __________________
    --> #307: primaryExpression => ( #identifier# | constant @ | #string# | '(' expression ')' )
    -->     Type: reduce
    -->     Reduce: primaryExpression => @ ( #identifier# | constant | #string# | '(' expression ')' )

** [FINAL] State #274: constant => ( #char# | #uchar# @ | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #floa
t# | #double# )
    --> __________________
    --> #307: primaryExpression => ( #identifier# | constant @ | #string# | '(' expression ')' )
    -->     Type: reduce
    -->     Reduce: primaryExpression => @ ( #identifier# | constant | #string# | '(' expression ')' )

** [FINAL] State #275: constant => ( #char# | #uchar# | #short# @ | #ushort# | #int# | #uint# | #long# | #ulong# | #floa
t# | #double# )
    --> __________________
    --> #307: primaryExpression => ( #identifier# | constant @ | #string# | '(' expression ')' )
    -->     Type: reduce
    -->     Reduce: primaryExpression => @ ( #identifier# | constant | #string# | '(' expression ')' )

** [FINAL] State #276: constant => ( #char# | #uchar# | #short# | #ushort# @ | #int# | #uint# | #long# | #ulong# | #floa
t# | #double# )
    --> __________________
    --> #307: primaryExpression => ( #identifier# | constant @ | #string# | '(' expression ')' )
    -->     Type: reduce
    -->     Reduce: primaryExpression => @ ( #identifier# | constant | #string# | '(' expression ')' )

** [FINAL] State #277: constant => ( #char# | #uchar# | #short# | #ushort# | #int# @ | #uint# | #long# | #ulong# | #floa
t# | #double# )
    --> __________________
    --> #307: primaryExpression => ( #identifier# | constant @ | #string# | '(' expression ')' )
    -->     Type: reduce
    -->     Reduce: primaryExpression => @ ( #identifier# | constant | #string# | '(' expression ')' )

** [FINAL] State #278: constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# @ | #long# | #ulong# | #floa
t# | #double# )
    --> __________________
    --> #307: primaryExpression => ( #identifier# | constant @ | #string# | '(' expression ')' )
    -->     Type: reduce
    -->     Reduce: primaryExpression => @ ( #identifier# | constant | #string# | '(' expression ')' )

** [FINAL] State #279: constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# @ | #ulong# | #floa
t# | #double# )
    --> __________________
    --> #307: primaryExpression => ( #identifier# | constant @ | #string# | '(' expression ')' )
    -->     Type: reduce
    -->     Reduce: primaryExpression => @ ( #identifier# | constant | #string# | '(' expression ')' )

** [FINAL] State #280: constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# @ | #floa
t# | #double# )
    --> __________________
    --> #307: primaryExpression => ( #identifier# | constant @ | #string# | '(' expression ')' )
    -->     Type: reduce
    -->     Reduce: primaryExpression => @ ( #identifier# | constant | #string# | '(' expression ')' )

** [FINAL] State #281: constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #float#
 @ | #double# )
    --> __________________
    --> #307: primaryExpression => ( #identifier# | constant @ | #string# | '(' expression ')' )
    -->     Type: reduce
    -->     Reduce: primaryExpression => @ ( #identifier# | constant | #string# | '(' expression ')' )

** State #282: exclusiveOrExpression => [ @ exclusiveOrExpression '^' ] andExpression
    --> __________________
    --> #308: andExpression => [ @ andExpression '&' ] equalityExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #283: iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' ';' |
for '(' forCondition ')' @ statement )
    --> __________________
    --> #242: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterati
onStatement | jumpStatement )
    -->     Type: shift
    -->     LA: '{' switch return continue while
    -->     LA: '(' #identifier# default case ';'
    -->     LA: '*' #long# goto #float# for
    -->     LA: #ulong# #int# break '-' '!'
    -->     LA: do '&' #char# '~' sizeof
    -->     LA: #string# '--' '++' #ushort# if
    -->     LA: #double# #short# '+' #uchar# #uint#

** State #284: enumerator => enumerationConstant [ '=' @ constantExpression ]
    --> __________________
    --> #139: constantExpression => @ conditionalExpression
    -->     Type: shift
    -->     LA: #double# '&' '*' #uint# '+'
    -->     LA: #uchar# #float# '~' #short# '('
    -->     LA: '-' #ushort# '++' '--' '!'
    -->     LA: #int# #char# sizeof #string# #identifier#
    -->     LA: #long# #ulong#

** [FINAL] State #285: enumeratorList => [ enumeratorList ',' ] enumerator @
    --> __________________
    --> #309: enumSpecifier => enum ( [ #identifier# ] '{' enumeratorList @ [ ',' ] '{' | #identifier# )
    -->     Type: reduce
    -->     Reduce: enumSpecifier => enum ( [ #identifier# ] '{' @ enumeratorList [ ',' ] '{' | #identifier# )
    --> __________________
    --> #310: enumeratorList => [ enumeratorList @ ',' ] enumerator
    -->     Type: recursion
    -->     LA: ','

** State #286: designator => @ ( '[' constantExpression ']' | '.' #identifier# )
    --> __________________
    --> #311: designator => ( '[' constantExpression ']' | '.' @ #identifier# )
    -->     Type: move
    -->     LA: '.'
    --> __________________
    --> #312: designator => ( '[' @ constantExpression ']' | '.' #identifier# )
    -->     Type: move
    -->     LA: '['

** State #287: additiveExpression => [ additiveExpression ( '+' | '-' @ ) ] multiplicativeExpression
    --> __________________
    --> #313: multiplicativeExpression => @ ( castExpression | multiplicativeExpression ( '*' castExpression | '/' castE
xpression | '%' castExpression ) )
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #288: additiveExpression => [ additiveExpression ( '+' @ | '-' ) ] multiplicativeExpression
    --> __________________
    --> #313: multiplicativeExpression => @ ( castExpression | multiplicativeExpression ( '*' castExpression | '/' castE
xpression | '%' castExpression ) )
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** [FINAL] State #289: relationalExpression => [ relationalExpression ( '<' | '>' | '<=' | '>=' ) ] shiftExpression @
    --> __________________
    --> #314: equalityExpression => [ equalityExpression ( '==' | '!=' ) ] relationalExpression @
    -->     Type: reduce
    -->     Reduce: equalityExpression => [ @ equalityExpression ( '==' | '!=' ) ] relationalExpression
    --> __________________
    --> #314: equalityExpression => [ equalityExpression ( '==' | '!=' ) ] relationalExpression @
    -->     Type: reduce
    -->     Reduce: equalityExpression => [ equalityExpression ( '==' | '!=' @ ) ] relationalExpression
    --> __________________
    --> #314: equalityExpression => [ equalityExpression ( '==' | '!=' ) ] relationalExpression @
    -->     Type: reduce
    -->     Reduce: equalityExpression => [ equalityExpression ( '==' @ | '!=' ) ] relationalExpression
    --> __________________
    --> #315: relationalExpression => [ relationalExpression @ ( '<' | '>' | '<=' | '>=' ) ] shiftExpression
    -->     Type: recursion
    -->     LA: '<=' '>' '<' '>='

** State #290: shiftExpression => [ shiftExpression @ ( '<<' | '>>' ) ] additiveExpression
    --> __________________
    --> #316: shiftExpression => [ shiftExpression ( '<<' | '>>' @ ) ] additiveExpression
    -->     Type: move
    -->     LA: '>>'
    --> __________________
    --> #317: shiftExpression => [ shiftExpression ( '<<' @ | '>>' ) ] additiveExpression
    -->     Type: move
    -->     LA: '<<'

** State #291: iterationStatement => ( while '(' expression ')' statement | do statement while '(' @ expression ')' ';'
| for '(' forCondition ')' statement )
    --> __________________
    --> #270: expression => [ @ expression ',' ] assignmentExpression
    -->     Type: shift
    -->     LA: #double# '&' #identifier# #uint# '*'
    -->     LA: #long# #uchar# '+' #short# '~'
    -->     LA: '(' #ushort# '-' #int# '++'
    -->     LA: '--' '!' sizeof #string# #char#
    -->     LA: #ulong# #float#

** State #292: jumpStatement => ( goto #identifier# ';' | continue ';' | break ';' | return @ [ expression ] ';' )
    --> __________________
    --> #318: jumpStatement => ( goto #identifier# ';' | continue ';' | break ';' | return [ expression ] ';' @ )
    -->     Type: move
    -->     LA: ';'
    --> __________________
    --> #270: expression => [ @ expression ',' ] assignmentExpression
    -->     Type: shift
    -->     LA: #double# '&' #identifier# #uint# '*'
    -->     LA: #long# #uchar# '+' #short# '~'
    -->     LA: '(' #ushort# '-' #int# '++'
    -->     LA: '--' '!' sizeof #string# #char#
    -->     LA: #ulong# #float#

** State #293: jumpStatement => ( goto @ #identifier# ';' | continue ';' | break ';' | return [ expression ] ';' )
    --> __________________
    --> #319: jumpStatement => ( goto #identifier# @ ';' | continue ';' | break ';' | return [ expression ] ';' )
    -->     Type: move
    -->     LA: #identifier#

** State #294: jumpStatement => ( goto #identifier# ';' | continue @ ';' | break ';' | return [ expression ] ';' )
    --> __________________
    --> #320: jumpStatement => ( goto #identifier# ';' | continue ';' @ | break ';' | return [ expression ] ';' )
    -->     Type: move
    -->     LA: ';'

** State #295: jumpStatement => ( goto #identifier# ';' | continue ';' | break @ ';' | return [ expression ] ';' )
    --> __________________
    --> #321: jumpStatement => ( goto #identifier# ';' | continue ';' | break ';' @ | return [ expression ] ';' )
    -->     Type: move
    -->     LA: ';'

** State #296: labeledStatement => ( #identifier# | case constantExpression | default @ ) '=' statement
    --> __________________
    --> #322: labeledStatement => ( #identifier# | case constantExpression | default ) '=' @ statement
    -->     Type: move
    -->     LA: '='

** State #297: labeledStatement => ( #identifier# @ | case constantExpression | default ) '=' statement
    --> __________________
    --> #322: labeledStatement => ( #identifier# | case constantExpression | default ) '=' @ statement
    -->     Type: move
    -->     LA: '='

** State #298: labeledStatement => ( #identifier# | case @ constantExpression | default ) '=' statement
    --> __________________
    --> #139: constantExpression => @ conditionalExpression
    -->     Type: shift
    -->     LA: #double# '&' '*' #uint# '+'
    -->     LA: #uchar# #float# '~' #short# '('
    -->     LA: '-' #ushort# '++' '--' '!'
    -->     LA: #int# #char# sizeof #string# #identifier#
    -->     LA: #long# #ulong#

** [FINAL] State #299: expressionStatement => [ expression ] ';' @
    --> __________________
    --> #323: statement => ( labeledStatement | compoundStatement | expressionStatement @ | selectionStatement | iterati
onStatement | jumpStatement )
    -->     Type: reduce
    -->     Reduce: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | i
terationStatement | jumpStatement )

** State #300: selectionStatement => ( if '(' expression ')' statement [ else statement ] | switch @ '(' expression ')'
statement )
    --> __________________
    --> #324: selectionStatement => ( if '(' expression ')' statement [ else statement ] | switch '(' @ expression ')' s
tatement )
    -->     Type: move
    -->     LA: '('

** State #301: selectionStatement => ( if @ '(' expression ')' statement [ else statement ] | switch '(' expression ')'
statement )
    --> __________________
    --> #325: selectionStatement => ( if '(' @ expression ')' statement [ else statement ] | switch '(' expression ')' s
tatement )
    -->     Type: move
    -->     LA: '('

** State #302: iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' ';' |
for @ '(' forCondition ')' statement )
    --> __________________
    --> #326: iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' ';' | f
or '(' @ forCondition ')' statement )
    -->     Type: move
    -->     LA: '('

** State #303: iterationStatement => ( while @ '(' expression ')' statement | do statement while '(' expression ')' ';'
| for '(' forCondition ')' statement )
    --> __________________
    --> #327: iterationStatement => ( while '(' @ expression ')' statement | do statement while '(' expression ')' ';' |
 for '(' forCondition ')' statement )
    -->     Type: move
    -->     LA: '('

** State #304: iterationStatement => ( while '(' expression ')' statement | do @ statement while '(' expression ')' ';'
| for '(' forCondition ')' statement )
    --> __________________
    --> #242: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterati
onStatement | jumpStatement )
    -->     Type: shift
    -->     LA: '{' switch return continue while
    -->     LA: '(' #identifier# default case ';'
    -->     LA: '*' #long# goto #float# for
    -->     LA: #ulong# #int# break '-' '!'
    -->     LA: do '&' #char# '~' sizeof
    -->     LA: #string# '--' '++' #ushort# if
    -->     LA: #double# #short# '+' #uchar# #uint#

** State #305: postfixExpression => ( primaryExpression | postfixExpression @ ( '[' expression ']' | '(' [ argumentExpre
ssionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}
' )
    --> __________________
    --> #328: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpressi
onList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' @ ) | '(' typeName ')' '{' initializerList [ ',' ] '}'
 )
    -->     Type: move
    -->     LA: '--'
    --> __________________
    --> #329: postfixExpression => ( primaryExpression | postfixExpression ( '[' @ expression ']' | '(' [ argumentExpres
sionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}'
 )
    -->     Type: move
    -->     LA: '['
    --> __________________
    --> #330: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' @ [ argumentExpres
sionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}'
 )
    -->     Type: move
    -->     LA: '('
    --> __________________
    --> #331: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpressi
onList ] ')' | '.' @ #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}'
 )
    -->     Type: move
    -->     LA: '.'
    --> __________________
    --> #332: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpressi
onList ] ')' | '.' #identifier# | '->' @ #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}'
 )
    -->     Type: move
    -->     LA: '->'
    --> __________________
    --> #333: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpressi
onList ] ')' | '.' #identifier# | '->' #identifier# | '++' @ | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}'
 )
    -->     Type: move
    -->     LA: '++'

** [FINAL] State #306: unaryExpression => ( postfixExpression @ | ( '++' | '--' ) unaryExpression | unaryOperator castEx
pression | sizeof ( unaryExpression | '(' typeName ')' ) )
    --> __________________
    --> #160: assignmentExpression => ( conditionalExpression | unaryExpression @ assignmentOperator assignmentExpressio
n )
    -->     Type: reduce
    -->     Reduce: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExp
ression )
    --> __________________
    --> #161: castExpression => ( '(' typeName ')' castExpression | unaryExpression @ )
    -->     Type: reduce
    -->     Reduce: castExpression => @ ( '(' typeName ')' castExpression | unaryExpression )
    --> __________________
    --> #162: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression @ | unaryOperator castExpression
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => ( postfixExpression | ( '++' | '--' @ ) unaryExpression | unaryOperator castExpre
ssion | sizeof ( unaryExpression | '(' typeName ')' ) )
    --> __________________
    --> #163: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression |
sizeof ( unaryExpression @ | '(' typeName ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpress
ion | sizeof @ ( unaryExpression | '(' typeName ')' ) )
    --> __________________
    --> #162: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression @ | unaryOperator castExpression
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => ( postfixExpression | ( '++' @ | '--' ) unaryExpression | unaryOperator castExpre
ssion | sizeof ( unaryExpression | '(' typeName ')' ) )

** [FINAL] State #307: primaryExpression => ( #identifier# | constant @ | #string# | '(' expression ')' )
    --> __________________
    --> #271: postfixExpression => ( primaryExpression @ | postfixExpression ( '[' expression ']' | '(' [ argumentExpres
sionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}'
 )
    -->     Type: reduce
    -->     Reduce: postfixExpression => @ ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argument
ExpressionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ','
 ] '}' )

** State #308: andExpression => [ @ andExpression '&' ] equalityExpression
    --> __________________
    --> #334: equalityExpression => [ @ equalityExpression ( '==' | '!=' ) ] relationalExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #309: enumSpecifier => enum ( [ #identifier# ] '{' enumeratorList @ [ ',' ] '{' | #identifier# )
    --> __________________
    --> #335: enumSpecifier => enum ( [ #identifier# ] '{' enumeratorList [ ',' ] '{' @ | #identifier# )
    -->     Type: move
    -->     LA: '{'
    --> __________________
    --> #336: enumSpecifier => enum ( [ #identifier# ] '{' enumeratorList [ ',' @ ] '{' | #identifier# )
    -->     Type: move
    -->     LA: ','

** State #310: enumeratorList => [ enumeratorList @ ',' ] enumerator
    --> __________________
    --> #337: enumeratorList => [ enumeratorList ',' @ ] enumerator
    -->     Type: move
    -->     LA: ','

** State #311: designator => ( '[' constantExpression ']' | '.' @ #identifier# )
    --> __________________
    --> #338: designator => ( '[' constantExpression ']' | '.' #identifier# @ )
    -->     Type: move
    -->     LA: #identifier#

** State #312: designator => ( '[' @ constantExpression ']' | '.' #identifier# )
    --> __________________
    --> #139: constantExpression => @ conditionalExpression
    -->     Type: shift
    -->     LA: #double# '&' '*' #uint# '+'
    -->     LA: #uchar# #float# '~' #short# '('
    -->     LA: '-' #ushort# '++' '--' '!'
    -->     LA: #int# #char# sizeof #string# #identifier#
    -->     LA: #long# #ulong#

** State #313: multiplicativeExpression => @ ( castExpression | multiplicativeExpression ( '*' castExpression | '/' cast
Expression | '%' castExpression ) )
    --> __________________
    --> #158: castExpression => @ ( '(' typeName ')' castExpression | unaryExpression )
    -->     Type: shift
    -->     LA: #double# '&' '*' #uint# '+'
    -->     LA: #uchar# #float# '~' #short# '('
    -->     LA: '-' #ushort# '++' '--' '!'
    -->     LA: #int# #char# sizeof #string# #identifier#
    -->     LA: #long# #ulong#

** [FINAL] State #314: equalityExpression => [ equalityExpression ( '==' | '!=' ) ] relationalExpression @
    --> __________________
    --> #339: andExpression => [ andExpression '&' ] equalityExpression @
    -->     Type: reduce
    -->     Reduce: andExpression => [ @ andExpression '&' ] equalityExpression
    --> __________________
    --> #339: andExpression => [ andExpression '&' ] equalityExpression @
    -->     Type: reduce
    -->     Reduce: andExpression => [ andExpression '&' @ ] equalityExpression
    --> __________________
    --> #340: equalityExpression => [ equalityExpression @ ( '==' | '!=' ) ] relationalExpression
    -->     Type: recursion
    -->     LA: '==' '!='

** State #315: relationalExpression => [ relationalExpression @ ( '<' | '>' | '<=' | '>=' ) ] shiftExpression
    --> __________________
    --> #341: relationalExpression => [ relationalExpression ( '<' | '>' | '<=' | '>=' @ ) ] shiftExpression
    -->     Type: move
    -->     LA: '>='
    --> __________________
    --> #342: relationalExpression => [ relationalExpression ( '<' @ | '>' | '<=' | '>=' ) ] shiftExpression
    -->     Type: move
    -->     LA: '<'
    --> __________________
    --> #343: relationalExpression => [ relationalExpression ( '<' | '>' @ | '<=' | '>=' ) ] shiftExpression
    -->     Type: move
    -->     LA: '>'
    --> __________________
    --> #344: relationalExpression => [ relationalExpression ( '<' | '>' | '<=' @ | '>=' ) ] shiftExpression
    -->     Type: move
    -->     LA: '<='

** State #316: shiftExpression => [ shiftExpression ( '<<' | '>>' @ ) ] additiveExpression
    --> __________________
    --> #345: additiveExpression => [ @ additiveExpression ( '+' | '-' ) ] multiplicativeExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #317: shiftExpression => [ shiftExpression ( '<<' @ | '>>' ) ] additiveExpression
    --> __________________
    --> #345: additiveExpression => [ @ additiveExpression ( '+' | '-' ) ] multiplicativeExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** [FINAL] State #318: jumpStatement => ( goto #identifier# ';' | continue ';' | break ';' | return [ expression ] ';' @
 )
    --> __________________
    --> #346: statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iteration
Statement | jumpStatement @ )
    -->     Type: reduce
    -->     Reduce: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | i
terationStatement | jumpStatement )

** State #319: jumpStatement => ( goto #identifier# @ ';' | continue ';' | break ';' | return [ expression ] ';' )
    --> __________________
    --> #347: jumpStatement => ( goto #identifier# ';' @ | continue ';' | break ';' | return [ expression ] ';' )
    -->     Type: move
    -->     LA: ';'

** [FINAL] State #320: jumpStatement => ( goto #identifier# ';' | continue ';' @ | break ';' | return [ expression ] ';'
 )
    --> __________________
    --> #346: statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iteration
Statement | jumpStatement @ )
    -->     Type: reduce
    -->     Reduce: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | i
terationStatement | jumpStatement )

** [FINAL] State #321: jumpStatement => ( goto #identifier# ';' | continue ';' | break ';' @ | return [ expression ] ';'
 )
    --> __________________
    --> #346: statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iteration
Statement | jumpStatement @ )
    -->     Type: reduce
    -->     Reduce: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | i
terationStatement | jumpStatement )

** State #322: labeledStatement => ( #identifier# | case constantExpression | default ) '=' @ statement
    --> __________________
    --> #242: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterati
onStatement | jumpStatement )
    -->     Type: shift
    -->     LA: '{' switch return continue while
    -->     LA: '(' #identifier# default case ';'
    -->     LA: '*' #long# goto #float# for
    -->     LA: #ulong# #int# break '-' '!'
    -->     LA: do '&' #char# '~' sizeof
    -->     LA: #string# '--' '++' #ushort# if
    -->     LA: #double# #short# '+' #uchar# #uint#

** [FINAL] State #323: statement => ( labeledStatement | compoundStatement | expressionStatement @ | selectionStatement
| iterationStatement | jumpStatement )
    --> __________________
    --> #234: blockItem => ( statement @ | declaration )
    -->     Type: reduce
    -->     Reduce: blockItem => @ ( statement | declaration )
    --> __________________
    --> #235: iterationStatement => ( while '(' expression ')' statement | do statement @ while '(' expression ')' ';' |
 for '(' forCondition ')' statement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while '(' expression ')' statement | do @ statement while '(' expression ')'
 ';' | for '(' forCondition ')' statement )
    --> __________________
    --> #236: iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' ';' | f
or '(' forCondition ')' statement @ )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' '
;' | for '(' forCondition ')' @ statement )
    --> __________________
    --> #237: iterationStatement => ( while '(' expression ')' statement @ | do statement while '(' expression ')' ';' |
 for '(' forCondition ')' statement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while '(' expression ')' @ statement | do statement while '(' expression ')'
 ';' | for '(' forCondition ')' statement )
    --> __________________
    --> #238: labeledStatement => ( #identifier# | case constantExpression | default ) '=' statement @
    -->     Type: reduce
    -->     Reduce: labeledStatement => ( #identifier# | case constantExpression | default ) '=' @ statement
    --> __________________
    --> #239: selectionStatement => ( if '(' expression ')' statement [ else statement ] | switch '(' expression ')' sta
tement @ )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if '(' expression ')' statement [ else statement ] | switch '(' expression '
)' @ statement )
    --> __________________
    --> #240: selectionStatement => ( if '(' expression ')' statement @ [ else statement ] | switch '(' expression ')' s
tatement )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if '(' expression ')' @ statement [ else statement ] | switch '(' expression
 ')' statement )
    --> __________________
    --> #241: selectionStatement => ( if '(' expression ')' statement [ else statement @ ] | switch '(' expression ')' s
tatement )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if '(' expression ')' statement [ else @ statement ] | switch '(' expression
 ')' statement )

** State #324: selectionStatement => ( if '(' expression ')' statement [ else statement ] | switch '(' @ expression ')'
statement )
    --> __________________
    --> #270: expression => [ @ expression ',' ] assignmentExpression
    -->     Type: shift
    -->     LA: #double# '&' #identifier# #uint# '*'
    -->     LA: #long# #uchar# '+' #short# '~'
    -->     LA: '(' #ushort# '-' #int# '++'
    -->     LA: '--' '!' sizeof #string# #char#
    -->     LA: #ulong# #float#

** State #325: selectionStatement => ( if '(' @ expression ')' statement [ else statement ] | switch '(' expression ')'
statement )
    --> __________________
    --> #270: expression => [ @ expression ',' ] assignmentExpression
    -->     Type: shift
    -->     LA: #double# '&' #identifier# #uint# '*'
    -->     LA: #long# #uchar# '+' #short# '~'
    -->     LA: '(' #ushort# '-' #int# '++'
    -->     LA: '--' '!' sizeof #string# #char#
    -->     LA: #ulong# #float#

** State #326: iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' ';' |
for '(' @ forCondition ')' statement )
    --> __________________
    --> #348: forCondition => @ ( forDeclaration | [ expression ] ) ';' [ forExpression ] ';' [ forExpression ]
    -->     Type: shift
    -->     LA: #uint# #uchar# sizeof '+' #short#
    -->     LA: #double# void '(' #ushort# static
    -->     LA: '++' struct '--' #string# '&'
    -->     LA: #identifier# volatile #char# '!' '-'
    -->     LA: #int# typedef #ulong# union float
    -->     LA: '~' #float# unsigned #long# '*'
    -->     LA: signed ';' enum int bool
    -->     LA: char long double short const
    -->     LA: auto extern register

** State #327: iterationStatement => ( while '(' @ expression ')' statement | do statement while '(' expression ')' ';'
| for '(' forCondition ')' statement )
    --> __________________
    --> #270: expression => [ @ expression ',' ] assignmentExpression
    -->     Type: shift
    -->     LA: #double# '&' #identifier# #uint# '*'
    -->     LA: #long# #uchar# '+' #short# '~'
    -->     LA: '(' #ushort# '-' #int# '++'
    -->     LA: '--' '!' sizeof #string# #char#
    -->     LA: #ulong# #float#

** [FINAL] State #328: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumen
tExpressionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' @ ) | '(' typeName ')' '{' initializerList [
',' ] '}' )
    --> __________________
    --> #305: postfixExpression => ( primaryExpression | postfixExpression @ ( '[' expression ']' | '(' [ argumentExpres
sionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}'
 )
    -->     Type: recursion
    -->     LA: '++' '->' '[' '--' '('
    -->     LA: '.'
    --> __________________
    --> #306: unaryExpression => ( postfixExpression @ | ( '++' | '--' ) unaryExpression | unaryOperator castExpression
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => @ ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpre
ssion | sizeof ( unaryExpression | '(' typeName ')' ) )

** State #329: postfixExpression => ( primaryExpression | postfixExpression ( '[' @ expression ']' | '(' [ argumentExpre
ssionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}
' )
    --> __________________
    --> #270: expression => [ @ expression ',' ] assignmentExpression
    -->     Type: shift
    -->     LA: #double# '&' #identifier# #uint# '*'
    -->     LA: #long# #uchar# '+' #short# '~'
    -->     LA: '(' #ushort# '-' #int# '++'
    -->     LA: '--' '!' sizeof #string# #char#
    -->     LA: #ulong# #float#

** State #330: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' @ [ argumentExpre
ssionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}
' )
    --> __________________
    --> #349: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpressi
onList ] ')' @ | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}'
 )
    -->     Type: move
    -->     LA: ')'
    --> __________________
    --> #350: argumentExpressionList => [ @ argumentExpressionList ',' ] assignmentExpression
    -->     Type: shift
    -->     LA: #double# '&' #identifier# #uint# '*'
    -->     LA: #long# #uchar# '+' #short# '~'
    -->     LA: '(' #ushort# '-' #int# '++'
    -->     LA: '--' '!' sizeof #string# #char#
    -->     LA: #ulong# #float#

** State #331: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpress
ionList ] ')' | '.' @ #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}
' )
    --> __________________
    --> #351: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpressi
onList ] ')' | '.' #identifier# @ | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}'
 )
    -->     Type: move
    -->     LA: #identifier#

** State #332: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpress
ionList ] ')' | '.' #identifier# | '->' @ #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}
' )
    --> __________________
    --> #352: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpressi
onList ] ')' | '.' #identifier# | '->' #identifier# @ | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}'
 )
    -->     Type: move
    -->     LA: #identifier#

** [FINAL] State #333: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumen
tExpressionList ] ')' | '.' #identifier# | '->' #identifier# | '++' @ | '--' ) | '(' typeName ')' '{' initializerList [
',' ] '}' )
    --> __________________
    --> #305: postfixExpression => ( primaryExpression | postfixExpression @ ( '[' expression ']' | '(' [ argumentExpres
sionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}'
 )
    -->     Type: recursion
    -->     LA: '++' '->' '[' '--' '('
    -->     LA: '.'
    --> __________________
    --> #306: unaryExpression => ( postfixExpression @ | ( '++' | '--' ) unaryExpression | unaryOperator castExpression
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => @ ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpre
ssion | sizeof ( unaryExpression | '(' typeName ')' ) )

** State #334: equalityExpression => [ @ equalityExpression ( '==' | '!=' ) ] relationalExpression
    --> __________________
    --> #353: relationalExpression => [ @ relationalExpression ( '<' | '>' | '<=' | '>=' ) ] shiftExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** [FINAL] State #335: enumSpecifier => enum ( [ #identifier# ] '{' enumeratorList [ ',' ] '{' @ | #identifier# )
    --> __________________
    --> #122: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOr
UnionSpecifier | enumSpecifier @ | typedefName | typeSpecifier pointer )
    -->     Type: reduce
    -->     Reduce: typeSpecifier => @ ( void | char | short | int | long | float | double | signed | unsigned | bool |
structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )

** State #336: enumSpecifier => enum ( [ #identifier# ] '{' enumeratorList [ ',' @ ] '{' | #identifier# )
    --> __________________
    --> #335: enumSpecifier => enum ( [ #identifier# ] '{' enumeratorList [ ',' ] '{' @ | #identifier# )
    -->     Type: move
    -->     LA: '{'

** State #337: enumeratorList => [ enumeratorList ',' @ ] enumerator
    --> __________________
    --> #153: enumerator => @ enumerationConstant [ '=' constantExpression ]
    -->     Type: shift
    -->     LA: #identifier#

** [FINAL] State #338: designator => ( '[' constantExpression ']' | '.' #identifier# @ )
    --> __________________
    --> #354: designatorList => [ designatorList ] designator @
    -->     Type: reduce
    -->     Reduce: designatorList => [ @ designatorList ] designator
    --> __________________
    --> #354: designatorList => [ designatorList ] designator @
    -->     Type: reduce
    -->     Reduce: designatorList => [ designatorList @ ] designator

** [FINAL] State #339: andExpression => [ andExpression '&' ] equalityExpression @
    --> __________________
    --> #355: andExpression => [ andExpression @ '&' ] equalityExpression
    -->     Type: recursion
    -->     LA: '&'
    --> __________________
    --> #356: exclusiveOrExpression => [ exclusiveOrExpression '^' ] andExpression @
    -->     Type: reduce
    -->     Reduce: exclusiveOrExpression => [ @ exclusiveOrExpression '^' ] andExpression
    --> __________________
    --> #356: exclusiveOrExpression => [ exclusiveOrExpression '^' ] andExpression @
    -->     Type: reduce
    -->     Reduce: exclusiveOrExpression => [ exclusiveOrExpression '^' @ ] andExpression

** State #340: equalityExpression => [ equalityExpression @ ( '==' | '!=' ) ] relationalExpression
    --> __________________
    --> #357: equalityExpression => [ equalityExpression ( '==' | '!=' @ ) ] relationalExpression
    -->     Type: move
    -->     LA: '!='
    --> __________________
    --> #358: equalityExpression => [ equalityExpression ( '==' @ | '!=' ) ] relationalExpression
    -->     Type: move
    -->     LA: '=='

** State #341: relationalExpression => [ relationalExpression ( '<' | '>' | '<=' | '>=' @ ) ] shiftExpression
    --> __________________
    --> #359: shiftExpression => [ @ shiftExpression ( '<<' | '>>' ) ] additiveExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #342: relationalExpression => [ relationalExpression ( '<' @ | '>' | '<=' | '>=' ) ] shiftExpression
    --> __________________
    --> #359: shiftExpression => [ @ shiftExpression ( '<<' | '>>' ) ] additiveExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #343: relationalExpression => [ relationalExpression ( '<' | '>' @ | '<=' | '>=' ) ] shiftExpression
    --> __________________
    --> #359: shiftExpression => [ @ shiftExpression ( '<<' | '>>' ) ] additiveExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #344: relationalExpression => [ relationalExpression ( '<' | '>' | '<=' @ | '>=' ) ] shiftExpression
    --> __________________
    --> #359: shiftExpression => [ @ shiftExpression ( '<<' | '>>' ) ] additiveExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #345: additiveExpression => [ @ additiveExpression ( '+' | '-' ) ] multiplicativeExpression
    --> __________________
    --> #313: multiplicativeExpression => @ ( castExpression | multiplicativeExpression ( '*' castExpression | '/' castE
xpression | '%' castExpression ) )
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** [FINAL] State #346: statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement |
iterationStatement | jumpStatement @ )
    --> __________________
    --> #234: blockItem => ( statement @ | declaration )
    -->     Type: reduce
    -->     Reduce: blockItem => @ ( statement | declaration )
    --> __________________
    --> #235: iterationStatement => ( while '(' expression ')' statement | do statement @ while '(' expression ')' ';' |
 for '(' forCondition ')' statement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while '(' expression ')' statement | do @ statement while '(' expression ')'
 ';' | for '(' forCondition ')' statement )
    --> __________________
    --> #236: iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' ';' | f
or '(' forCondition ')' statement @ )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' '
;' | for '(' forCondition ')' @ statement )
    --> __________________
    --> #237: iterationStatement => ( while '(' expression ')' statement @ | do statement while '(' expression ')' ';' |
 for '(' forCondition ')' statement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while '(' expression ')' @ statement | do statement while '(' expression ')'
 ';' | for '(' forCondition ')' statement )
    --> __________________
    --> #238: labeledStatement => ( #identifier# | case constantExpression | default ) '=' statement @
    -->     Type: reduce
    -->     Reduce: labeledStatement => ( #identifier# | case constantExpression | default ) '=' @ statement
    --> __________________
    --> #239: selectionStatement => ( if '(' expression ')' statement [ else statement ] | switch '(' expression ')' sta
tement @ )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if '(' expression ')' statement [ else statement ] | switch '(' expression '
)' @ statement )
    --> __________________
    --> #240: selectionStatement => ( if '(' expression ')' statement @ [ else statement ] | switch '(' expression ')' s
tatement )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if '(' expression ')' @ statement [ else statement ] | switch '(' expression
 ')' statement )
    --> __________________
    --> #241: selectionStatement => ( if '(' expression ')' statement [ else statement @ ] | switch '(' expression ')' s
tatement )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if '(' expression ')' statement [ else @ statement ] | switch '(' expression
 ')' statement )

** [FINAL] State #347: jumpStatement => ( goto #identifier# ';' @ | continue ';' | break ';' | return [ expression ] ';'
 )
    --> __________________
    --> #346: statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iteration
Statement | jumpStatement @ )
    -->     Type: reduce
    -->     Reduce: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | i
terationStatement | jumpStatement )

** State #348: forCondition => @ ( forDeclaration | [ expression ] ) ';' [ forExpression ] ';' [ forExpression ]
    --> __________________
    --> #182: forCondition => ( forDeclaration | [ expression ] ) ';' @ [ forExpression ] ';' [ forExpression ]
    -->     Type: move
    -->     LA: ';'
    --> __________________
    --> #360: forDeclaration => @ declarationSpecifiers [ initDeclaratorList ]
    -->     Type: shift
    -->     LA: union struct enum int bool
    -->     LA: char long float unsigned double
    -->     LA: void short const volatile #identifier#
    -->     LA: signed auto static extern typedef
    -->     LA: register
    --> __________________
    --> #270: expression => [ @ expression ',' ] assignmentExpression
    -->     Type: shift
    -->     LA: #double# '&' #identifier# #uint# '*'
    -->     LA: #long# #uchar# '+' #short# '~'
    -->     LA: '(' #ushort# '-' #int# '++'
    -->     LA: '--' '!' sizeof #string# #char#
    -->     LA: #ulong# #float#

** [FINAL] State #349: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumen
tExpressionList ] ')' @ | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [
',' ] '}' )
    --> __________________
    --> #305: postfixExpression => ( primaryExpression | postfixExpression @ ( '[' expression ']' | '(' [ argumentExpres
sionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}'
 )
    -->     Type: recursion
    -->     LA: '++' '->' '[' '--' '('
    -->     LA: '.'
    --> __________________
    --> #306: unaryExpression => ( postfixExpression @ | ( '++' | '--' ) unaryExpression | unaryOperator castExpression
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => @ ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpre
ssion | sizeof ( unaryExpression | '(' typeName ')' ) )

** State #350: argumentExpressionList => [ @ argumentExpressionList ',' ] assignmentExpression
    --> __________________
    --> #108: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExpressio
n )
    -->     Type: shift
    -->     LA: #float# #ulong# #long# #int# #char#
    -->     LA: #identifier# #string# sizeof '!' '--'
    -->     LA: '++' '-' #ushort# '(' #short#
    -->     LA: '~' '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** [FINAL] State #351: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumen
tExpressionList ] ')' | '.' #identifier# @ | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [
',' ] '}' )
    --> __________________
    --> #305: postfixExpression => ( primaryExpression | postfixExpression @ ( '[' expression ']' | '(' [ argumentExpres
sionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}'
 )
    -->     Type: recursion
    -->     LA: '++' '->' '[' '--' '('
    -->     LA: '.'
    --> __________________
    --> #306: unaryExpression => ( postfixExpression @ | ( '++' | '--' ) unaryExpression | unaryOperator castExpression
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => @ ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpre
ssion | sizeof ( unaryExpression | '(' typeName ')' ) )

** [FINAL] State #352: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumen
tExpressionList ] ')' | '.' #identifier# | '->' #identifier# @ | '++' | '--' ) | '(' typeName ')' '{' initializerList [
',' ] '}' )
    --> __________________
    --> #305: postfixExpression => ( primaryExpression | postfixExpression @ ( '[' expression ']' | '(' [ argumentExpres
sionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}'
 )
    -->     Type: recursion
    -->     LA: '++' '->' '[' '--' '('
    -->     LA: '.'
    --> __________________
    --> #306: unaryExpression => ( postfixExpression @ | ( '++' | '--' ) unaryExpression | unaryOperator castExpression
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => @ ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpre
ssion | sizeof ( unaryExpression | '(' typeName ')' ) )

** State #353: relationalExpression => [ @ relationalExpression ( '<' | '>' | '<=' | '>=' ) ] shiftExpression
    --> __________________
    --> #359: shiftExpression => [ @ shiftExpression ( '<<' | '>>' ) ] additiveExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** [FINAL] State #354: designatorList => [ designatorList ] designator @
    --> __________________
    --> #361: designation => designatorList @ '='
    -->     Type: reduce
    -->     Reduce: designation => @ designatorList '='
    --> __________________
    --> #362: designatorList => [ designatorList @ ] designator
    -->     Type: recursion
    -->     LA: '[' '.'

** State #355: andExpression => [ andExpression @ '&' ] equalityExpression
    --> __________________
    --> #363: andExpression => [ andExpression '&' @ ] equalityExpression
    -->     Type: move
    -->     LA: '&'

** [FINAL] State #356: exclusiveOrExpression => [ exclusiveOrExpression '^' ] andExpression @
    --> __________________
    --> #364: exclusiveOrExpression => [ exclusiveOrExpression @ '^' ] andExpression
    -->     Type: recursion
    -->     LA: '^'
    --> __________________
    --> #365: inclusiveOrExpression => [ inclusiveOrExpression '|' ] exclusiveOrExpression @
    -->     Type: reduce
    -->     Reduce: inclusiveOrExpression => [ @ inclusiveOrExpression '|' ] exclusiveOrExpression
    --> __________________
    --> #365: inclusiveOrExpression => [ inclusiveOrExpression '|' ] exclusiveOrExpression @
    -->     Type: reduce
    -->     Reduce: inclusiveOrExpression => [ inclusiveOrExpression '|' @ ] exclusiveOrExpression

** State #357: equalityExpression => [ equalityExpression ( '==' | '!=' @ ) ] relationalExpression
    --> __________________
    --> #353: relationalExpression => [ @ relationalExpression ( '<' | '>' | '<=' | '>=' ) ] shiftExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #358: equalityExpression => [ equalityExpression ( '==' @ | '!=' ) ] relationalExpression
    --> __________________
    --> #353: relationalExpression => [ @ relationalExpression ( '<' | '>' | '<=' | '>=' ) ] shiftExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #359: shiftExpression => [ @ shiftExpression ( '<<' | '>>' ) ] additiveExpression
    --> __________________
    --> #345: additiveExpression => [ @ additiveExpression ( '+' | '-' ) ] multiplicativeExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #360: forDeclaration => @ declarationSpecifiers [ initDeclaratorList ]
    --> __________________
    --> #7: declarationSpecifiers => @ declarationSpecifier [ declarationSpecifiers ]
    -->     Type: shift
    -->     LA: union struct enum int bool
    -->     LA: char long float unsigned double
    -->     LA: void short const volatile #identifier#
    -->     LA: signed auto static extern typedef
    -->     LA: register

** State #361: designation => designatorList @ '='
    --> __________________
    --> #366: designation => designatorList '=' @
    -->     Type: move
    -->     LA: '='

** State #362: designatorList => [ designatorList @ ] designator
    --> __________________
    --> #286: designator => @ ( '[' constantExpression ']' | '.' #identifier# )
    -->     Type: shift
    -->     LA: '[' '.'

** State #363: andExpression => [ andExpression '&' @ ] equalityExpression
    --> __________________
    --> #334: equalityExpression => [ @ equalityExpression ( '==' | '!=' ) ] relationalExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #364: exclusiveOrExpression => [ exclusiveOrExpression @ '^' ] andExpression
    --> __________________
    --> #367: exclusiveOrExpression => [ exclusiveOrExpression '^' @ ] andExpression
    -->     Type: move
    -->     LA: '^'

** [FINAL] State #365: inclusiveOrExpression => [ inclusiveOrExpression '|' ] exclusiveOrExpression @
    --> __________________
    --> #368: inclusiveOrExpression => [ inclusiveOrExpression @ '|' ] exclusiveOrExpression
    -->     Type: recursion
    -->     LA: '|'
    --> __________________
    --> #369: logicalAndExpression => [ logicalAndExpression '&&' ] inclusiveOrExpression @
    -->     Type: reduce
    -->     Reduce: logicalAndExpression => [ @ logicalAndExpression '&&' ] inclusiveOrExpression
    --> __________________
    --> #369: logicalAndExpression => [ logicalAndExpression '&&' ] inclusiveOrExpression @
    -->     Type: reduce
    -->     Reduce: logicalAndExpression => [ logicalAndExpression '&&' @ ] inclusiveOrExpression

** [FINAL] State #366: designation => designatorList '=' @
    --> __________________
    --> #370: initializerList => [ initializerList ',' ] [ designation @ ] initializer
    -->     Type: reduce
    -->     Reduce: initializerList => [ @ initializerList ',' ] [ designation ] initializer
    --> __________________
    --> #370: initializerList => [ initializerList ',' ] [ designation @ ] initializer
    -->     Type: reduce
    -->     Reduce: initializerList => [ initializerList ',' @ ] [ designation ] initializer

** State #367: exclusiveOrExpression => [ exclusiveOrExpression '^' @ ] andExpression
    --> __________________
    --> #308: andExpression => [ @ andExpression '&' ] equalityExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #368: inclusiveOrExpression => [ inclusiveOrExpression @ '|' ] exclusiveOrExpression
    --> __________________
    --> #371: inclusiveOrExpression => [ inclusiveOrExpression '|' @ ] exclusiveOrExpression
    -->     Type: move
    -->     LA: '|'

** [FINAL] State #369: logicalAndExpression => [ logicalAndExpression '&&' ] inclusiveOrExpression @
    --> __________________
    --> #372: logicalAndExpression => [ logicalAndExpression @ '&&' ] inclusiveOrExpression
    -->     Type: recursion
    -->     LA: '&&'
    --> __________________
    --> #373: logicalOrExpression => [ logicalOrExpression '||' ] logicalAndExpression @
    -->     Type: reduce
    -->     Reduce: logicalOrExpression => [ @ logicalOrExpression '||' ] logicalAndExpression
    --> __________________
    --> #373: logicalOrExpression => [ logicalOrExpression '||' ] logicalAndExpression @
    -->     Type: reduce
    -->     Reduce: logicalOrExpression => [ logicalOrExpression '||' @ ] logicalAndExpression

** State #370: initializerList => [ initializerList ',' ] [ designation @ ] initializer
    --> __________________
    --> #133: initializer => @ ( assignmentExpression | '{' initializerList [ ',' ] '}' )
    -->     Type: shift
    -->     LA: '{' #string# #float# '~' #ulong#
    -->     LA: #long# #int# '!' #char# sizeof
    -->     LA: #identifier# '--' '++' '-' #ushort#
    -->     LA: '(' #double# #short# '+' #uchar#
    -->     LA: '*' #uint# '&'

** State #371: inclusiveOrExpression => [ inclusiveOrExpression '|' @ ] exclusiveOrExpression
    --> __________________
    --> #282: exclusiveOrExpression => [ @ exclusiveOrExpression '^' ] andExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #372: logicalAndExpression => [ logicalAndExpression @ '&&' ] inclusiveOrExpression
    --> __________________
    --> #374: logicalAndExpression => [ logicalAndExpression '&&' @ ] inclusiveOrExpression
    -->     Type: move
    -->     LA: '&&'

** [FINAL] State #373: logicalOrExpression => [ logicalOrExpression '||' ] logicalAndExpression @
    --> __________________
    --> #375: conditionalExpression => logicalOrExpression @ [ '?' expression '=' conditionalExpression ]
    -->     Type: reduce
    -->     Reduce: conditionalExpression => @ logicalOrExpression [ '?' expression '=' conditionalExpression ]
    --> __________________
    --> #376: logicalOrExpression => [ logicalOrExpression @ '||' ] logicalAndExpression
    -->     Type: recursion
    -->     LA: '||'

** State #374: logicalAndExpression => [ logicalAndExpression '&&' @ ] inclusiveOrExpression
    --> __________________
    --> #248: inclusiveOrExpression => [ @ inclusiveOrExpression '|' ] exclusiveOrExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** [FINAL] State #375: conditionalExpression => logicalOrExpression @ [ '?' expression '=' conditionalExpression ]
    --> __________________
    --> #377: conditionalExpression => logicalOrExpression [ '?' @ expression '=' conditionalExpression ]
    -->     Type: move
    -->     LA: '?'
    --> __________________
    --> #378: assignmentExpression => ( conditionalExpression @ | unaryExpression assignmentOperator assignmentExpressio
n )
    -->     Type: reduce
    -->     Reduce: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExp
ression )
    --> __________________
    --> #379: conditionalExpression => logicalOrExpression [ '?' expression '=' conditionalExpression @ ]
    -->     Type: reduce
    -->     Reduce: conditionalExpression => logicalOrExpression [ '?' expression '=' @ conditionalExpression ]
    --> __________________
    --> #380: constantExpression => conditionalExpression @
    -->     Type: reduce
    -->     Reduce: constantExpression => @ conditionalExpression

** State #376: logicalOrExpression => [ logicalOrExpression @ '||' ] logicalAndExpression
    --> __________________
    --> #381: logicalOrExpression => [ logicalOrExpression '||' @ ] logicalAndExpression
    -->     Type: move
    -->     LA: '||'

** State #377: conditionalExpression => logicalOrExpression [ '?' @ expression '=' conditionalExpression ]
    --> __________________
    --> #270: expression => [ @ expression ',' ] assignmentExpression
    -->     Type: shift
    -->     LA: #double# '&' #identifier# #uint# '*'
    -->     LA: #long# #uchar# '+' #short# '~'
    -->     LA: '(' #ushort# '-' #int# '++'
    -->     LA: '--' '!' sizeof #string# #char#
    -->     LA: #ulong# #float#

** [FINAL] State #378: assignmentExpression => ( conditionalExpression @ | unaryExpression assignmentOperator assignment
Expression )
    --> __________________
    --> #382: argumentExpressionList => [ argumentExpressionList ',' ] assignmentExpression @
    -->     Type: reduce
    -->     Reduce: argumentExpressionList => [ @ argumentExpressionList ',' ] assignmentExpression
    --> __________________
    --> #382: argumentExpressionList => [ argumentExpressionList ',' ] assignmentExpression @
    -->     Type: reduce
    -->     Reduce: argumentExpressionList => [ argumentExpressionList ',' @ ] assignmentExpression
    --> __________________
    --> #383: assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator assignmentExpression
@ )
    -->     Type: reduce
    -->     Reduce: assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator @ assignmentExp
ression )
    --> __________________
    --> #384: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQual
ifierList ] [ assignmentExpression @ ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: reduce
    -->     Reduce: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' @ ( [
typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #384: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQual
ifierList ] [ assignmentExpression @ ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: reduce
    -->     Reduce: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ ty
peQualifierList @ ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #385: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList ] ( a
ssignmentExpression @ | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    -->     Type: reduce
    -->     Reduce: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' @ [ typeQualifierLi
st ] ( assignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    --> __________________
    --> #385: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList ] ( a
ssignmentExpression @ | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    -->     Type: reduce
    -->     Reduce: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList
 @ ] ( assignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    --> __________________
    --> #386: expression => [ expression ',' ] assignmentExpression @
    -->     Type: reduce
    -->     Reduce: expression => [ @ expression ',' ] assignmentExpression
    --> __________________
    --> #386: expression => [ expression ',' ] assignmentExpression @
    -->     Type: reduce
    -->     Reduce: expression => [ expression ',' @ ] assignmentExpression
    --> __________________
    --> #387: forExpression => [ forExpression ',' ] assignmentExpression @
    -->     Type: reduce
    -->     Reduce: forExpression => [ @ forExpression ',' ] assignmentExpression
    --> __________________
    --> #387: forExpression => [ forExpression ',' ] assignmentExpression @
    -->     Type: reduce
    -->     Reduce: forExpression => [ forExpression ',' @ ] assignmentExpression
    --> __________________
    --> #388: initializer => ( assignmentExpression @ | '{' initializerList [ ',' ] '}' )
    -->     Type: reduce
    -->     Reduce: initializer => @ ( assignmentExpression | '{' initializerList [ ',' ] '}' )

** [FINAL] State #379: conditionalExpression => logicalOrExpression [ '?' expression '=' conditionalExpression @ ]
    --> __________________
    --> #378: assignmentExpression => ( conditionalExpression @ | unaryExpression assignmentOperator assignmentExpressio
n )
    -->     Type: reduce
    -->     Reduce: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExp
ression )
    --> __________________
    --> #379: conditionalExpression => logicalOrExpression [ '?' expression '=' conditionalExpression @ ]
    -->     Type: reduce
    -->     Reduce: conditionalExpression => logicalOrExpression [ '?' expression '=' @ conditionalExpression ]
    --> __________________
    --> #380: constantExpression => conditionalExpression @
    -->     Type: reduce
    -->     Reduce: constantExpression => @ conditionalExpression

** [FINAL] State #380: constantExpression => conditionalExpression @
    --> __________________
    --> #389: designator => ( '[' constantExpression @ ']' | '.' #identifier# )
    -->     Type: reduce
    -->     Reduce: designator => ( '[' @ constantExpression ']' | '.' #identifier# )
    --> __________________
    --> #390: enumerator => enumerationConstant [ '=' constantExpression @ ]
    -->     Type: reduce
    -->     Reduce: enumerator => enumerationConstant [ '=' @ constantExpression ]
    --> __________________
    --> #391: labeledStatement => ( #identifier# | case constantExpression @ | default ) '=' statement
    -->     Type: reduce
    -->     Reduce: labeledStatement => ( #identifier# | case @ constantExpression | default ) '=' statement
    --> __________________
    --> #392: structDeclarator => ( declarator | [ declarator ] '=' constantExpression @ )
    -->     Type: reduce
    -->     Reduce: structDeclarator => ( declarator | [ declarator ] '=' @ constantExpression )

** State #381: logicalOrExpression => [ logicalOrExpression '||' @ ] logicalAndExpression
    --> __________________
    --> #212: logicalAndExpression => [ @ logicalAndExpression '&&' ] inclusiveOrExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** [FINAL] State #382: argumentExpressionList => [ argumentExpressionList ',' ] assignmentExpression @
    --> __________________
    --> #393: argumentExpressionList => [ argumentExpressionList @ ',' ] assignmentExpression
    -->     Type: recursion
    -->     LA: ','
    --> __________________
    --> #394: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpressi
onList @ ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}'
 )
    -->     Type: reduce
    -->     Reduce: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' @ [ argument
ExpressionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ','
 ] '}' )

** [FINAL] State #383: assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator assignmentEx
pression @ )
    --> __________________
    --> #382: argumentExpressionList => [ argumentExpressionList ',' ] assignmentExpression @
    -->     Type: reduce
    -->     Reduce: argumentExpressionList => [ @ argumentExpressionList ',' ] assignmentExpression
    --> __________________
    --> #382: argumentExpressionList => [ argumentExpressionList ',' ] assignmentExpression @
    -->     Type: reduce
    -->     Reduce: argumentExpressionList => [ argumentExpressionList ',' @ ] assignmentExpression
    --> __________________
    --> #383: assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator assignmentExpression
@ )
    -->     Type: reduce
    -->     Reduce: assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator @ assignmentExp
ression )
    --> __________________
    --> #384: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQual
ifierList ] [ assignmentExpression @ ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: reduce
    -->     Reduce: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' @ ( [
typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #384: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQual
ifierList ] [ assignmentExpression @ ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: reduce
    -->     Reduce: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ ty
peQualifierList @ ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #385: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList ] ( a
ssignmentExpression @ | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    -->     Type: reduce
    -->     Reduce: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' @ [ typeQualifierLi
st ] ( assignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    --> __________________
    --> #385: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList ] ( a
ssignmentExpression @ | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    -->     Type: reduce
    -->     Reduce: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList
 @ ] ( assignmentExpression | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    --> __________________
    --> #386: expression => [ expression ',' ] assignmentExpression @
    -->     Type: reduce
    -->     Reduce: expression => [ @ expression ',' ] assignmentExpression
    --> __________________
    --> #386: expression => [ expression ',' ] assignmentExpression @
    -->     Type: reduce
    -->     Reduce: expression => [ expression ',' @ ] assignmentExpression
    --> __________________
    --> #387: forExpression => [ forExpression ',' ] assignmentExpression @
    -->     Type: reduce
    -->     Reduce: forExpression => [ @ forExpression ',' ] assignmentExpression
    --> __________________
    --> #387: forExpression => [ forExpression ',' ] assignmentExpression @
    -->     Type: reduce
    -->     Reduce: forExpression => [ forExpression ',' @ ] assignmentExpression
    --> __________________
    --> #388: initializer => ( assignmentExpression @ | '{' initializerList [ ',' ] '}' )
    -->     Type: reduce
    -->     Reduce: initializer => @ ( assignmentExpression | '{' initializerList [ ',' ] '}' )

** State #384: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQua
lifierList ] [ assignmentExpression @ ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #119: directAbstractDeclarator => ( '(' abstractDeclarator ')' | [ directAbstractDeclarator ] ( '[' ( [ typeQual
ifierList ] [ assignmentExpression ] | '*' ) ']' @ | '(' [ parameterTypeList ] ')' ) )
    -->     Type: move
    -->     LA: ']'

** State #385: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList ] (
assignmentExpression @ | '*' ) ']' | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    --> __________________
    --> #142: directDeclarator => ( #identifier# | '(' declarator ')' | directDeclarator ( '[' [ typeQualifierList ] ( a
ssignmentExpression | '*' ) ']' @ | '(' ( parameterTypeList | [ identifierList ] ) ')' ) )
    -->     Type: move
    -->     LA: ']'

** [FINAL] State #386: expression => [ expression ',' ] assignmentExpression @
    --> __________________
    --> #395: conditionalExpression => logicalOrExpression [ '?' expression @ '=' conditionalExpression ]
    -->     Type: reduce
    -->     Reduce: conditionalExpression => logicalOrExpression [ '?' @ expression '=' conditionalExpression ]
    --> __________________
    --> #396: expression => [ expression @ ',' ] assignmentExpression
    -->     Type: recursion
    -->     LA: ','
    --> __________________
    --> #397: expressionStatement => [ expression @ ] ';'
    -->     Type: reduce
    -->     Reduce: expressionStatement => [ @ expression ] ';'
    --> __________________
    --> #398: forCondition => ( forDeclaration | [ expression @ ] ) ';' [ forExpression ] ';' [ forExpression ]
    -->     Type: reduce
    -->     Reduce: forCondition => @ ( forDeclaration | [ expression ] ) ';' [ forExpression ] ';' [ forExpression ]
    --> __________________
    --> #399: iterationStatement => ( while '(' expression @ ')' statement | do statement while '(' expression ')' ';' |
 for '(' forCondition ')' statement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while '(' @ expression ')' statement | do statement while '(' expression ')'
 ';' | for '(' forCondition ')' statement )
    --> __________________
    --> #400: iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression @ ')' ';' |
 for '(' forCondition ')' statement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while '(' expression ')' statement | do statement while '(' @ expression ')'
 ';' | for '(' forCondition ')' statement )
    --> __________________
    --> #401: jumpStatement => ( goto #identifier# ';' | continue ';' | break ';' | return [ expression @ ] ';' )
    -->     Type: reduce
    -->     Reduce: jumpStatement => ( goto #identifier# ';' | continue ';' | break ';' | return @ [ expression ] ';' )
    --> __________________
    --> #402: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression @ ']' | '(' [ argumentExpres
sionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}'
 )
    -->     Type: reduce
    -->     Reduce: postfixExpression => ( primaryExpression | postfixExpression ( '[' @ expression ']' | '(' [ argument
ExpressionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ','
 ] '}' )
    --> __________________
    --> #403: primaryExpression => ( #identifier# | constant | #string# | '(' expression @ ')' )
    -->     Type: reduce
    -->     Reduce: primaryExpression => ( #identifier# | constant | #string# | '(' @ expression ')' )
    --> __________________
    --> #404: selectionStatement => ( if '(' expression ')' statement [ else statement ] | switch '(' expression @ ')' s
tatement )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if '(' expression ')' statement [ else statement ] | switch '(' @ expression
 ')' statement )
    --> __________________
    --> #405: selectionStatement => ( if '(' expression @ ')' statement [ else statement ] | switch '(' expression ')' s
tatement )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if '(' @ expression ')' statement [ else statement ] | switch '(' expression
 ')' statement )

** [FINAL] State #387: forExpression => [ forExpression ',' ] assignmentExpression @
    --> __________________
    --> #406: forCondition => ( forDeclaration | [ expression ] ) ';' [ forExpression @ ] ';' [ forExpression ]
    -->     Type: reduce
    -->     Reduce: forCondition => ( forDeclaration | [ expression ] ) ';' @ [ forExpression ] ';' [ forExpression ]
    --> __________________
    --> #407: forCondition => ( forDeclaration | [ expression ] ) ';' [ forExpression ] ';' [ forExpression @ ]
    -->     Type: reduce
    -->     Reduce: forCondition => ( forDeclaration | [ expression ] ) ';' [ forExpression ] ';' @ [ forExpression ]
    --> __________________
    --> #408: forExpression => [ forExpression @ ',' ] assignmentExpression
    -->     Type: recursion
    -->     LA: ','

** [FINAL] State #388: initializer => ( assignmentExpression @ | '{' initializerList [ ',' ] '}' )
    --> __________________
    --> #409: initDeclarator => declarator [ '=' initializer @ ]
    -->     Type: reduce
    -->     Reduce: initDeclarator => declarator [ '=' @ initializer ]
    --> __________________
    --> #410: initializerList => [ initializerList ',' ] [ designation ] initializer @
    -->     Type: reduce
    -->     Reduce: initializerList => [ @ initializerList ',' ] [ designation ] initializer
    --> __________________
    --> #410: initializerList => [ initializerList ',' ] [ designation ] initializer @
    -->     Type: reduce
    -->     Reduce: initializerList => [ initializerList ',' ] [ designation @ ] initializer
    --> __________________
    --> #410: initializerList => [ initializerList ',' ] [ designation ] initializer @
    -->     Type: reduce
    -->     Reduce: initializerList => [ initializerList ',' @ ] [ designation ] initializer

** State #389: designator => ( '[' constantExpression @ ']' | '.' #identifier# )
    --> __________________
    --> #411: designator => ( '[' constantExpression ']' @ | '.' #identifier# )
    -->     Type: move
    -->     LA: ']'

** [FINAL] State #390: enumerator => enumerationConstant [ '=' constantExpression @ ]
    --> __________________
    --> #285: enumeratorList => [ enumeratorList ',' ] enumerator @
    -->     Type: reduce
    -->     Reduce: enumeratorList => [ @ enumeratorList ',' ] enumerator
    --> __________________
    --> #285: enumeratorList => [ enumeratorList ',' ] enumerator @
    -->     Type: reduce
    -->     Reduce: enumeratorList => [ enumeratorList ',' @ ] enumerator

** State #391: labeledStatement => ( #identifier# | case constantExpression @ | default ) '=' statement
    --> __________________
    --> #322: labeledStatement => ( #identifier# | case constantExpression | default ) '=' @ statement
    -->     Type: move
    -->     LA: '='

** [FINAL] State #392: structDeclarator => ( declarator | [ declarator ] '=' constantExpression @ )
    --> __________________
    --> #102: structDeclaratorList => [ structDeclaratorList ',' ] structDeclarator @
    -->     Type: reduce
    -->     Reduce: structDeclaratorList => [ @ structDeclaratorList ',' ] structDeclarator
    --> __________________
    --> #102: structDeclaratorList => [ structDeclaratorList ',' ] structDeclarator @
    -->     Type: reduce
    -->     Reduce: structDeclaratorList => [ structDeclaratorList ',' @ ] structDeclarator

** State #393: argumentExpressionList => [ argumentExpressionList @ ',' ] assignmentExpression
    --> __________________
    --> #412: argumentExpressionList => [ argumentExpressionList ',' @ ] assignmentExpression
    -->     Type: move
    -->     LA: ','

** State #394: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpress
ionList @ ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}
' )
    --> __________________
    --> #349: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpressi
onList ] ')' @ | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}'
 )
    -->     Type: move
    -->     LA: ')'

** State #395: conditionalExpression => logicalOrExpression [ '?' expression @ '=' conditionalExpression ]
    --> __________________
    --> #413: conditionalExpression => logicalOrExpression [ '?' expression '=' @ conditionalExpression ]
    -->     Type: move
    -->     LA: '='

** State #396: expression => [ expression @ ',' ] assignmentExpression
    --> __________________
    --> #414: expression => [ expression ',' @ ] assignmentExpression
    -->     Type: move
    -->     LA: ','

** State #397: expressionStatement => [ expression @ ] ';'
    --> __________________
    --> #299: expressionStatement => [ expression ] ';' @
    -->     Type: move
    -->     LA: ';'

** State #398: forCondition => ( forDeclaration | [ expression @ ] ) ';' [ forExpression ] ';' [ forExpression ]
    --> __________________
    --> #182: forCondition => ( forDeclaration | [ expression ] ) ';' @ [ forExpression ] ';' [ forExpression ]
    -->     Type: move
    -->     LA: ';'

** State #399: iterationStatement => ( while '(' expression @ ')' statement | do statement while '(' expression ')' ';'
| for '(' forCondition ')' statement )
    --> __________________
    --> #415: iterationStatement => ( while '(' expression ')' @ statement | do statement while '(' expression ')' ';' |
 for '(' forCondition ')' statement )
    -->     Type: move
    -->     LA: ')'

** State #400: iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression @ ')' ';'
| for '(' forCondition ')' statement )
    --> __________________
    --> #416: iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' @ ';' |
 for '(' forCondition ')' statement )
    -->     Type: move
    -->     LA: ')'

** State #401: jumpStatement => ( goto #identifier# ';' | continue ';' | break ';' | return [ expression @ ] ';' )
    --> __________________
    --> #318: jumpStatement => ( goto #identifier# ';' | continue ';' | break ';' | return [ expression ] ';' @ )
    -->     Type: move
    -->     LA: ';'

** State #402: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression @ ']' | '(' [ argumentExpre
ssionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}
' )
    --> __________________
    --> #417: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' @ | '(' [ argumentExpres
sionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}'
 )
    -->     Type: move
    -->     LA: ']'

** State #403: primaryExpression => ( #identifier# | constant | #string# | '(' expression @ ')' )
    --> __________________
    --> #418: primaryExpression => ( #identifier# | constant | #string# | '(' expression ')' @ )
    -->     Type: move
    -->     LA: ')'

** State #404: selectionStatement => ( if '(' expression ')' statement [ else statement ] | switch '(' expression @ ')'
statement )
    --> __________________
    --> #419: selectionStatement => ( if '(' expression ')' statement [ else statement ] | switch '(' expression ')' @ s
tatement )
    -->     Type: move
    -->     LA: ')'

** State #405: selectionStatement => ( if '(' expression @ ')' statement [ else statement ] | switch '(' expression ')'
statement )
    --> __________________
    --> #420: selectionStatement => ( if '(' expression ')' @ statement [ else statement ] | switch '(' expression ')' s
tatement )
    -->     Type: move
    -->     LA: ')'

** State #406: forCondition => ( forDeclaration | [ expression ] ) ';' [ forExpression @ ] ';' [ forExpression ]
    --> __________________
    --> #216: forCondition => ( forDeclaration | [ expression ] ) ';' [ forExpression ] ';' @ [ forExpression ]
    -->     Type: move
    -->     LA: ';'

** [FINAL] State #407: forCondition => ( forDeclaration | [ expression ] ) ';' [ forExpression ] ';' [ forExpression @ ]

    --> __________________
    --> #251: iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' ';' | f
or '(' forCondition @ ')' statement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' '
;' | for '(' @ forCondition ')' statement )

** State #408: forExpression => [ forExpression @ ',' ] assignmentExpression
    --> __________________
    --> #421: forExpression => [ forExpression ',' @ ] assignmentExpression
    -->     Type: move
    -->     LA: ','

** [FINAL] State #409: initDeclarator => declarator [ '=' initializer @ ]
    --> __________________
    --> #101: initDeclaratorList => [ initDeclaratorList ',' ] initDeclarator @
    -->     Type: reduce
    -->     Reduce: initDeclaratorList => [ @ initDeclaratorList ',' ] initDeclarator
    --> __________________
    --> #101: initDeclaratorList => [ initDeclaratorList ',' ] initDeclarator @
    -->     Type: reduce
    -->     Reduce: initDeclaratorList => [ initDeclaratorList ',' @ ] initDeclarator

** [FINAL] State #410: initializerList => [ initializerList ',' ] [ designation ] initializer @
    --> __________________
    --> #422: initializer => ( assignmentExpression | '{' initializerList @ [ ',' ] '}' )
    -->     Type: reduce
    -->     Reduce: initializer => ( assignmentExpression | '{' @ initializerList [ ',' ] '}' )
    --> __________________
    --> #423: initializerList => [ initializerList @ ',' ] [ designation ] initializer
    -->     Type: recursion
    -->     LA: ','
    --> __________________
    --> #424: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpressi
onList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList @ [ ',' ] '}'
 )
    -->     Type: reduce
    -->     Reduce: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentEx
pressionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' @ initializerList [ ','
 ] '}' )

** [FINAL] State #411: designator => ( '[' constantExpression ']' @ | '.' #identifier# )
    --> __________________
    --> #354: designatorList => [ designatorList ] designator @
    -->     Type: reduce
    -->     Reduce: designatorList => [ @ designatorList ] designator
    --> __________________
    --> #354: designatorList => [ designatorList ] designator @
    -->     Type: reduce
    -->     Reduce: designatorList => [ designatorList @ ] designator

** State #412: argumentExpressionList => [ argumentExpressionList ',' @ ] assignmentExpression
    --> __________________
    --> #108: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExpressio
n )
    -->     Type: shift
    -->     LA: #float# #ulong# #long# #int# #char#
    -->     LA: #identifier# #string# sizeof '!' '--'
    -->     LA: '++' '-' #ushort# '(' #short#
    -->     LA: '~' '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #413: conditionalExpression => logicalOrExpression [ '?' expression '=' @ conditionalExpression ]
    --> __________________
    --> #144: conditionalExpression => @ logicalOrExpression [ '?' expression '=' conditionalExpression ]
    -->     Type: shift
    -->     LA: #double# '&' '*' #uint# '+'
    -->     LA: #uchar# #float# '~' #short# '('
    -->     LA: '-' #ushort# '++' '--' '!'
    -->     LA: #int# #char# sizeof #string# #identifier#
    -->     LA: #long# #ulong#

** State #414: expression => [ expression ',' @ ] assignmentExpression
    --> __________________
    --> #108: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExpressio
n )
    -->     Type: shift
    -->     LA: #float# #ulong# #long# #int# #char#
    -->     LA: #identifier# #string# sizeof '!' '--'
    -->     LA: '++' '-' #ushort# '(' #short#
    -->     LA: '~' '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #415: iterationStatement => ( while '(' expression ')' @ statement | do statement while '(' expression ')' ';'
| for '(' forCondition ')' statement )
    --> __________________
    --> #242: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterati
onStatement | jumpStatement )
    -->     Type: shift
    -->     LA: '{' switch return continue while
    -->     LA: '(' #identifier# default case ';'
    -->     LA: '*' #long# goto #float# for
    -->     LA: #ulong# #int# break '-' '!'
    -->     LA: do '&' #char# '~' sizeof
    -->     LA: #string# '--' '++' #ushort# if
    -->     LA: #double# #short# '+' #uchar# #uint#

** State #416: iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' @ ';'
| for '(' forCondition ')' statement )
    --> __________________
    --> #425: iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')' ';' @ |
 for '(' forCondition ')' statement )
    -->     Type: move
    -->     LA: ';'

** [FINAL] State #417: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' @ | '(' [ argum
entExpressionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [
',' ] '}' )
    --> __________________
    --> #305: postfixExpression => ( primaryExpression | postfixExpression @ ( '[' expression ']' | '(' [ argumentExpres
sionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}'
 )
    -->     Type: recursion
    -->     LA: '++' '->' '[' '--' '('
    -->     LA: '.'
    --> __________________
    --> #306: unaryExpression => ( postfixExpression @ | ( '++' | '--' ) unaryExpression | unaryOperator castExpression
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => @ ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpre
ssion | sizeof ( unaryExpression | '(' typeName ')' ) )

** [FINAL] State #418: primaryExpression => ( #identifier# | constant | #string# | '(' expression ')' @ )
    --> __________________
    --> #271: postfixExpression => ( primaryExpression @ | postfixExpression ( '[' expression ']' | '(' [ argumentExpres
sionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}'
 )
    -->     Type: reduce
    -->     Reduce: postfixExpression => @ ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argument
ExpressionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ','
 ] '}' )

** State #419: selectionStatement => ( if '(' expression ')' statement [ else statement ] | switch '(' expression ')' @
statement )
    --> __________________
    --> #242: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterati
onStatement | jumpStatement )
    -->     Type: shift
    -->     LA: '{' switch return continue while
    -->     LA: '(' #identifier# default case ';'
    -->     LA: '*' #long# goto #float# for
    -->     LA: #ulong# #int# break '-' '!'
    -->     LA: do '&' #char# '~' sizeof
    -->     LA: #string# '--' '++' #ushort# if
    -->     LA: #double# #short# '+' #uchar# #uint#

** State #420: selectionStatement => ( if '(' expression ')' @ statement [ else statement ] | switch '(' expression ')'
statement )
    --> __________________
    --> #242: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterati
onStatement | jumpStatement )
    -->     Type: shift
    -->     LA: '{' switch return continue while
    -->     LA: '(' #identifier# default case ';'
    -->     LA: '*' #long# goto #float# for
    -->     LA: #ulong# #int# break '-' '!'
    -->     LA: do '&' #char# '~' sizeof
    -->     LA: #string# '--' '++' #ushort# if
    -->     LA: #double# #short# '+' #uchar# #uint#

** State #421: forExpression => [ forExpression ',' @ ] assignmentExpression
    --> __________________
    --> #108: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExpressio
n )
    -->     Type: shift
    -->     LA: #float# #ulong# #long# #int# #char#
    -->     LA: #identifier# #string# sizeof '!' '--'
    -->     LA: '++' '-' #ushort# '(' #short#
    -->     LA: '~' '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #422: initializer => ( assignmentExpression | '{' initializerList @ [ ',' ] '}' )
    --> __________________
    --> #426: initializer => ( assignmentExpression | '{' initializerList [ ',' ] '}' @ )
    -->     Type: move
    -->     LA: '}'
    --> __________________
    --> #427: initializer => ( assignmentExpression | '{' initializerList [ ',' @ ] '}' )
    -->     Type: move
    -->     LA: ','

** State #423: initializerList => [ initializerList @ ',' ] [ designation ] initializer
    --> __________________
    --> #428: initializerList => [ initializerList ',' @ ] [ designation ] initializer
    -->     Type: move
    -->     LA: ','

** State #424: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpress
ionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList @ [ ',' ] '}
' )
    --> __________________
    --> #429: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpressi
onList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}' @
 )
    -->     Type: move
    -->     LA: '}'
    --> __________________
    --> #430: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpressi
onList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' @ ] '}'
 )
    -->     Type: move
    -->     LA: ','

** [FINAL] State #425: iterationStatement => ( while '(' expression ')' statement | do statement while '(' expression ')
' ';' @ | for '(' forCondition ')' statement )
    --> __________________
    --> #261: statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iteration
Statement @ | jumpStatement )
    -->     Type: reduce
    -->     Reduce: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | i
terationStatement | jumpStatement )

** [FINAL] State #426: initializer => ( assignmentExpression | '{' initializerList [ ',' ] '}' @ )
    --> __________________
    --> #409: initDeclarator => declarator [ '=' initializer @ ]
    -->     Type: reduce
    -->     Reduce: initDeclarator => declarator [ '=' @ initializer ]
    --> __________________
    --> #410: initializerList => [ initializerList ',' ] [ designation ] initializer @
    -->     Type: reduce
    -->     Reduce: initializerList => [ @ initializerList ',' ] [ designation ] initializer
    --> __________________
    --> #410: initializerList => [ initializerList ',' ] [ designation ] initializer @
    -->     Type: reduce
    -->     Reduce: initializerList => [ initializerList ',' ] [ designation @ ] initializer
    --> __________________
    --> #410: initializerList => [ initializerList ',' ] [ designation ] initializer @
    -->     Type: reduce
    -->     Reduce: initializerList => [ initializerList ',' @ ] [ designation ] initializer

** State #427: initializer => ( assignmentExpression | '{' initializerList [ ',' @ ] '}' )
    --> __________________
    --> #426: initializer => ( assignmentExpression | '{' initializerList [ ',' ] '}' @ )
    -->     Type: move
    -->     LA: '}'

** State #428: initializerList => [ initializerList ',' @ ] [ designation ] initializer
    --> __________________
    --> #133: initializer => @ ( assignmentExpression | '{' initializerList [ ',' ] '}' )
    -->     Type: shift
    -->     LA: '{' #string# #float# '~' #ulong#
    -->     LA: #long# #int# '!' #char# sizeof
    -->     LA: #identifier# '--' '++' '-' #ushort#
    -->     LA: '(' #double# #short# '+' #uchar#
    -->     LA: '*' #uint# '&'
    --> __________________
    --> #222: designation => @ designatorList '='
    -->     Type: shift
    -->     LA: '[' '.'

** [FINAL] State #429: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumen
tExpressionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',
' ] '}' @ )
    --> __________________
    --> #305: postfixExpression => ( primaryExpression | postfixExpression @ ( '[' expression ']' | '(' [ argumentExpres
sionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}'
 )
    -->     Type: recursion
    -->     LA: '++' '->' '[' '--' '('
    -->     LA: '.'
    --> __________________
    --> #306: unaryExpression => ( postfixExpression @ | ( '++' | '--' ) unaryExpression | unaryOperator castExpression
| sizeof ( unaryExpression | '(' typeName ')' ) )
    -->     Type: reduce
    -->     Reduce: unaryExpression => @ ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpre
ssion | sizeof ( unaryExpression | '(' typeName ')' ) )

** State #430: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpress
ionList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' @ ] '}
' )
    --> __________________
    --> #429: postfixExpression => ( primaryExpression | postfixExpression ( '[' expression ']' | '(' [ argumentExpressi
onList ] ')' | '.' #identifier# | '->' #identifier# | '++' | '--' ) | '(' typeName ')' '{' initializerList [ ',' ] '}' @
 )
    -->     Type: move
    -->     LA: '}'
