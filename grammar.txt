==== RULE ====
abstractDeclarator => ( pointer | [ pointer ] directAbstractDeclarator )
additiveExpression => [ additiveExpression ( '+' | '-' ) ] multiplicativeExpression
andExpression => [ andExpression '&' ] equalityExpression
argumentExpressionList => [ argumentExpressionList (',') ] assignmentExpression
assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator assignmentExpression )
assignmentOperator => ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' )
blockItem => ( statement | declaration )
blockItemList => [ blockItemList ] blockItem
castExpression => ( ('(') typeName (')') castExpression | unaryExpression )
compilationUnit => translationUnit [ compilationUnit ]
compoundStatement => ('{') [ blockItemList ] ('}')
conditionalExpression => logicalOrExpression [ '?' expression '=' conditionalExpression ]
constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #float# | #double# )
constantExpression => conditionalExpression
declaration => declarationSpecifiers [ initDeclaratorList ] (';')
declarationList => [ declarationList ] declaration
declarationSpecifier => ( storageClassSpecifier | typeSpecifier | typeQualifier )
declarationSpecifiers => [ declarationSpecifiers ] declarationSpecifier
declarationSpecifiers2 => [ declarationSpecifiers ] declarationSpecifier
declarator => [ pointer ] directDeclarator
designation => designatorList '='
designator => ( '[' constantExpression ']' | '.' #identifier# )
designatorList => [ designatorList ] designator
directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
enumSpecifier => (enum) ( [ #identifier# ] ('{') enumeratorList [ (',') ] ('{') | #identifier# )
enumerationConstant => #identifier#
enumerator => enumerationConstant [ ('=') constantExpression ]
enumeratorList => [ enumeratorList (',') ] enumerator
equalityExpression => [ equalityExpression ( '==' | '!=' ) ] relationalExpression
exclusiveOrExpression => [ exclusiveOrExpression '^' ] andExpression
expression => [ expression (',') ] assignmentExpression
expressionStatement => [ expression ] (';')
externalDeclaration => ( functionDefinition | declaration | (';') )
forCondition => ( forDeclaration | [ expression ] ) ';' [ forExpression ] ';' [ forExpression ]
forDeclaration => declarationSpecifiers [ initDeclaratorList ]
forExpression => [ forExpression (',') ] assignmentExpression
functionDefinition => [ declarationSpecifiers ] declarator [ declarationList ] compoundStatement
identifierList => [ identifierList (',') ] #identifier#
inclusiveOrExpression => [ inclusiveOrExpression '|' ] exclusiveOrExpression
initDeclarator => declarator [ ('=') initializer ]
initDeclaratorList => [ initDeclaratorList (',') ] initDeclarator
initializer => ( assignmentExpression | '{' initializerList [ (',') ] '}' )
initializerList => [ initializerList (',') ] [ designation ] initializer
iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
jumpStatement => ( goto #identifier# | continue | break | return [ expression ] ) (';')
labeledStatement => ( #identifier# | case constantExpression | default ) '=' statement
logicalAndExpression => [ logicalAndExpression '&&' ] inclusiveOrExpression
logicalOrExpression => [ logicalOrExpression '||' ] logicalAndExpression
multiplicativeExpression => [ multiplicativeExpression ( '*' | '/' | '%' ) ] castExpression
parameterDeclaration => ( declarationSpecifiers declarator | declarationSpecifiers2 [ abstractDeclarator ] )
parameterList => [ parameterList (',') ] parameterDeclaration
parameterTypeList => parameterList [ (',') '...' ]
pointer => [ typeQualifierList ] [ pointer ] ( '*' | '^' )
postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
primaryExpression => ( #identifier# | constant | #string# | ('(') expression (')') )
program => compilationUnit
relationalExpression => [ relationalExpression ( '<' | '>' | '<=' | '>=' ) ] shiftExpression
selectionStatement => ( if ('(') expression (')') statement [ else statement ] | switch ('(') expression (')') statement )
shiftExpression => [ shiftExpression ( '<<' | '>>' ) ] additiveExpression
specifierQualifierList => ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationStatement | jumpStatement )
storageClassSpecifier => ( typedef | extern | static | auto | register )
structDeclaration => specifierQualifierList [ structDeclaratorList ] (';')
structDeclarationList => [ structDeclarationList ] structDeclaration
structDeclarator => ( declarator | [ declarator ] ('=') constantExpression )
structDeclaratorList => [ structDeclaratorList (',') ] structDeclarator
structOrUnion => ( struct | union )
structOrUnionSpecifier => structOrUnion ( #identifier# | [ #identifier# ] ('{') structDeclarationList ('}') )
translationUnit => [ translationUnit ] externalDeclaration
typeName => specifierQualifierList [ abstractDeclarator ]
typeQualifier => ( const | volatile )
typeQualifierList => [ typeQualifierList ] typeQualifier
typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
typedefName => #identifier#
unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
unaryOperator => ( '&' | '*' | '+' | '-' | '~' | '!' )
==== NGA  ====
** Rule: abstractDeclarator => ( pointer | [ pointer ] directAbstractDeclarator )
-- Tokens: '[' '(' '*' '^' const volatile
-- First-set tokens: volatile const '^' '*' '(' '['
-- First-set rules: directAbstractDeclarator pointer
Status #0 - abstractDeclarator => @ ( pointer | [ pointer ] directAbstractDeclarator )
  To #1:  directAbstractDeclarator
  To #2:  pointer
  To #3:  pointer
Status #1 [FINAL] - abstractDeclarator => ( pointer | [ pointer ] directAbstractDeclarator @ )
Status #2 [FINAL] - abstractDeclarator => ( pointer @ | [ pointer ] directAbstractDeclarator )
Status #3 - abstractDeclarator => ( pointer | [ pointer @ ] directAbstractDeclarator )
  To #1:  directAbstractDeclarator

** Rule: additiveExpression => [ additiveExpression ( '+' | '-' ) ] multiplicativeExpression
-- Tokens: #double# '&' '*' #uint# '+' #uchar# #float# '~' #short# '(' '-' #ushort# '++' '--' '!' #int# #char# sizeof #string# #identifier# #long# #ulong#
-- First-set tokens: #double# #uint# #uchar# #float# '~' '+' #short# '(' #ushort# '++' '--' '!' '-' #int# #char# sizeof #string# '&' #identifier# '*' #long# #ulong#
-- First-set rules: multiplicativeExpression additiveExpression
Status #0 - additiveExpression => [ @ additiveExpression ( '+' | '-' ) ] multiplicativeExpression
  To #1:  additiveExpression
  To #2:  multiplicativeExpression
Status #1 - additiveExpression => [ additiveExpression @ ( '+' | '-' ) ] multiplicativeExpression
  To #3:  '-'
  To #4:  '+'
Status #2 [FINAL] - additiveExpression => [ additiveExpression ( '+' | '-' ) ] multiplicativeExpression @
Status #3 - additiveExpression => [ additiveExpression ( '+' | '-' @ ) ] multiplicativeExpression
  To #2:  multiplicativeExpression
Status #4 - additiveExpression => [ additiveExpression ( '+' @ | '-' ) ] multiplicativeExpression
  To #2:  multiplicativeExpression

** Rule: andExpression => [ andExpression '&' ] equalityExpression
-- Tokens: #double# '&' '*' #uint# '+' #uchar# #float# '~' #short# '(' '-' #ushort# '++' '--' '!' #int# #char# sizeof #string# #identifier# #long# #ulong#
-- First-set tokens: #double# #uint# #uchar# #float# '~' '+' #short# '(' #ushort# '++' '--' '!' '-' #int# #char# sizeof #string# '&' #identifier# '*' #long# #ulong#
-- First-set rules: equalityExpression andExpression
Status #0 - andExpression => [ @ andExpression '&' ] equalityExpression
  To #1:  andExpression
  To #2:  equalityExpression
Status #1 - andExpression => [ andExpression @ '&' ] equalityExpression
  To #3:  '&'
Status #2 [FINAL] - andExpression => [ andExpression '&' ] equalityExpression @
Status #3 - andExpression => [ andExpression '&' @ ] equalityExpression
  To #2:  equalityExpression

** Rule: argumentExpressionList => [ argumentExpressionList (',') ] assignmentExpression
-- Tokens: #float# #ulong# #long# #int# #char# #identifier# #string# sizeof '!' '--' '++' '-' #ushort# '(' #short# '~' '+' #uchar# '*' #uint# '&' #double#
-- First-set tokens: #float# #ulong# #char# #string# sizeof '!' '--' '++' #int# '-' #ushort# '(' '~' #short# '+' #uchar# #long# '*' #uint# #identifier# '&' #double#
-- First-set rules: assignmentExpression argumentExpressionList
Status #0 - argumentExpressionList => [ @ argumentExpressionList (',') ] assignmentExpression
  To #1:  argumentExpressionList
  To #2:  assignmentExpression
Status #1 - argumentExpressionList => [ argumentExpressionList @ (',') ] assignmentExpression
  To #3:  (',')
Status #2 [FINAL] - argumentExpressionList => [ argumentExpressionList (',') ] assignmentExpression @
Status #3 - argumentExpressionList => [ argumentExpressionList (',') @ ] assignmentExpression
  To #2:  assignmentExpression

** Rule: assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator assignmentExpression )
-- Tokens: #float# #ulong# #long# #int# #char# #identifier# #string# sizeof '!' '--' '++' '-' #ushort# '(' #short# '~' '+' #uchar# '*' #uint# '&' #double#
-- First-set tokens: #double# #uint# #uchar# '~' '+' #short# '(' #ushort# '++' '--' '!' sizeof #string# '&' #identifier# #char# '-' #int# '*' #long# #ulong# #float#
-- First-set rules: unaryExpression conditionalExpression
Status #0 - assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExpression )
  To #1:  unaryExpression
  To #2:  conditionalExpression
Status #1 - assignmentExpression => ( conditionalExpression | unaryExpression @ assignmentOperator assignmentExpression )
  To #3:  assignmentOperator
Status #2 [FINAL] - assignmentExpression => ( conditionalExpression @ | unaryExpression assignmentOperator assignmentExpression )
Status #3 - assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator @ assignmentExpression )
  To #4:  assignmentExpression
Status #4 [FINAL] - assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator assignmentExpression @ )

** Rule: assignmentOperator => ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' )
-- Tokens: '/=' '%=' '*=' '=' '<<=' '+=' '-=' '>>='
-- First-set tokens: '>>=' '-=' '+=' '<<=' '=' '*=' '%=' '/='
-- First-set rules:
Status #0 - assignmentOperator => @ ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' )
  To #1:  '>>='
  To #2:  '='
  To #3:  '*='
  To #4:  '/='
  To #5:  '%='
  To #6:  '+='
  To #7:  '-='
  To #8:  '<<='
Status #1 [FINAL] - assignmentOperator => ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' @ )
Status #2 [FINAL] - assignmentOperator => ( '=' @ | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' )
Status #3 [FINAL] - assignmentOperator => ( '=' | '*=' @ | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' )
Status #4 [FINAL] - assignmentOperator => ( '=' | '*=' | '/=' @ | '%=' | '+=' | '-=' | '<<=' | '>>=' )
Status #5 [FINAL] - assignmentOperator => ( '=' | '*=' | '/=' | '%=' @ | '+=' | '-=' | '<<=' | '>>=' )
Status #6 [FINAL] - assignmentOperator => ( '=' | '*=' | '/=' | '%=' | '+=' @ | '-=' | '<<=' | '>>=' )
Status #7 [FINAL] - assignmentOperator => ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' @ | '<<=' | '>>=' )
Status #8 [FINAL] - assignmentOperator => ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' @ | '>>=' )

** Rule: blockItem => ( statement | declaration )
-- Tokens: register typedef #long# extern static #short# auto signed #char# #identifier# volatile const '{' short void #double# double unsigned #float# float '--' long char bool int enum ';' struct #ushort# union #ulong# switch #int# return continue while #string# '(' case default '*' goto for break '~' '-' '!' do '&' sizeof #uchar# '++' if '+' #uint#
-- First-set tokens: #uint# '+' if '++' #uchar# sizeof '&' do '!' '-' '~' break for goto '*' default case '(' #string# while continue return #int# switch #ulong# union #ushort# struct ';' enum int bool char long '--' float #float# unsigned double #double# void short '{' const volatile #identifier# #char# signed auto #short# static extern #long# typedef register
-- First-set rules: declaration statement
Status #0 - blockItem => @ ( statement | declaration )
  To #1:  declaration
  To #2:  statement
Status #1 [FINAL] - blockItem => ( statement | declaration @ )
Status #2 [FINAL] - blockItem => ( statement @ | declaration )

** Rule: blockItemList => [ blockItemList ] blockItem
-- Tokens: register typedef #long# extern static #short# auto signed #char# #identifier# volatile const '{' short void #double# double unsigned #float# float '--' long char bool int enum ';' struct #ushort# union #ulong# switch #int# return continue while #string# '(' case default '*' goto for break '~' '-' '!' do '&' sizeof #uchar# '++' if '+' #uint#
-- First-set tokens: register typedef #long# extern static #short# auto signed #char# #identifier# volatile const '{' short void #double# double unsigned #float# float '--' long char bool int enum ';' struct #ushort# union #ulong# switch #int# return continue while #string# '(' case default '*' goto for break '~' '-' '!' do '&' sizeof #uchar# '++' if '+' #uint#
-- First-set rules: blockItem blockItemList
Status #0 - blockItemList => [ @ blockItemList ] blockItem
  To #1:  blockItemList
  To #2:  blockItem
Status #1 - blockItemList => [ blockItemList @ ] blockItem
  To #2:  blockItem
Status #2 [FINAL] - blockItemList => [ blockItemList ] blockItem @

** Rule: castExpression => ( ('(') typeName (')') castExpression | unaryExpression )
-- Tokens: #double# '&' '*' #uint# '+' #uchar# #float# '~' #short# '(' '-' #ushort# '++' '--' '!' #int# #char# sizeof #string# #identifier# #long# #ulong#
-- First-set tokens: #ulong# #long# #identifier# #string# #char# sizeof #int# '!' '--' '++' #ushort# '-' #short# #float# '~' #uchar# '+' #uint# '*' '&' #double# '('
-- First-set rules: unaryExpression
Status #0 - castExpression => @ ( ('(') typeName (')') castExpression | unaryExpression )
  To #1:  unaryExpression
  To #2:  ('(')
Status #1 [FINAL] - castExpression => ( ('(') typeName (')') castExpression | unaryExpression @ )
Status #2 - castExpression => ( ('(') @ typeName (')') castExpression | unaryExpression )
  To #3:  typeName
Status #3 - castExpression => ( ('(') typeName @ (')') castExpression | unaryExpression )
  To #4:  (')')
Status #4 - castExpression => ( ('(') typeName (')') @ castExpression | unaryExpression )
  To #5:  castExpression
Status #5 [FINAL] - castExpression => ( ('(') typeName (')') castExpression @ | unaryExpression )

** Rule: compilationUnit => translationUnit [ compilationUnit ]
-- Tokens: static typedef auto signed #identifier# const short void double unsigned float long int enum struct union bool volatile char '(' register '^' extern ';' '*'
-- First-set tokens: '*' ';' extern '^' register '(' char volatile bool union struct enum int long float unsigned double void short const #identifier# signed auto typedef static
-- First-set rules: translationUnit
Status #0 - compilationUnit => @ translationUnit [ compilationUnit ]
  To #1:  translationUnit
Status #1 [FINAL] - compilationUnit => translationUnit @ [ compilationUnit ]
  To #2:  compilationUnit
Status #2 [FINAL] - compilationUnit => translationUnit [ compilationUnit @ ]

** Rule: compoundStatement => ('{') [ blockItemList ] ('}')
-- Tokens: '{'
-- First-set tokens: '{'
-- First-set rules:
Status #0 - compoundStatement => @ ('{') [ blockItemList ] ('}')
  To #1:  ('{')
Status #1 - compoundStatement => ('{') @ [ blockItemList ] ('}')
  To #2:  ('}')
  To #3:  blockItemList
Status #2 [FINAL] - compoundStatement => ('{') [ blockItemList ] ('}') @
Status #3 - compoundStatement => ('{') [ blockItemList @ ] ('}')
  To #2:  ('}')

** Rule: conditionalExpression => logicalOrExpression [ '?' expression '=' conditionalExpression ]
-- Tokens: #double# '&' '*' #uint# '+' #uchar# #float# '~' #short# '(' '-' #ushort# '++' '--' '!' #int# #char# sizeof #string# #identifier# #long# #ulong#
-- First-set tokens: #ulong# #long# #identifier# #string# sizeof #char# #int# '!' '--' '++' #ushort# '-' '(' #short# '~' #float# #uchar# '+' #uint# '*' '&' #double#
-- First-set rules: logicalOrExpression
Status #0 - conditionalExpression => @ logicalOrExpression [ '?' expression '=' conditionalExpression ]
  To #1:  logicalOrExpression
Status #1 [FINAL] - conditionalExpression => logicalOrExpression @ [ '?' expression '=' conditionalExpression ]
  To #2:  '?'
Status #2 - conditionalExpression => logicalOrExpression [ '?' @ expression '=' conditionalExpression ]
  To #3:  expression
Status #3 - conditionalExpression => logicalOrExpression [ '?' expression @ '=' conditionalExpression ]
  To #4:  '='
Status #4 - conditionalExpression => logicalOrExpression [ '?' expression '=' @ conditionalExpression ]
  To #5:  conditionalExpression
Status #5 [FINAL] - conditionalExpression => logicalOrExpression [ '?' expression '=' conditionalExpression @ ]

** Rule: constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #float# | #double# )
-- Tokens: #ushort# #short# #uchar# #char# #int# #uint# #long# #ulong# #float# #double#
-- First-set tokens: #double# #float# #ulong# #long# #uint# #int# #char# #uchar# #short# #ushort#
-- First-set rules:
Status #0 - constant => @ ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #float# | #double# )
  To #1:  #double#
  To #2:  #char#
  To #3:  #uchar#
  To #4:  #short#
  To #5:  #ushort#
  To #6:  #int#
  To #7:  #uint#
  To #8:  #long#
  To #9:  #ulong#
  To #10:  #float#
Status #1 [FINAL] - constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #float# | #double# @ )
Status #2 [FINAL] - constant => ( #char# @ | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #float# | #double# )
Status #3 [FINAL] - constant => ( #char# | #uchar# @ | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #float# | #double# )
Status #4 [FINAL] - constant => ( #char# | #uchar# | #short# @ | #ushort# | #int# | #uint# | #long# | #ulong# | #float# | #double# )
Status #5 [FINAL] - constant => ( #char# | #uchar# | #short# | #ushort# @ | #int# | #uint# | #long# | #ulong# | #float# | #double# )
Status #6 [FINAL] - constant => ( #char# | #uchar# | #short# | #ushort# | #int# @ | #uint# | #long# | #ulong# | #float# | #double# )
Status #7 [FINAL] - constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# @ | #long# | #ulong# | #float# | #double# )
Status #8 [FINAL] - constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# @ | #ulong# | #float# | #double# )
Status #9 [FINAL] - constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# @ | #float# | #double# )
Status #10 [FINAL] - constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #float# @ | #double# )

** Rule: constantExpression => conditionalExpression
-- Tokens: #double# '&' '*' #uint# '+' #uchar# #float# '~' #short# '(' '-' #ushort# '++' '--' '!' #int# #char# sizeof #string# #identifier# #long# #ulong#
-- First-set tokens: #ulong# #long# #identifier# #string# sizeof #char# #int# '!' '--' '++' #ushort# '-' '(' #short# '~' #float# #uchar# '+' #uint# '*' '&' #double#
-- First-set rules: conditionalExpression
Status #0 - constantExpression => @ conditionalExpression
  To #1:  conditionalExpression
Status #1 [FINAL] - constantExpression => conditionalExpression @

** Rule: declaration => declarationSpecifiers [ initDeclaratorList ] (';')
-- Tokens: union struct enum int bool char long float unsigned double void short const volatile #identifier# signed auto static extern typedef register
-- First-set tokens: register typedef extern static auto signed #identifier# volatile const short void double unsigned float long char bool int enum struct union
-- First-set rules: declarationSpecifiers
Status #0 - declaration => @ declarationSpecifiers [ initDeclaratorList ] (';')
  To #1:  declarationSpecifiers
Status #1 - declaration => declarationSpecifiers @ [ initDeclaratorList ] (';')
  To #2:  (';')
  To #3:  initDeclaratorList
Status #2 [FINAL] - declaration => declarationSpecifiers [ initDeclaratorList ] (';') @
Status #3 - declaration => declarationSpecifiers [ initDeclaratorList @ ] (';')
  To #2:  (';')

** Rule: declarationList => [ declarationList ] declaration
-- Tokens: union struct enum int bool char long float unsigned double void short const volatile #identifier# signed auto static extern typedef register
-- First-set tokens: union struct enum int bool char long float unsigned double void short const volatile #identifier# signed auto static extern typedef register
-- First-set rules: declaration declarationList
Status #0 - declarationList => [ @ declarationList ] declaration
  To #1:  declarationList
  To #2:  declaration
Status #1 - declarationList => [ declarationList @ ] declaration
  To #2:  declaration
Status #2 [FINAL] - declarationList => [ declarationList ] declaration @

** Rule: declarationSpecifier => ( storageClassSpecifier | typeSpecifier | typeQualifier )
-- Tokens: union struct enum int bool char long float unsigned double void short const volatile #identifier# signed auto static extern typedef register
-- First-set tokens: register typedef extern static auto volatile const short signed void unsigned float long char bool #identifier# int enum double struct union
-- First-set rules: typeQualifier typeSpecifier storageClassSpecifier
Status #0 - declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
  To #1:  typeQualifier
  To #2:  storageClassSpecifier
  To #3:  typeSpecifier
Status #1 [FINAL] - declarationSpecifier => ( storageClassSpecifier | typeSpecifier | typeQualifier @ )
Status #2 [FINAL] - declarationSpecifier => ( storageClassSpecifier @ | typeSpecifier | typeQualifier )
Status #3 [FINAL] - declarationSpecifier => ( storageClassSpecifier | typeSpecifier @ | typeQualifier )

** Rule: declarationSpecifiers => [ declarationSpecifiers ] declarationSpecifier
-- Tokens: union struct enum int bool char long float unsigned double void short const volatile #identifier# signed auto static extern typedef register
-- First-set tokens: union struct enum int bool char long float unsigned double void short const volatile #identifier# signed auto static extern typedef register
-- First-set rules: declarationSpecifier declarationSpecifiers
Status #0 - declarationSpecifiers => [ @ declarationSpecifiers ] declarationSpecifier
  To #1:  declarationSpecifiers
  To #2:  declarationSpecifier
Status #1 - declarationSpecifiers => [ declarationSpecifiers @ ] declarationSpecifier
  To #2:  declarationSpecifier
Status #2 [FINAL] - declarationSpecifiers => [ declarationSpecifiers ] declarationSpecifier @

** Rule: declarationSpecifiers2 => [ declarationSpecifiers ] declarationSpecifier
-- Tokens: register typedef extern static auto signed #identifier# volatile const short void double unsigned float long char bool int enum struct union
-- First-set tokens: union struct enum int bool char long float unsigned double void short const volatile #identifier# signed auto static extern typedef register
-- First-set rules: declarationSpecifier declarationSpecifiers
Status #0 - declarationSpecifiers2 => [ @ declarationSpecifiers ] declarationSpecifier
  To #1:  declarationSpecifiers
  To #2:  declarationSpecifier
Status #1 - declarationSpecifiers2 => [ declarationSpecifiers @ ] declarationSpecifier
  To #2:  declarationSpecifier
Status #2 [FINAL] - declarationSpecifiers2 => [ declarationSpecifiers ] declarationSpecifier @

** Rule: declarator => [ pointer ] directDeclarator
-- Tokens: '(' '*' #identifier# '^' const volatile
-- First-set tokens: volatile const '^' #identifier# '*' '('
-- First-set rules: directDeclarator pointer
Status #0 - declarator => [ @ pointer ] directDeclarator
  To #1:  pointer
  To #2:  directDeclarator
Status #1 - declarator => [ pointer @ ] directDeclarator
  To #2:  directDeclarator
Status #2 [FINAL] - declarator => [ pointer ] directDeclarator @

** Rule: designation => designatorList '='
-- Tokens: '[' '.'
-- First-set tokens: '.' '['
-- First-set rules: designatorList
Status #0 - designation => @ designatorList '='
  To #1:  designatorList
Status #1 - designation => designatorList @ '='
  To #2:  '='
Status #2 [FINAL] - designation => designatorList '=' @

** Rule: designator => ( '[' constantExpression ']' | '.' #identifier# )
-- Tokens: '[' '.'
-- First-set tokens: '.' '['
-- First-set rules:
Status #0 - designator => @ ( '[' constantExpression ']' | '.' #identifier# )
  To #1:  '.'
  To #2:  '['
Status #1 - designator => ( '[' constantExpression ']' | '.' @ #identifier# )
  To #3:  #identifier#
Status #2 - designator => ( '[' @ constantExpression ']' | '.' #identifier# )
  To #4:  constantExpression
Status #3 [FINAL] - designator => ( '[' constantExpression ']' | '.' #identifier# @ )
Status #4 - designator => ( '[' constantExpression @ ']' | '.' #identifier# )
  To #5:  ']'
Status #5 [FINAL] - designator => ( '[' constantExpression ']' @ | '.' #identifier# )

** Rule: designatorList => [ designatorList ] designator
-- Tokens: '[' '.'
-- First-set tokens: '[' '.'
-- First-set rules: designator designatorList
Status #0 - designatorList => [ @ designatorList ] designator
  To #1:  designatorList
  To #2:  designator
Status #1 - designatorList => [ designatorList @ ] designator
  To #2:  designator
Status #2 [FINAL] - designatorList => [ designatorList ] designator @

** Rule: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
-- Tokens: '(' '['
-- First-set tokens: '[' '('
-- First-set rules: directAbstractDeclarator
Status #0 - directAbstractDeclarator => @ ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
  To #1:  '('
  To #2:  ('(')
  To #3:  directAbstractDeclarator
  To #4:  '['
Status #1 - directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' @ [ parameterTypeList ] ')' ) )
  To #5:  ')'
  To #6:  parameterTypeList
Status #2 - directAbstractDeclarator => ( ('(') @ abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
  To #7:  abstractDeclarator
Status #3 - directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator @ ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
  To #1:  '('
  To #4:  '['
Status #4 - directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' @ ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
  To #8:  ']'
  To #9:  typeQualifierList
  To #10:  '*'
  To #11:  assignmentExpression
Status #5 [FINAL] - directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' @ ) )
Status #6 - directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList @ ] ')' ) )
  To #5:  ')'
Status #7 - directAbstractDeclarator => ( ('(') abstractDeclarator @ (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
  To #12:  (')')
Status #8 [FINAL] - directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' @ | '(' [ parameterTypeList ] ')' ) )
Status #9 - directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList @ ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
  To #8:  ']'
  To #11:  assignmentExpression
Status #10 - directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' @ ) ']' | '(' [ parameterTypeList ] ')' ) )
  To #8:  ']'
Status #11 - directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression @ ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
  To #8:  ']'
Status #12 [FINAL] - directAbstractDeclarator => ( ('(') abstractDeclarator (')') @ | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )

** Rule: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
-- Tokens: #identifier# '('
-- First-set tokens: '(' #identifier#
-- First-set rules: directDeclarator
Status #0 - directDeclarator => @ ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
  To #1:  directDeclarator
  To #2:  #identifier#
  To #3:  ('(')
Status #1 - directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator @ ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
  To #4:  ('(')
  To #5:  ('[')
Status #2 [FINAL] - directDeclarator => ( #identifier# @ | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
Status #3 - directDeclarator => ( #identifier# | ('(') @ declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
  To #6:  declarator
Status #4 - directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') @ ( parameterTypeList | [ identifierList ] ) (')') ) )
  To #7:  (')')
  To #8:  parameterTypeList
  To #9:  identifierList
Status #5 - directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') @ [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
  To #10:  '*'
  To #11:  typeQualifierList
  To #12:  assignmentExpression
Status #6 - directDeclarator => ( #identifier# | ('(') declarator @ (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
  To #13:  (')')
Status #7 [FINAL] - directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') @ ) )
Status #8 - directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList @ | [ identifierList ] ) (')') ) )
  To #7:  (')')
Status #9 - directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList @ ] ) (')') ) )
  To #7:  (')')
Status #10 - directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' @ ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
  To #14:  (']')
Status #11 - directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList @ ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
  To #10:  '*'
  To #12:  assignmentExpression
Status #12 - directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression @ | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
  To #14:  (']')
Status #13 [FINAL] - directDeclarator => ( #identifier# | ('(') declarator (')') @ | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
Status #14 [FINAL] - directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') @ | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )

** Rule: enumSpecifier => (enum) ( [ #identifier# ] ('{') enumeratorList [ (',') ] ('{') | #identifier# )
-- Tokens: enum
-- First-set tokens: enum
-- First-set rules:
Status #0 - enumSpecifier => @ (enum) ( [ #identifier# ] ('{') enumeratorList [ (',') ] ('{') | #identifier# )
  To #1:  (enum)
Status #1 - enumSpecifier => (enum) @ ( [ #identifier# ] ('{') enumeratorList [ (',') ] ('{') | #identifier# )
  To #2:  ('{')
  To #3:  #identifier#
  To #4:  #identifier#
Status #2 - enumSpecifier => (enum) ( [ #identifier# ] ('{') @ enumeratorList [ (',') ] ('{') | #identifier# )
  To #5:  enumeratorList
Status #3 - enumSpecifier => (enum) ( [ #identifier# @ ] ('{') enumeratorList [ (',') ] ('{') | #identifier# )
  To #2:  ('{')
Status #4 [FINAL] - enumSpecifier => (enum) ( [ #identifier# ] ('{') enumeratorList [ (',') ] ('{') | #identifier# @ )
Status #5 - enumSpecifier => (enum) ( [ #identifier# ] ('{') enumeratorList @ [ (',') ] ('{') | #identifier# )
  To #6:  ('{')
  To #7:  (',')
Status #6 [FINAL] - enumSpecifier => (enum) ( [ #identifier# ] ('{') enumeratorList [ (',') ] ('{') @ | #identifier# )
Status #7 - enumSpecifier => (enum) ( [ #identifier# ] ('{') enumeratorList [ (',') @ ] ('{') | #identifier# )
  To #6:  ('{')

** Rule: enumerationConstant => #identifier#
-- Tokens: #identifier#
-- First-set tokens: #identifier#
-- First-set rules:
Status #0 - enumerationConstant => @ #identifier#
  To #1:  #identifier#
Status #1 [FINAL] - enumerationConstant => #identifier# @

** Rule: enumerator => enumerationConstant [ ('=') constantExpression ]
-- Tokens: #identifier#
-- First-set tokens: #identifier#
-- First-set rules: enumerationConstant
Status #0 - enumerator => @ enumerationConstant [ ('=') constantExpression ]
  To #1:  enumerationConstant
Status #1 [FINAL] - enumerator => enumerationConstant @ [ ('=') constantExpression ]
  To #2:  ('=')
Status #2 - enumerator => enumerationConstant [ ('=') @ constantExpression ]
  To #3:  constantExpression
Status #3 [FINAL] - enumerator => enumerationConstant [ ('=') constantExpression @ ]

** Rule: enumeratorList => [ enumeratorList (',') ] enumerator
-- Tokens: #identifier#
-- First-set tokens: #identifier#
-- First-set rules: enumerator enumeratorList
Status #0 - enumeratorList => [ @ enumeratorList (',') ] enumerator
  To #1:  enumeratorList
  To #2:  enumerator
Status #1 - enumeratorList => [ enumeratorList @ (',') ] enumerator
  To #3:  (',')
Status #2 [FINAL] - enumeratorList => [ enumeratorList (',') ] enumerator @
Status #3 - enumeratorList => [ enumeratorList (',') @ ] enumerator
  To #2:  enumerator

** Rule: equalityExpression => [ equalityExpression ( '==' | '!=' ) ] relationalExpression
-- Tokens: #double# '&' '*' #uint# '+' #uchar# #float# '~' #short# '(' '-' #ushort# '++' '--' '!' #int# #char# sizeof #string# #identifier# #long# #ulong#
-- First-set tokens: #double# #uint# #uchar# #float# '~' '+' #short# '(' #ushort# '++' '--' '!' '-' #int# #char# sizeof #string# '&' #identifier# '*' #long# #ulong#
-- First-set rules: relationalExpression equalityExpression
Status #0 - equalityExpression => [ @ equalityExpression ( '==' | '!=' ) ] relationalExpression
  To #1:  equalityExpression
  To #2:  relationalExpression
Status #1 - equalityExpression => [ equalityExpression @ ( '==' | '!=' ) ] relationalExpression
  To #3:  '!='
  To #4:  '=='
Status #2 [FINAL] - equalityExpression => [ equalityExpression ( '==' | '!=' ) ] relationalExpression @
Status #3 - equalityExpression => [ equalityExpression ( '==' | '!=' @ ) ] relationalExpression
  To #2:  relationalExpression
Status #4 - equalityExpression => [ equalityExpression ( '==' @ | '!=' ) ] relationalExpression
  To #2:  relationalExpression

** Rule: exclusiveOrExpression => [ exclusiveOrExpression '^' ] andExpression
-- Tokens: #double# '&' '*' #uint# '+' #uchar# #float# '~' #short# '(' '-' #ushort# '++' '--' '!' #int# #char# sizeof #string# #identifier# #long# #ulong#
-- First-set tokens: #double# #uint# #uchar# #float# '~' '+' #short# '(' #ushort# '++' '--' '!' '-' #int# #char# sizeof #string# '&' #identifier# '*' #long# #ulong#
-- First-set rules: andExpression exclusiveOrExpression
Status #0 - exclusiveOrExpression => [ @ exclusiveOrExpression '^' ] andExpression
  To #1:  exclusiveOrExpression
  To #2:  andExpression
Status #1 - exclusiveOrExpression => [ exclusiveOrExpression @ '^' ] andExpression
  To #3:  '^'
Status #2 [FINAL] - exclusiveOrExpression => [ exclusiveOrExpression '^' ] andExpression @
Status #3 - exclusiveOrExpression => [ exclusiveOrExpression '^' @ ] andExpression
  To #2:  andExpression

** Rule: expression => [ expression (',') ] assignmentExpression
-- Tokens: #float# #ulong# #long# #int# #char# #identifier# #string# sizeof '!' '--' '++' '-' #ushort# '(' #short# '~' '+' #uchar# '*' #uint# '&' #double#
-- First-set tokens: #float# #ulong# #char# #string# sizeof '!' '--' '++' #int# '-' #ushort# '(' '~' #short# '+' #uchar# #long# '*' #uint# #identifier# '&' #double#
-- First-set rules: assignmentExpression expression
Status #0 - expression => [ @ expression (',') ] assignmentExpression
  To #1:  expression
  To #2:  assignmentExpression
Status #1 - expression => [ expression @ (',') ] assignmentExpression
  To #3:  (',')
Status #2 [FINAL] - expression => [ expression (',') ] assignmentExpression @
Status #3 - expression => [ expression (',') @ ] assignmentExpression
  To #2:  assignmentExpression

** Rule: expressionStatement => [ expression ] (';')
-- Tokens: ';' '*' #float# '~' #ulong# #long# #int# '!' #char# sizeof #identifier# #string# '--' '++' '-' #ushort# '(' #double# #short# '+' #uchar# #uint# '&'
-- First-set tokens: '&' #uint# #uchar# '+' #short# #double# '(' #ushort# '-' '++' '--' #string# #identifier# sizeof #char# '!' #int# #long# #ulong# '~' #float# '*' ';'
-- First-set rules: expression
Status #0 - expressionStatement => [ @ expression ] (';')
  To #1:  expression
  To #2:  (';')
Status #1 - expressionStatement => [ expression @ ] (';')
  To #2:  (';')
Status #2 [FINAL] - expressionStatement => [ expression ] (';') @

** Rule: externalDeclaration => ( functionDefinition | declaration | (';') )
-- Tokens: static typedef auto signed #identifier# const short void double unsigned float long int enum struct union bool volatile char '(' register '^' extern ';' '*'
-- First-set tokens: '*' '^' '(' bool union struct enum int char long float unsigned double void short const volatile #identifier# ';' signed auto static extern typedef register
-- First-set rules: declaration functionDefinition
Status #0 - externalDeclaration => @ ( functionDefinition | declaration | (';') )
  To #1:  (';')
  To #2:  functionDefinition
  To #3:  declaration
Status #1 [FINAL] - externalDeclaration => ( functionDefinition | declaration | (';') @ )
Status #2 [FINAL] - externalDeclaration => ( functionDefinition @ | declaration | (';') )
Status #3 [FINAL] - externalDeclaration => ( functionDefinition | declaration @ | (';') )

** Rule: forCondition => ( forDeclaration | [ expression ] ) ';' [ forExpression ] ';' [ forExpression ]
-- Tokens: #uint# #uchar# sizeof '+' #short# #double# void '(' #ushort# static '++' struct '--' #string# '&' #identifier# volatile #char# '!' '-' #int# typedef #ulong# union float '~' #float# unsigned #long# '*' signed ';' enum int bool char long double short const auto extern register
-- First-set tokens: register extern auto const short double long char bool int enum ';' '*' unsigned #float# '~' union #ulong# typedef #long# #int# '!' signed #char# volatile #identifier# #string# float '--' '++' '-' struct #ushort# '(' void #double# static #short# '+' sizeof #uchar# #uint# '&'
-- First-set rules: expression forDeclaration
Status #0 - forCondition => @ ( forDeclaration | [ expression ] ) ';' [ forExpression ] ';' [ forExpression ]
  To #1:  ';'
  To #2:  forDeclaration
  To #3:  expression
Status #1 - forCondition => ( forDeclaration | [ expression ] ) ';' @ [ forExpression ] ';' [ forExpression ]
  To #4:  ';'
  To #5:  forExpression
Status #2 - forCondition => ( forDeclaration @ | [ expression ] ) ';' [ forExpression ] ';' [ forExpression ]
  To #1:  ';'
Status #3 - forCondition => ( forDeclaration | [ expression @ ] ) ';' [ forExpression ] ';' [ forExpression ]
  To #1:  ';'
Status #4 [FINAL] - forCondition => ( forDeclaration | [ expression ] ) ';' [ forExpression ] ';' @ [ forExpression ]
  To #6:  forExpression
Status #5 - forCondition => ( forDeclaration | [ expression ] ) ';' [ forExpression @ ] ';' [ forExpression ]
  To #4:  ';'
Status #6 [FINAL] - forCondition => ( forDeclaration | [ expression ] ) ';' [ forExpression ] ';' [ forExpression @ ]

** Rule: forDeclaration => declarationSpecifiers [ initDeclaratorList ]
-- Tokens: union struct enum int bool char long float unsigned double void short const volatile #identifier# signed auto static extern typedef register
-- First-set tokens: register typedef extern static auto signed #identifier# volatile const short void double unsigned float long char bool int enum struct union
-- First-set rules: declarationSpecifiers
Status #0 - forDeclaration => @ declarationSpecifiers [ initDeclaratorList ]
  To #1:  declarationSpecifiers
Status #1 [FINAL] - forDeclaration => declarationSpecifiers @ [ initDeclaratorList ]
  To #2:  initDeclaratorList
Status #2 [FINAL] - forDeclaration => declarationSpecifiers [ initDeclaratorList @ ]

** Rule: forExpression => [ forExpression (',') ] assignmentExpression
-- Tokens: #float# #ulong# #long# #int# #char# #identifier# #string# sizeof '!' '--' '++' '-' #ushort# '(' #short# '~' '+' #uchar# '*' #uint# '&' #double#
-- First-set tokens: #float# #ulong# #char# #string# sizeof '!' '--' '++' #int# '-' #ushort# '(' '~' #short# '+' #uchar# #long# '*' #uint# #identifier# '&' #double#
-- First-set rules: assignmentExpression forExpression
Status #0 - forExpression => [ @ forExpression (',') ] assignmentExpression
  To #1:  forExpression
  To #2:  assignmentExpression
Status #1 - forExpression => [ forExpression @ (',') ] assignmentExpression
  To #3:  (',')
Status #2 [FINAL] - forExpression => [ forExpression (',') ] assignmentExpression @
Status #3 - forExpression => [ forExpression (',') @ ] assignmentExpression
  To #2:  assignmentExpression

** Rule: functionDefinition => [ declarationSpecifiers ] declarator [ declarationList ] compoundStatement
-- Tokens: volatile '(' char const #identifier# '^' register '*' extern union bool struct enum int long float unsigned double void short signed auto typedef static
-- First-set tokens: static typedef auto signed short void double unsigned float long int enum struct bool union extern '*' register '^' #identifier# const char '(' volatile
-- First-set rules: declarator declarationSpecifiers
Status #0 - functionDefinition => [ @ declarationSpecifiers ] declarator [ declarationList ] compoundStatement
  To #1:  declarationSpecifiers
  To #2:  declarator
Status #1 - functionDefinition => [ declarationSpecifiers @ ] declarator [ declarationList ] compoundStatement
  To #2:  declarator
Status #2 - functionDefinition => [ declarationSpecifiers ] declarator @ [ declarationList ] compoundStatement
  To #3:  compoundStatement
  To #4:  declarationList
Status #3 [FINAL] - functionDefinition => [ declarationSpecifiers ] declarator [ declarationList ] compoundStatement @
Status #4 - functionDefinition => [ declarationSpecifiers ] declarator [ declarationList @ ] compoundStatement
  To #3:  compoundStatement

** Rule: identifierList => [ identifierList (',') ] #identifier#
-- Tokens: #identifier#
-- First-set tokens: #identifier#
-- First-set rules: identifierList
Status #0 - identifierList => [ @ identifierList (',') ] #identifier#
  To #1:  identifierList
  To #2:  #identifier#
Status #1 - identifierList => [ identifierList @ (',') ] #identifier#
  To #3:  (',')
Status #2 [FINAL] - identifierList => [ identifierList (',') ] #identifier# @
Status #3 - identifierList => [ identifierList (',') @ ] #identifier#
  To #2:  #identifier#

** Rule: inclusiveOrExpression => [ inclusiveOrExpression '|' ] exclusiveOrExpression
-- Tokens: #double# '&' '*' #uint# '+' #uchar# #float# '~' #short# '(' '-' #ushort# '++' '--' '!' #int# #char# sizeof #string# #identifier# #long# #ulong#
-- First-set tokens: #double# #uint# #uchar# #float# '~' '+' #short# '(' #ushort# '++' '--' '!' '-' #int# #char# sizeof #string# '&' #identifier# '*' #long# #ulong#
-- First-set rules: exclusiveOrExpression inclusiveOrExpression
Status #0 - inclusiveOrExpression => [ @ inclusiveOrExpression '|' ] exclusiveOrExpression
  To #1:  inclusiveOrExpression
  To #2:  exclusiveOrExpression
Status #1 - inclusiveOrExpression => [ inclusiveOrExpression @ '|' ] exclusiveOrExpression
  To #3:  '|'
Status #2 [FINAL] - inclusiveOrExpression => [ inclusiveOrExpression '|' ] exclusiveOrExpression @
Status #3 - inclusiveOrExpression => [ inclusiveOrExpression '|' @ ] exclusiveOrExpression
  To #2:  exclusiveOrExpression

** Rule: initDeclarator => declarator [ ('=') initializer ]
-- Tokens: '(' '*' #identifier# '^' const volatile
-- First-set tokens: volatile const '^' #identifier# '*' '('
-- First-set rules: declarator
Status #0 - initDeclarator => @ declarator [ ('=') initializer ]
  To #1:  declarator
Status #1 [FINAL] - initDeclarator => declarator @ [ ('=') initializer ]
  To #2:  ('=')
Status #2 - initDeclarator => declarator [ ('=') @ initializer ]
  To #3:  initializer
Status #3 [FINAL] - initDeclarator => declarator [ ('=') initializer @ ]

** Rule: initDeclaratorList => [ initDeclaratorList (',') ] initDeclarator
-- Tokens: '(' '*' #identifier# '^' const volatile
-- First-set tokens: '(' '*' #identifier# '^' const volatile
-- First-set rules: initDeclarator initDeclaratorList
Status #0 - initDeclaratorList => [ @ initDeclaratorList (',') ] initDeclarator
  To #1:  initDeclaratorList
  To #2:  initDeclarator
Status #1 - initDeclaratorList => [ initDeclaratorList @ (',') ] initDeclarator
  To #3:  (',')
Status #2 [FINAL] - initDeclaratorList => [ initDeclaratorList (',') ] initDeclarator @
Status #3 - initDeclaratorList => [ initDeclaratorList (',') @ ] initDeclarator
  To #2:  initDeclarator

** Rule: initializer => ( assignmentExpression | '{' initializerList [ (',') ] '}' )
-- Tokens: '{' #string# #float# '~' #ulong# #long# #int# '!' #char# sizeof #identifier# '--' '++' '-' #ushort# '(' #double# #short# '+' #uchar# '*' #uint# '&'
-- First-set tokens: '&' #uint# '*' #uchar# '+' #short# #double# '(' #ushort# '-' '++' '--' #identifier# sizeof #char# '!' #int# #long# #ulong# '~' #float# #string# '{'
-- First-set rules: assignmentExpression
Status #0 - initializer => @ ( assignmentExpression | '{' initializerList [ (',') ] '}' )
  To #1:  '{'
  To #2:  assignmentExpression
Status #1 - initializer => ( assignmentExpression | '{' @ initializerList [ (',') ] '}' )
  To #3:  initializerList
Status #2 [FINAL] - initializer => ( assignmentExpression @ | '{' initializerList [ (',') ] '}' )
Status #3 - initializer => ( assignmentExpression | '{' initializerList @ [ (',') ] '}' )
  To #4:  '}'
  To #5:  (',')
Status #4 [FINAL] - initializer => ( assignmentExpression | '{' initializerList [ (',') ] '}' @ )
Status #5 - initializer => ( assignmentExpression | '{' initializerList [ (',') @ ] '}' )
  To #4:  '}'

** Rule: initializerList => [ initializerList (',') ] [ designation ] initializer
-- Tokens: '{' #string# #float# '~' #ulong# #long# #int# '!' #char# sizeof #identifier# '--' '++' '-' #ushort# '(' #double# #short# '+' '[' #uchar# '*' #uint# '&' '.'
-- First-set tokens: '{' #string# #float# '~' #ulong# #long# #int# '!' #char# #identifier# '--' '++' '-' #ushort# '(' #double# #short# '+' '[' sizeof #uchar# '*' #uint# '&' '.'
-- First-set rules: initializer designation initializerList
Status #0 - initializerList => [ @ initializerList (',') ] [ designation ] initializer
  To #1:  initializerList
  To #2:  designation
  To #3:  initializer
Status #1 - initializerList => [ initializerList @ (',') ] [ designation ] initializer
  To #4:  (',')
Status #2 - initializerList => [ initializerList (',') ] [ designation @ ] initializer
  To #3:  initializer
Status #3 [FINAL] - initializerList => [ initializerList (',') ] [ designation ] initializer @
Status #4 - initializerList => [ initializerList (',') @ ] [ designation ] initializer
  To #3:  initializer
  To #2:  designation

** Rule: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
-- Tokens: while do for
-- First-set tokens: for do while
-- First-set rules:
Status #0 - iterationStatement => @ ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
  To #1:  for
  To #2:  while
  To #3:  do
Status #1 - iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for @ ('(') forCondition (')') statement )
  To #4:  ('(')
Status #2 - iterationStatement => ( while @ ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
  To #5:  ('(')
Status #3 - iterationStatement => ( while ('(') expression (')') statement | do @ statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
  To #6:  statement
Status #4 - iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') @ forCondition (')') statement )
  To #7:  forCondition
Status #5 - iterationStatement => ( while ('(') @ expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
  To #8:  expression
Status #6 - iterationStatement => ( while ('(') expression (')') statement | do statement @ while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
  To #9:  while
Status #7 - iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition @ (')') statement )
  To #10:  (')')
Status #8 - iterationStatement => ( while ('(') expression @ (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
  To #11:  (')')
Status #9 - iterationStatement => ( while ('(') expression (')') statement | do statement while @ ('(') expression (')') ';' | for ('(') forCondition (')') statement )
  To #12:  ('(')
Status #10 - iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') @ statement )
  To #13:  statement
Status #11 - iterationStatement => ( while ('(') expression (')') @ statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
  To #14:  statement
Status #12 - iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') @ expression (')') ';' | for ('(') forCondition (')') statement )
  To #15:  expression
Status #13 [FINAL] - iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement @ )
Status #14 [FINAL] - iterationStatement => ( while ('(') expression (')') statement @ | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
Status #15 - iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression @ (')') ';' | for ('(') forCondition (')') statement )
  To #16:  (')')
Status #16 - iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') @ ';' | for ('(') forCondition (')') statement )
  To #17:  ';'
Status #17 [FINAL] - iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' @ | for ('(') forCondition (')') statement )

** Rule: jumpStatement => ( goto #identifier# | continue | break | return [ expression ] ) (';')
-- Tokens: goto continue return break
-- First-set tokens: break return continue goto
-- First-set rules:
Status #0 - jumpStatement => @ ( goto #identifier# | continue | break | return [ expression ] ) (';')
  To #1:  return
  To #2:  goto
  To #3:  continue
  To #4:  break
Status #1 - jumpStatement => ( goto #identifier# | continue | break | return @ [ expression ] ) (';')
  To #5:  (';')
  To #6:  expression
Status #2 - jumpStatement => ( goto @ #identifier# | continue | break | return [ expression ] ) (';')
  To #7:  #identifier#
Status #3 - jumpStatement => ( goto #identifier# | continue @ | break | return [ expression ] ) (';')
  To #5:  (';')
Status #4 - jumpStatement => ( goto #identifier# | continue | break @ | return [ expression ] ) (';')
  To #5:  (';')
Status #5 [FINAL] - jumpStatement => ( goto #identifier# | continue | break | return [ expression ] ) (';') @
Status #6 - jumpStatement => ( goto #identifier# | continue | break | return [ expression @ ] ) (';')
  To #5:  (';')
Status #7 - jumpStatement => ( goto #identifier# @ | continue | break | return [ expression ] ) (';')
  To #5:  (';')

** Rule: labeledStatement => ( #identifier# | case constantExpression | default ) '=' statement
-- Tokens: #identifier# default case
-- First-set tokens: case default #identifier#
-- First-set rules:
Status #0 - labeledStatement => @ ( #identifier# | case constantExpression | default ) '=' statement
  To #1:  default
  To #2:  #identifier#
  To #3:  case
Status #1 - labeledStatement => ( #identifier# | case constantExpression | default @ ) '=' statement
  To #4:  '='
Status #2 - labeledStatement => ( #identifier# @ | case constantExpression | default ) '=' statement
  To #4:  '='
Status #3 - labeledStatement => ( #identifier# | case @ constantExpression | default ) '=' statement
  To #5:  constantExpression
Status #4 - labeledStatement => ( #identifier# | case constantExpression | default ) '=' @ statement
  To #6:  statement
Status #5 - labeledStatement => ( #identifier# | case constantExpression @ | default ) '=' statement
  To #4:  '='
Status #6 [FINAL] - labeledStatement => ( #identifier# | case constantExpression | default ) '=' statement @

** Rule: logicalAndExpression => [ logicalAndExpression '&&' ] inclusiveOrExpression
-- Tokens: #double# '&' '*' #uint# '+' #uchar# #float# '~' #short# '(' '-' #ushort# '++' '--' '!' #int# #char# sizeof #string# #identifier# #long# #ulong#
-- First-set tokens: #double# #uint# #uchar# #float# '~' '+' #short# '(' #ushort# '++' '--' '!' '-' #int# #char# sizeof #string# '&' #identifier# '*' #long# #ulong#
-- First-set rules: inclusiveOrExpression logicalAndExpression
Status #0 - logicalAndExpression => [ @ logicalAndExpression '&&' ] inclusiveOrExpression
  To #1:  logicalAndExpression
  To #2:  inclusiveOrExpression
Status #1 - logicalAndExpression => [ logicalAndExpression @ '&&' ] inclusiveOrExpression
  To #3:  '&&'
Status #2 [FINAL] - logicalAndExpression => [ logicalAndExpression '&&' ] inclusiveOrExpression @
Status #3 - logicalAndExpression => [ logicalAndExpression '&&' @ ] inclusiveOrExpression
  To #2:  inclusiveOrExpression

** Rule: logicalOrExpression => [ logicalOrExpression '||' ] logicalAndExpression
-- Tokens: #double# '&' '*' #uint# '+' #uchar# #float# '~' #short# '(' '-' #ushort# '++' '--' '!' #int# #char# sizeof #string# #identifier# #long# #ulong#
-- First-set tokens: #double# #uint# #uchar# #float# '~' '+' #short# '(' #ushort# '++' '--' '!' '-' #int# #char# sizeof #string# '&' #identifier# '*' #long# #ulong#
-- First-set rules: logicalAndExpression logicalOrExpression
Status #0 - logicalOrExpression => [ @ logicalOrExpression '||' ] logicalAndExpression
  To #1:  logicalOrExpression
  To #2:  logicalAndExpression
Status #1 - logicalOrExpression => [ logicalOrExpression @ '||' ] logicalAndExpression
  To #3:  '||'
Status #2 [FINAL] - logicalOrExpression => [ logicalOrExpression '||' ] logicalAndExpression @
Status #3 - logicalOrExpression => [ logicalOrExpression '||' @ ] logicalAndExpression
  To #2:  logicalAndExpression

** Rule: multiplicativeExpression => [ multiplicativeExpression ( '*' | '/' | '%' ) ] castExpression
-- Tokens: #double# '&' '*' #uint# '+' #uchar# #float# '~' #short# '(' '-' #ushort# '++' '--' '!' #int# #char# sizeof #string# #identifier# #long# #ulong#
-- First-set tokens: #double# #uint# #uchar# #float# '~' '+' #short# '(' #ushort# '++' '--' '!' '-' #int# #char# sizeof #string# '&' #identifier# '*' #long# #ulong#
-- First-set rules: castExpression multiplicativeExpression
Status #0 - multiplicativeExpression => [ @ multiplicativeExpression ( '*' | '/' | '%' ) ] castExpression
  To #1:  multiplicativeExpression
  To #2:  castExpression
Status #1 - multiplicativeExpression => [ multiplicativeExpression @ ( '*' | '/' | '%' ) ] castExpression
  To #3:  '%'
  To #4:  '*'
  To #5:  '/'
Status #2 [FINAL] - multiplicativeExpression => [ multiplicativeExpression ( '*' | '/' | '%' ) ] castExpression @
Status #3 - multiplicativeExpression => [ multiplicativeExpression ( '*' | '/' | '%' @ ) ] castExpression
  To #2:  castExpression
Status #4 - multiplicativeExpression => [ multiplicativeExpression ( '*' @ | '/' | '%' ) ] castExpression
  To #2:  castExpression
Status #5 - multiplicativeExpression => [ multiplicativeExpression ( '*' | '/' @ | '%' ) ] castExpression
  To #2:  castExpression

** Rule: parameterDeclaration => ( declarationSpecifiers declarator | declarationSpecifiers2 [ abstractDeclarator ] )
-- Tokens: union struct enum int bool char long float unsigned double void short const volatile #identifier# signed auto static extern typedef register
-- First-set tokens: register typedef extern static auto signed #identifier# volatile const short void double unsigned float long char bool int enum struct union
-- First-set rules: declarationSpecifiers2 declarationSpecifiers
Status #0 - parameterDeclaration => @ ( declarationSpecifiers declarator | declarationSpecifiers2 [ abstractDeclarator ] )
  To #1:  declarationSpecifiers2
  To #2:  declarationSpecifiers
Status #1 [FINAL] - parameterDeclaration => ( declarationSpecifiers declarator | declarationSpecifiers2 @ [ abstractDeclarator ] )
  To #3:  abstractDeclarator
Status #2 - parameterDeclaration => ( declarationSpecifiers @ declarator | declarationSpecifiers2 [ abstractDeclarator ] )
  To #4:  declarator
Status #3 [FINAL] - parameterDeclaration => ( declarationSpecifiers declarator | declarationSpecifiers2 [ abstractDeclarator @ ] )
Status #4 [FINAL] - parameterDeclaration => ( declarationSpecifiers declarator @ | declarationSpecifiers2 [ abstractDeclarator ] )

** Rule: parameterList => [ parameterList (',') ] parameterDeclaration
-- Tokens: union struct enum int bool char long float unsigned double void short const volatile #identifier# signed auto static extern typedef register
-- First-set tokens: union struct enum int bool char long float unsigned double void short const volatile #identifier# signed auto static extern typedef register
-- First-set rules: parameterDeclaration parameterList
Status #0 - parameterList => [ @ parameterList (',') ] parameterDeclaration
  To #1:  parameterList
  To #2:  parameterDeclaration
Status #1 - parameterList => [ parameterList @ (',') ] parameterDeclaration
  To #3:  (',')
Status #2 [FINAL] - parameterList => [ parameterList (',') ] parameterDeclaration @
Status #3 - parameterList => [ parameterList (',') @ ] parameterDeclaration
  To #2:  parameterDeclaration

** Rule: parameterTypeList => parameterList [ (',') '...' ]
-- Tokens: union struct enum int bool char long float unsigned double void short const volatile #identifier# signed auto static extern typedef register
-- First-set tokens: register typedef extern static auto signed #identifier# volatile const short void double unsigned float long char bool int enum struct union
-- First-set rules: parameterList
Status #0 - parameterTypeList => @ parameterList [ (',') '...' ]
  To #1:  parameterList
Status #1 [FINAL] - parameterTypeList => parameterList @ [ (',') '...' ]
  To #2:  (',')
Status #2 - parameterTypeList => parameterList [ (',') @ '...' ]
  To #3:  '...'
Status #3 [FINAL] - parameterTypeList => parameterList [ (',') '...' @ ]

** Rule: pointer => [ typeQualifierList ] [ pointer ] ( '*' | '^' )
-- Tokens: '*' '^' const volatile
-- First-set tokens: '*' '^' const volatile
-- First-set rules: pointer typeQualifierList
Status #0 - pointer => [ @ typeQualifierList ] [ pointer ] ( '*' | '^' )
  To #1:  typeQualifierList
  To #2:  pointer
  To #3:  '*'
  To #4:  '^'
Status #1 - pointer => [ typeQualifierList @ ] [ pointer ] ( '*' | '^' )
  To #4:  '^'
  To #2:  pointer
  To #3:  '*'
Status #2 - pointer => [ typeQualifierList ] [ pointer @ ] ( '*' | '^' )
  To #4:  '^'
  To #3:  '*'
Status #3 [FINAL] - pointer => [ typeQualifierList ] [ pointer ] ( '*' @ | '^' )
Status #4 [FINAL] - pointer => [ typeQualifierList ] [ pointer ] ( '*' | '^' @ )

** Rule: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
-- Tokens: '(' #string# #identifier# #ushort# #short# #uchar# #char# #int# #uint# #long# #ulong# #float# #double#
-- First-set tokens: '(' #string# #identifier# #ushort# #short# #uchar# #char# #int# #uint# #long# #ulong# #float# #double#
-- First-set rules: postfixExpression primaryExpression
Status #0 - postfixExpression => @ ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
  To #1:  ('(')
  To #2:  primaryExpression
  To #3:  postfixExpression
Status #1 - postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') @ typeName (')') ('{') initializerList [ (',') ] ('}') )
  To #4:  typeName
Status #2 [FINAL] - postfixExpression => ( primaryExpression @ | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
Status #3 - postfixExpression => ( primaryExpression | postfixExpression @ ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
  To #5:  '->'
  To #6:  ('[')
  To #7:  ('(')
  To #8:  '++'
  To #9:  '--'
  To #10:  '.'
Status #4 - postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName @ (')') ('{') initializerList [ (',') ] ('}') )
  To #11:  (')')
Status #5 - postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' @ ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
  To #12:  #identifier#
Status #6 - postfixExpression => ( primaryExpression | postfixExpression ( ('[') @ expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
  To #13:  expression
Status #7 - postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') @ [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
  To #14:  (')')
  To #15:  argumentExpressionList
Status #8 [FINAL] - postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' @ | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
Status #9 [FINAL] - postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' @ ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
Status #10 - postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' @ | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
  To #12:  #identifier#
Status #11 - postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') @ ('{') initializerList [ (',') ] ('}') )
  To #16:  ('{')
Status #12 [FINAL] - postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# @ | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
Status #13 - postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression @ (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
  To #17:  (']')
Status #14 [FINAL] - postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') @ | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
Status #15 - postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList @ ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
  To #14:  (')')
Status #16 - postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') @ initializerList [ (',') ] ('}') )
  To #18:  initializerList
Status #17 [FINAL] - postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') @ | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
Status #18 - postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList @ [ (',') ] ('}') )
  To #19:  ('}')
  To #20:  (',')
Status #19 [FINAL] - postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') @ )
Status #20 - postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') @ ] ('}') )
  To #19:  ('}')

** Rule: primaryExpression => ( #identifier# | constant | #string# | ('(') expression (')') )
-- Tokens: #string# '(' #identifier# #ushort# #short# #uchar# #char# #int# #uint# #long# #ulong# #float# #double#
-- First-set tokens: #double# #float# #ulong# #long# #uint# #int# #char# #uchar# #short# #ushort# #identifier# '(' #string#
-- First-set rules: constant
Status #0 - primaryExpression => @ ( #identifier# | constant | #string# | ('(') expression (')') )
  To #1:  ('(')
  To #2:  #identifier#
  To #3:  constant
  To #4:  #string#
Status #1 - primaryExpression => ( #identifier# | constant | #string# | ('(') @ expression (')') )
  To #5:  expression
Status #2 [FINAL] - primaryExpression => ( #identifier# @ | constant | #string# | ('(') expression (')') )
Status #3 [FINAL] - primaryExpression => ( #identifier# | constant @ | #string# | ('(') expression (')') )
Status #4 [FINAL] - primaryExpression => ( #identifier# | constant | #string# @ | ('(') expression (')') )
Status #5 - primaryExpression => ( #identifier# | constant | #string# | ('(') expression @ (')') )
  To #6:  (')')
Status #6 [FINAL] - primaryExpression => ( #identifier# | constant | #string# | ('(') expression (')') @ )

** Rule: program => compilationUnit
-- Tokens: static typedef auto signed #identifier# const short void double unsigned float long int enum struct union bool volatile char '(' register '^' extern ';' '*'
-- First-set tokens: '*' ';' extern '^' register '(' char volatile bool union struct enum int long float unsigned double void short const #identifier# signed auto typedef static
-- First-set rules: compilationUnit
Status #0 - program => @ compilationUnit
  To #1:  compilationUnit
Status #1 [FINAL] - program => compilationUnit @

** Rule: relationalExpression => [ relationalExpression ( '<' | '>' | '<=' | '>=' ) ] shiftExpression
-- Tokens: #double# '&' '*' #uint# '+' #uchar# #float# '~' #short# '(' '-' #ushort# '++' '--' '!' #int# #char# sizeof #string# #identifier# #long# #ulong#
-- First-set tokens: #double# #uint# #uchar# #float# '~' '+' #short# '(' #ushort# '++' '--' '!' '-' #int# #char# sizeof #string# '&' #identifier# '*' #long# #ulong#
-- First-set rules: shiftExpression relationalExpression
Status #0 - relationalExpression => [ @ relationalExpression ( '<' | '>' | '<=' | '>=' ) ] shiftExpression
  To #1:  relationalExpression
  To #2:  shiftExpression
Status #1 - relationalExpression => [ relationalExpression @ ( '<' | '>' | '<=' | '>=' ) ] shiftExpression
  To #3:  '>='
  To #4:  '<'
  To #5:  '>'
  To #6:  '<='
Status #2 [FINAL] - relationalExpression => [ relationalExpression ( '<' | '>' | '<=' | '>=' ) ] shiftExpression @
Status #3 - relationalExpression => [ relationalExpression ( '<' | '>' | '<=' | '>=' @ ) ] shiftExpression
  To #2:  shiftExpression
Status #4 - relationalExpression => [ relationalExpression ( '<' @ | '>' | '<=' | '>=' ) ] shiftExpression
  To #2:  shiftExpression
Status #5 - relationalExpression => [ relationalExpression ( '<' | '>' @ | '<=' | '>=' ) ] shiftExpression
  To #2:  shiftExpression
Status #6 - relationalExpression => [ relationalExpression ( '<' | '>' | '<=' @ | '>=' ) ] shiftExpression
  To #2:  shiftExpression

** Rule: selectionStatement => ( if ('(') expression (')') statement [ else statement ] | switch ('(') expression (')') statement )
-- Tokens: if switch
-- First-set tokens: switch if
-- First-set rules:
Status #0 - selectionStatement => @ ( if ('(') expression (')') statement [ else statement ] | switch ('(') expression (')') statement )
  To #1:  switch
  To #2:  if
Status #1 - selectionStatement => ( if ('(') expression (')') statement [ else statement ] | switch @ ('(') expression (')') statement )
  To #3:  ('(')
Status #2 - selectionStatement => ( if @ ('(') expression (')') statement [ else statement ] | switch ('(') expression (')') statement )
  To #4:  ('(')
Status #3 - selectionStatement => ( if ('(') expression (')') statement [ else statement ] | switch ('(') @ expression (')') statement )
  To #5:  expression
Status #4 - selectionStatement => ( if ('(') @ expression (')') statement [ else statement ] | switch ('(') expression (')') statement )
  To #6:  expression
Status #5 - selectionStatement => ( if ('(') expression (')') statement [ else statement ] | switch ('(') expression @ (')') statement )
  To #7:  (')')
Status #6 - selectionStatement => ( if ('(') expression @ (')') statement [ else statement ] | switch ('(') expression (')') statement )
  To #8:  (')')
Status #7 - selectionStatement => ( if ('(') expression (')') statement [ else statement ] | switch ('(') expression (')') @ statement )
  To #9:  statement
Status #8 - selectionStatement => ( if ('(') expression (')') @ statement [ else statement ] | switch ('(') expression (')') statement )
  To #10:  statement
Status #9 [FINAL] - selectionStatement => ( if ('(') expression (')') statement [ else statement ] | switch ('(') expression (')') statement @ )
Status #10 [FINAL] - selectionStatement => ( if ('(') expression (')') statement @ [ else statement ] | switch ('(') expression (')') statement )
  To #11:  else
Status #11 - selectionStatement => ( if ('(') expression (')') statement [ else @ statement ] | switch ('(') expression (')') statement )
  To #12:  statement
Status #12 [FINAL] - selectionStatement => ( if ('(') expression (')') statement [ else statement @ ] | switch ('(') expression (')') statement )

** Rule: shiftExpression => [ shiftExpression ( '<<' | '>>' ) ] additiveExpression
-- Tokens: #double# '&' '*' #uint# '+' #uchar# #float# '~' #short# '(' '-' #ushort# '++' '--' '!' #int# #char# sizeof #string# #identifier# #long# #ulong#
-- First-set tokens: #double# #uint# #uchar# #float# '~' '+' #short# '(' #ushort# '++' '--' '!' '-' #int# #char# sizeof #string# '&' #identifier# '*' #long# #ulong#
-- First-set rules: additiveExpression shiftExpression
Status #0 - shiftExpression => [ @ shiftExpression ( '<<' | '>>' ) ] additiveExpression
  To #1:  shiftExpression
  To #2:  additiveExpression
Status #1 - shiftExpression => [ shiftExpression @ ( '<<' | '>>' ) ] additiveExpression
  To #3:  '>>'
  To #4:  '<<'
Status #2 [FINAL] - shiftExpression => [ shiftExpression ( '<<' | '>>' ) ] additiveExpression @
Status #3 - shiftExpression => [ shiftExpression ( '<<' | '>>' @ ) ] additiveExpression
  To #2:  additiveExpression
Status #4 - shiftExpression => [ shiftExpression ( '<<' @ | '>>' ) ] additiveExpression
  To #2:  additiveExpression

** Rule: specifierQualifierList => ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
-- Tokens: volatile const short signed #identifier# void unsigned float long char bool int enum double struct union
-- First-set tokens: union struct double enum int bool char long float unsigned void #identifier# signed short const volatile
-- First-set rules: typeQualifier typeSpecifier
Status #0 - specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
  To #1:  typeQualifier
  To #2:  typeSpecifier
Status #1 [FINAL] - specifierQualifierList => ( typeSpecifier | typeQualifier @ ) [ specifierQualifierList ]
  To #3:  specifierQualifierList
Status #2 [FINAL] - specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
  To #3:  specifierQualifierList
Status #3 [FINAL] - specifierQualifierList => ( typeSpecifier | typeQualifier ) [ specifierQualifierList @ ]

** Rule: statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationStatement | jumpStatement )
-- Tokens: '{' switch return continue while '(' #identifier# default case ';' '*' #long# goto #float# for #ulong# #int# break '-' '!' do '&' #char# '~' sizeof #string# '--' '++' #ushort# if #double# #short# '+' #uchar# #uint#
-- First-set tokens: #uint# #uchar# '+' #short# #double# #ushort# '++' '--' #string# sizeof #char# '!' '-' #int# #ulong# '~' #float# #long# '*' ';' case default '&' #identifier# '(' for do while goto continue return break switch if '{'
-- First-set rules: jumpStatement iterationStatement labeledStatement selectionStatement compoundStatement expressionStatement
Status #0 - statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationStatement | jumpStatement )
  To #1:  jumpStatement
  To #2:  labeledStatement
  To #3:  compoundStatement
  To #4:  expressionStatement
  To #5:  selectionStatement
  To #6:  iterationStatement
Status #1 [FINAL] - statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationStatement | jumpStatement @ )
Status #2 [FINAL] - statement => ( labeledStatement @ | compoundStatement | expressionStatement | selectionStatement | iterationStatement | jumpStatement )
Status #3 [FINAL] - statement => ( labeledStatement | compoundStatement @ | expressionStatement | selectionStatement | iterationStatement | jumpStatement )
Status #4 [FINAL] - statement => ( labeledStatement | compoundStatement | expressionStatement @ | selectionStatement | iterationStatement | jumpStatement )
Status #5 [FINAL] - statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement @ | iterationStatement | jumpStatement )
Status #6 [FINAL] - statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationStatement @ | jumpStatement )

** Rule: storageClassSpecifier => ( typedef | extern | static | auto | register )
-- Tokens: auto static extern typedef register
-- First-set tokens: register typedef extern static auto
-- First-set rules:
Status #0 - storageClassSpecifier => @ ( typedef | extern | static | auto | register )
  To #1:  register
  To #2:  typedef
  To #3:  extern
  To #4:  static
  To #5:  auto
Status #1 [FINAL] - storageClassSpecifier => ( typedef | extern | static | auto | register @ )
Status #2 [FINAL] - storageClassSpecifier => ( typedef @ | extern | static | auto | register )
Status #3 [FINAL] - storageClassSpecifier => ( typedef | extern @ | static | auto | register )
Status #4 [FINAL] - storageClassSpecifier => ( typedef | extern | static @ | auto | register )
Status #5 [FINAL] - storageClassSpecifier => ( typedef | extern | static | auto @ | register )

** Rule: structDeclaration => specifierQualifierList [ structDeclaratorList ] (';')
-- Tokens: volatile const short signed #identifier# void unsigned float long char bool int enum double struct union
-- First-set tokens: union struct double enum int bool char long float unsigned void #identifier# signed short const volatile
-- First-set rules: specifierQualifierList
Status #0 - structDeclaration => @ specifierQualifierList [ structDeclaratorList ] (';')
  To #1:  specifierQualifierList
Status #1 - structDeclaration => specifierQualifierList @ [ structDeclaratorList ] (';')
  To #2:  (';')
  To #3:  structDeclaratorList
Status #2 [FINAL] - structDeclaration => specifierQualifierList [ structDeclaratorList ] (';') @
Status #3 - structDeclaration => specifierQualifierList [ structDeclaratorList @ ] (';')
  To #2:  (';')

** Rule: structDeclarationList => [ structDeclarationList ] structDeclaration
-- Tokens: volatile const short signed #identifier# void unsigned float long char bool int enum double struct union
-- First-set tokens: volatile const short signed void unsigned float long char bool #identifier# int enum double struct union
-- First-set rules: structDeclaration structDeclarationList
Status #0 - structDeclarationList => [ @ structDeclarationList ] structDeclaration
  To #1:  structDeclarationList
  To #2:  structDeclaration
Status #1 - structDeclarationList => [ structDeclarationList @ ] structDeclaration
  To #2:  structDeclaration
Status #2 [FINAL] - structDeclarationList => [ structDeclarationList ] structDeclaration @

** Rule: structDeclarator => ( declarator | [ declarator ] ('=') constantExpression )
-- Tokens: '=' '(' '*' #identifier# '^' const volatile
-- First-set tokens: volatile const '^' #identifier# '*' '(' '='
-- First-set rules: declarator
Status #0 - structDeclarator => @ ( declarator | [ declarator ] ('=') constantExpression )
  To #1:  ('=')
  To #2:  declarator
  To #3:  declarator
Status #1 - structDeclarator => ( declarator | [ declarator ] ('=') @ constantExpression )
  To #4:  constantExpression
Status #2 [FINAL] - structDeclarator => ( declarator @ | [ declarator ] ('=') constantExpression )
Status #3 - structDeclarator => ( declarator | [ declarator @ ] ('=') constantExpression )
  To #1:  ('=')
Status #4 [FINAL] - structDeclarator => ( declarator | [ declarator ] ('=') constantExpression @ )

** Rule: structDeclaratorList => [ structDeclaratorList (',') ] structDeclarator
-- Tokens: '=' '(' '*' #identifier# '^' const volatile
-- First-set tokens: '=' '(' '*' #identifier# '^' const volatile
-- First-set rules: structDeclarator structDeclaratorList
Status #0 - structDeclaratorList => [ @ structDeclaratorList (',') ] structDeclarator
  To #1:  structDeclaratorList
  To #2:  structDeclarator
Status #1 - structDeclaratorList => [ structDeclaratorList @ (',') ] structDeclarator
  To #3:  (',')
Status #2 [FINAL] - structDeclaratorList => [ structDeclaratorList (',') ] structDeclarator @
Status #3 - structDeclaratorList => [ structDeclaratorList (',') @ ] structDeclarator
  To #2:  structDeclarator

** Rule: structOrUnion => ( struct | union )
-- Tokens: struct union
-- First-set tokens: union struct
-- First-set rules:
Status #0 - structOrUnion => @ ( struct | union )
  To #1:  union
  To #2:  struct
Status #1 [FINAL] - structOrUnion => ( struct | union @ )
Status #2 [FINAL] - structOrUnion => ( struct @ | union )

** Rule: structOrUnionSpecifier => structOrUnion ( #identifier# | [ #identifier# ] ('{') structDeclarationList ('}') )
-- Tokens: struct union
-- First-set tokens: union struct
-- First-set rules: structOrUnion
Status #0 - structOrUnionSpecifier => @ structOrUnion ( #identifier# | [ #identifier# ] ('{') structDeclarationList ('}') )
  To #1:  structOrUnion
Status #1 - structOrUnionSpecifier => structOrUnion @ ( #identifier# | [ #identifier# ] ('{') structDeclarationList ('}') )
  To #2:  ('{')
  To #3:  #identifier#
  To #4:  #identifier#
Status #2 - structOrUnionSpecifier => structOrUnion ( #identifier# | [ #identifier# ] ('{') @ structDeclarationList ('}') )
  To #5:  structDeclarationList
Status #3 [FINAL] - structOrUnionSpecifier => structOrUnion ( #identifier# @ | [ #identifier# ] ('{') structDeclarationList ('}') )
Status #4 - structOrUnionSpecifier => structOrUnion ( #identifier# | [ #identifier# @ ] ('{') structDeclarationList ('}') )
  To #2:  ('{')
Status #5 - structOrUnionSpecifier => structOrUnion ( #identifier# | [ #identifier# ] ('{') structDeclarationList @ ('}') )
  To #6:  ('}')
Status #6 [FINAL] - structOrUnionSpecifier => structOrUnion ( #identifier# | [ #identifier# ] ('{') structDeclarationList ('}') @ )

** Rule: translationUnit => [ translationUnit ] externalDeclaration
-- Tokens: static typedef auto signed #identifier# const short void double unsigned float long int enum struct union bool volatile char '(' register '^' extern ';' '*'
-- First-set tokens: static typedef auto signed const short void double unsigned float long int struct union bool #identifier# volatile char '(' register '^' extern enum ';' '*'
-- First-set rules: externalDeclaration translationUnit
Status #0 - translationUnit => [ @ translationUnit ] externalDeclaration
  To #1:  translationUnit
  To #2:  externalDeclaration
Status #1 - translationUnit => [ translationUnit @ ] externalDeclaration
  To #2:  externalDeclaration
Status #2 [FINAL] - translationUnit => [ translationUnit ] externalDeclaration @

** Rule: typeName => specifierQualifierList [ abstractDeclarator ]
-- Tokens: volatile const short signed #identifier# void unsigned float long char bool int enum double struct union
-- First-set tokens: union struct double enum int bool char long float unsigned void #identifier# signed short const volatile
-- First-set rules: specifierQualifierList
Status #0 - typeName => @ specifierQualifierList [ abstractDeclarator ]
  To #1:  specifierQualifierList
Status #1 [FINAL] - typeName => specifierQualifierList @ [ abstractDeclarator ]
  To #2:  abstractDeclarator
Status #2 [FINAL] - typeName => specifierQualifierList [ abstractDeclarator @ ]

** Rule: typeQualifier => ( const | volatile )
-- Tokens: const volatile
-- First-set tokens: volatile const
-- First-set rules:
Status #0 - typeQualifier => @ ( const | volatile )
  To #1:  volatile
  To #2:  const
Status #1 [FINAL] - typeQualifier => ( const | volatile @ )
Status #2 [FINAL] - typeQualifier => ( const @ | volatile )

** Rule: typeQualifierList => [ typeQualifierList ] typeQualifier
-- Tokens: const volatile
-- First-set tokens: const volatile
-- First-set rules: typeQualifier typeQualifierList
Status #0 - typeQualifierList => [ @ typeQualifierList ] typeQualifier
  To #1:  typeQualifierList
  To #2:  typeQualifier
Status #1 - typeQualifierList => [ typeQualifierList @ ] typeQualifier
  To #2:  typeQualifier
Status #2 [FINAL] - typeQualifierList => [ typeQualifierList ] typeQualifier @

** Rule: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
-- Tokens: signed #identifier# void unsigned float long short char bool int enum double struct union
-- First-set tokens: bool signed #identifier# unsigned double void float long short char int enum struct union
-- First-set rules: typeSpecifier typedefName enumSpecifier structOrUnionSpecifier
Status #0 - typeSpecifier => @ ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
  To #1:  typeSpecifier
  To #2:  void
  To #3:  char
  To #4:  short
  To #5:  int
  To #6:  long
  To #7:  float
  To #8:  double
  To #9:  signed
  To #10:  unsigned
  To #11:  bool
  To #12:  structOrUnionSpecifier
  To #13:  enumSpecifier
  To #14:  typedefName
Status #1 - typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )
  To #15:  pointer
Status #2 [FINAL] - typeSpecifier => ( void @ | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
Status #3 [FINAL] - typeSpecifier => ( void | char @ | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
Status #4 [FINAL] - typeSpecifier => ( void | char | short @ | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
Status #5 [FINAL] - typeSpecifier => ( void | char | short | int @ | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
Status #6 [FINAL] - typeSpecifier => ( void | char | short | int | long @ | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
Status #7 [FINAL] - typeSpecifier => ( void | char | short | int | long | float @ | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
Status #8 [FINAL] - typeSpecifier => ( void | char | short | int | long | float | double @ | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
Status #9 [FINAL] - typeSpecifier => ( void | char | short | int | long | float | double | signed @ | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
Status #10 [FINAL] - typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned @ | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
Status #11 [FINAL] - typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool @ | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
Status #12 [FINAL] - typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier @ | enumSpecifier | typedefName | typeSpecifier pointer )
Status #13 [FINAL] - typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier @ | typedefName | typeSpecifier pointer )
Status #14 [FINAL] - typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName @ | typeSpecifier pointer )
Status #15 [FINAL] - typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer @ )

** Rule: typedefName => #identifier#
-- Tokens: #identifier#
-- First-set tokens: #identifier#
-- First-set rules:
Status #0 - typedefName => @ #identifier#
  To #1:  #identifier#
Status #1 [FINAL] - typedefName => #identifier# @

** Rule: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
-- Tokens: '&' #double# '*' #uint# '+' #uchar# '~' #short# '-' '(' #ushort# '++' '--' '!' sizeof #string# #identifier# #char# #int# #long# #ulong# #float#
-- First-set tokens: #float# #ulong# #long# #int# #char# #identifier# #string# sizeof '!' '--' '++' #ushort# '(' '-' #short# '~' #uchar# '+' #uint# '*' #double# '&'
-- First-set rules: unaryOperator postfixExpression
Status #0 - unaryExpression => @ ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
  To #1:  '--'
  To #2:  postfixExpression
  To #3:  unaryOperator
  To #4:  sizeof
  To #5:  '++'
Status #1 - unaryExpression => ( postfixExpression | ( '++' | '--' @ ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
  To #6:  unaryExpression
Status #2 [FINAL] - unaryExpression => ( postfixExpression @ | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
Status #3 - unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator @ castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
  To #7:  castExpression
Status #4 - unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof @ ( unaryExpression | ('(') typeName (')') ) )
  To #8:  ('(')
  To #9:  unaryExpression
Status #5 - unaryExpression => ( postfixExpression | ( '++' @ | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
  To #6:  unaryExpression
Status #6 [FINAL] - unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression @ | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
Status #7 [FINAL] - unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression @ | sizeof ( unaryExpression | ('(') typeName (')') ) )
Status #8 - unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') @ typeName (')') ) )
  To #10:  typeName
Status #9 [FINAL] - unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression @ | ('(') typeName (')') ) )
Status #10 - unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName @ (')') ) )
  To #11:  (')')
Status #11 [FINAL] - unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') @ ) )

** Rule: unaryOperator => ( '&' | '*' | '+' | '-' | '~' | '!' )
-- Tokens: '-' '~' '+' '*' '&' '!'
-- First-set tokens: '!' '&' '*' '+' '~' '-'
-- First-set rules:
Status #0 - unaryOperator => @ ( '&' | '*' | '+' | '-' | '~' | '!' )
  To #1:  '!'
  To #2:  '&'
  To #3:  '*'
  To #4:  '+'
  To #5:  '-'
  To #6:  '~'
Status #1 [FINAL] - unaryOperator => ( '&' | '*' | '+' | '-' | '~' | '!' @ )
Status #2 [FINAL] - unaryOperator => ( '&' @ | '*' | '+' | '-' | '~' | '!' )
Status #3 [FINAL] - unaryOperator => ( '&' | '*' @ | '+' | '-' | '~' | '!' )
Status #4 [FINAL] - unaryOperator => ( '&' | '*' | '+' @ | '-' | '~' | '!' )
Status #5 [FINAL] - unaryOperator => ( '&' | '*' | '+' | '-' @ | '~' | '!' )
Status #6 [FINAL] - unaryOperator => ( '&' | '*' | '+' | '-' | '~' @ | '!' )

==== PDA  ====
** [Initial] State: compilationUnit => @ translationUnit [ compilationUnit ]

** State #0: compilationUnit => @ translationUnit [ compilationUnit ]
    --> __________________
    --> #1: translationUnit => [ @ translationUnit ] externalDeclaration
    -->     Type: shift
    -->     LA: enum '*' ';' extern '^'
    -->     LA: register '(' char volatile bool
    -->     LA: union struct int long float
    -->     LA: unsigned double void short #identifier#
    -->     LA: const signed auto typedef static

** State #1: translationUnit => [ @ translationUnit ] externalDeclaration
    --> __________________
    --> #2: externalDeclaration => @ ( functionDefinition | declaration | (';') )
    -->     Type: shift
    -->     LA: static typedef auto signed #identifier#
    -->     LA: const short void double unsigned
    -->     LA: float long int enum struct
    -->     LA: union bool volatile char '('
    -->     LA: register '^' extern ';' '*'

** State #2: externalDeclaration => @ ( functionDefinition | declaration | (';') )
    --> __________________
    --> #3: externalDeclaration => ( functionDefinition | declaration | (';') @ )
    -->     Type: pass
    -->     LA: ';'
    --> __________________
    --> #4: functionDefinition => [ @ declarationSpecifiers ] declarator [ declarationList ] compoundStatement
    -->     Type: shift
    -->     LA: volatile '(' char const #identifier#
    -->     LA: '^' register '*' extern union
    -->     LA: bool struct enum int long
    -->     LA: float unsigned double void short
    -->     LA: signed auto typedef static
    --> __________________
    --> #5: declaration => @ declarationSpecifiers [ initDeclaratorList ] (';')
    -->     Type: shift
    -->     LA: union struct enum int bool
    -->     LA: char long float unsigned double
    -->     LA: void short const volatile #identifier#
    -->     LA: signed auto static extern typedef
    -->     LA: register

** [FINAL] State #3: externalDeclaration => ( functionDefinition | declaration | (';') @ )
    --> __________________
    --> #6: translationUnit => [ translationUnit ] externalDeclaration @
    -->     Type: reduce
    -->     Reduce: translationUnit => [ @ translationUnit ] externalDeclaration
    --> __________________
    --> #6: translationUnit => [ translationUnit ] externalDeclaration @
    -->     Type: reduce
    -->     Reduce: translationUnit => [ translationUnit @ ] externalDeclaration

** State #4: functionDefinition => [ @ declarationSpecifiers ] declarator [ declarationList ] compoundStatement
    --> __________________
    --> #7: declarationSpecifiers => [ @ declarationSpecifiers ] declarationSpecifier
    -->     Type: shift
    -->     LA: register typedef extern static auto
    -->     LA: signed #identifier# volatile const short
    -->     LA: void double unsigned float long
    -->     LA: char bool int enum struct
    -->     LA: union
    --> __________________
    --> #8: declarator => [ @ pointer ] directDeclarator
    -->     Type: shift
    -->     LA: '(' '*' #identifier# '^' const
    -->     LA: volatile

** State #5: declaration => @ declarationSpecifiers [ initDeclaratorList ] (';')
    --> __________________
    --> #7: declarationSpecifiers => [ @ declarationSpecifiers ] declarationSpecifier
    -->     Type: shift
    -->     LA: register typedef extern static auto
    -->     LA: signed #identifier# volatile const short
    -->     LA: void double unsigned float long
    -->     LA: char bool int enum struct
    -->     LA: union

** [FINAL] State #6: translationUnit => [ translationUnit ] externalDeclaration @
    --> __________________
    --> #9: compilationUnit => translationUnit @ [ compilationUnit ]
    -->     Type: reduce
    -->     Reduce: compilationUnit => @ translationUnit [ compilationUnit ]
    --> __________________
    --> #10: translationUnit => [ translationUnit @ ] externalDeclaration
    -->     Type: recursion
    -->     LA: static typedef auto signed #identifier#
    -->     LA: const short void double unsigned
    -->     LA: float long int enum struct
    -->     LA: union bool volatile char '('
    -->     LA: register '^' extern ';' '*'

** State #7: declarationSpecifiers => [ @ declarationSpecifiers ] declarationSpecifier
    --> __________________
    --> #11: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    -->     Type: shift
    -->     LA: union struct enum int bool
    -->     LA: char long float unsigned double
    -->     LA: void short const volatile #identifier#
    -->     LA: signed auto static extern typedef
    -->     LA: register

** State #8: declarator => [ @ pointer ] directDeclarator
    --> __________________
    --> #12: pointer => [ @ typeQualifierList ] [ pointer ] ( '*' | '^' )
    -->     Type: shift
    -->     LA: volatile const '^' '*'
    --> __________________
    --> #13: directDeclarator => @ ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    -->     Type: shift
    -->     LA: #identifier# '('

** [FINAL] State #9: compilationUnit => translationUnit @ [ compilationUnit ]
    --> __________________
    --> #0: compilationUnit => @ translationUnit [ compilationUnit ]
    -->     Type: shift
    -->     LA: static typedef auto signed #identifier#
    -->     LA: const short void double unsigned
    -->     LA: float long int enum struct
    -->     LA: union bool volatile char '('
    -->     LA: register '^' extern ';' '*'
    --> __________________
    --> #14: compilationUnit => translationUnit [ compilationUnit @ ]
    -->     Type: reduce
    -->     Reduce: compilationUnit => translationUnit @ [ compilationUnit ]
    --> __________________
    --> #15: program => compilationUnit @
    -->     Type: reduce
    -->     Reduce: compilationUnit => @ translationUnit [ compilationUnit ]
    --> __________________
    --> #9: compilationUnit => translationUnit @ [ compilationUnit ]
    -->     Type: finish

** State #10: translationUnit => [ translationUnit @ ] externalDeclaration
    --> __________________
    --> #2: externalDeclaration => @ ( functionDefinition | declaration | (';') )
    -->     Type: shift
    -->     LA: static typedef auto signed #identifier#
    -->     LA: const short void double unsigned
    -->     LA: float long int enum struct
    -->     LA: union bool volatile char '('
    -->     LA: register '^' extern ';' '*'

** State #11: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #16: typeQualifier => @ ( const | volatile )
    -->     Type: shift
    -->     LA: const volatile
    --> __________________
    --> #17: storageClassSpecifier => @ ( typedef | extern | static | auto | register )
    -->     Type: shift
    -->     LA: auto static extern typedef register
    --> __________________
    --> #18: typeSpecifier => @ ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    -->     Type: shift
    -->     LA: union enum char short long
    -->     LA: void struct double float unsigned
    -->     LA: #identifier# signed int bool

** State #12: pointer => [ @ typeQualifierList ] [ pointer ] ( '*' | '^' )
    --> __________________
    --> #19: typeQualifierList => [ @ typeQualifierList ] typeQualifier
    -->     Type: shift
    -->     LA: volatile const
    --> __________________
    --> #20: pointer => [ typeQualifierList ] [ pointer ] ( '*' @ | '^' )
    -->     Type: move
    -->     LA: '*'
    --> __________________
    --> #21: pointer => [ typeQualifierList ] [ pointer ] ( '*' | '^' @ )
    -->     Type: move
    -->     LA: '^'

** State #13: directDeclarator => @ ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    --> __________________
    --> #22: directDeclarator => ( #identifier# @ | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    -->     Type: move
    -->     LA: #identifier#
    --> __________________
    --> #23: directDeclarator => ( #identifier# | ('(') @ declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    -->     Type: pass
    -->     LA: '('

** [FINAL] State #14: compilationUnit => translationUnit [ compilationUnit @ ]
    --> __________________
    --> #14: compilationUnit => translationUnit [ compilationUnit @ ]
    -->     Type: reduce
    -->     Reduce: compilationUnit => translationUnit @ [ compilationUnit ]
    --> __________________
    --> #15: program => compilationUnit @
    -->     Type: reduce
    -->     Reduce: compilationUnit => @ translationUnit [ compilationUnit ]
    --> __________________
    --> #14: compilationUnit => translationUnit [ compilationUnit @ ]
    -->     Type: finish

** [FINAL] State #15: program => compilationUnit @

** State #16: typeQualifier => @ ( const | volatile )
    --> __________________
    --> #24: typeQualifier => ( const | volatile @ )
    -->     Type: move
    -->     LA: volatile
    --> __________________
    --> #25: typeQualifier => ( const @ | volatile )
    -->     Type: move
    -->     LA: const

** State #17: storageClassSpecifier => @ ( typedef | extern | static | auto | register )
    --> __________________
    --> #26: storageClassSpecifier => ( typedef | extern | static | auto | register @ )
    -->     Type: move
    -->     LA: register
    --> __________________
    --> #27: storageClassSpecifier => ( typedef @ | extern | static | auto | register )
    -->     Type: move
    -->     LA: typedef
    --> __________________
    --> #28: storageClassSpecifier => ( typedef | extern @ | static | auto | register )
    -->     Type: move
    -->     LA: extern
    --> __________________
    --> #29: storageClassSpecifier => ( typedef | extern | static @ | auto | register )
    -->     Type: move
    -->     LA: static
    --> __________________
    --> #30: storageClassSpecifier => ( typedef | extern | static | auto @ | register )
    -->     Type: move
    -->     LA: auto

** State #18: typeSpecifier => @ ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    --> __________________
    --> #31: typeSpecifier => ( void @ | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    -->     Type: move
    -->     LA: void
    --> __________________
    --> #32: typeSpecifier => ( void | char @ | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    -->     Type: move
    -->     LA: char
    --> __________________
    --> #33: typeSpecifier => ( void | char | short @ | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    -->     Type: move
    -->     LA: short
    --> __________________
    --> #34: typeSpecifier => ( void | char | short | int @ | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    -->     Type: move
    -->     LA: int
    --> __________________
    --> #35: typeSpecifier => ( void | char | short | int | long @ | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    -->     Type: move
    -->     LA: long
    --> __________________
    --> #36: typeSpecifier => ( void | char | short | int | long | float @ | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    -->     Type: move
    -->     LA: float
    --> __________________
    --> #37: typeSpecifier => ( void | char | short | int | long | float | double @ | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    -->     Type: move
    -->     LA: double
    --> __________________
    --> #38: typeSpecifier => ( void | char | short | int | long | float | double | signed @ | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    -->     Type: move
    -->     LA: signed
    --> __________________
    --> #39: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned @ | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    -->     Type: move
    -->     LA: unsigned
    --> __________________
    --> #40: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool @ | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    -->     Type: move
    -->     LA: bool
    --> __________________
    --> #41: structOrUnionSpecifier => @ structOrUnion ( #identifier# | [ #identifier# ] ('{') structDeclarationList ('}') )
    -->     Type: shift
    -->     LA: struct union
    --> __________________
    --> #42: enumSpecifier => @ (enum) ( [ #identifier# ] ('{') enumeratorList [ (',') ] ('{') | #identifier# )
    -->     Type: shift
    -->     LA: enum
    --> __________________
    --> #43: typedefName => @ #identifier#
    -->     Type: shift
    -->     LA: #identifier#

** State #19: typeQualifierList => [ @ typeQualifierList ] typeQualifier
    --> __________________
    --> #16: typeQualifier => @ ( const | volatile )
    -->     Type: shift
    -->     LA: const volatile

** [FINAL] State #20: pointer => [ typeQualifierList ] [ pointer ] ( '*' @ | '^' )
    --> __________________
    --> #44: abstractDeclarator => ( pointer @ | [ pointer ] directAbstractDeclarator )
    -->     Type: reduce
    -->     Reduce: abstractDeclarator => @ ( pointer | [ pointer ] directAbstractDeclarator )
    --> __________________
    --> #45: abstractDeclarator => ( pointer | [ pointer @ ] directAbstractDeclarator )
    -->     Type: reduce
    -->     Reduce: abstractDeclarator => @ ( pointer | [ pointer ] directAbstractDeclarator )
    --> __________________
    --> #46: declarator => [ pointer @ ] directDeclarator
    -->     Type: reduce
    -->     Reduce: declarator => [ @ pointer ] directDeclarator
    --> __________________
    --> #47: pointer => [ typeQualifierList ] [ pointer @ ] ( '*' | '^' )
    -->     Type: recursion
    -->     LA: '*' '^'
    --> __________________
    --> #47: pointer => [ typeQualifierList ] [ pointer @ ] ( '*' | '^' )
    -->     Type: reduce
    -->     Reduce: pointer => [ typeQualifierList @ ] [ pointer ] ( '*' | '^' )
    --> __________________
    --> #48: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer @ )
    -->     Type: reduce
    -->     Reduce: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )

** [FINAL] State #21: pointer => [ typeQualifierList ] [ pointer ] ( '*' | '^' @ )
    --> __________________
    --> #44: abstractDeclarator => ( pointer @ | [ pointer ] directAbstractDeclarator )
    -->     Type: reduce
    -->     Reduce: abstractDeclarator => @ ( pointer | [ pointer ] directAbstractDeclarator )
    --> __________________
    --> #45: abstractDeclarator => ( pointer | [ pointer @ ] directAbstractDeclarator )
    -->     Type: reduce
    -->     Reduce: abstractDeclarator => @ ( pointer | [ pointer ] directAbstractDeclarator )
    --> __________________
    --> #46: declarator => [ pointer @ ] directDeclarator
    -->     Type: reduce
    -->     Reduce: declarator => [ @ pointer ] directDeclarator
    --> __________________
    --> #47: pointer => [ typeQualifierList ] [ pointer @ ] ( '*' | '^' )
    -->     Type: recursion
    -->     LA: '*' '^'
    --> __________________
    --> #47: pointer => [ typeQualifierList ] [ pointer @ ] ( '*' | '^' )
    -->     Type: reduce
    -->     Reduce: pointer => [ typeQualifierList @ ] [ pointer ] ( '*' | '^' )
    --> __________________
    --> #48: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer @ )
    -->     Type: reduce
    -->     Reduce: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )

** [FINAL] State #22: directDeclarator => ( #identifier# @ | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    --> __________________
    --> #49: declarator => [ pointer ] directDeclarator @
    -->     Type: reduce
    -->     Reduce: declarator => [ @ pointer ] directDeclarator
    --> __________________
    --> #49: declarator => [ pointer ] directDeclarator @
    -->     Type: reduce
    -->     Reduce: declarator => [ pointer @ ] directDeclarator
    --> __________________
    --> #50: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator @ ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    -->     Type: recursion
    -->     LA: '[' '('

** State #23: directDeclarator => ( #identifier# | ('(') @ declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    --> __________________
    --> #8: declarator => [ @ pointer ] directDeclarator
    -->     Type: shift
    -->     LA: '(' '*' #identifier# '^' const
    -->     LA: volatile

** [FINAL] State #24: typeQualifier => ( const | volatile @ )
    --> __________________
    --> #51: declarationSpecifier => ( storageClassSpecifier | typeSpecifier | typeQualifier @ )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #52: specifierQualifierList => ( typeSpecifier | typeQualifier @ ) [ specifierQualifierList ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #53: typeQualifierList => [ typeQualifierList ] typeQualifier @
    -->     Type: reduce
    -->     Reduce: typeQualifierList => [ @ typeQualifierList ] typeQualifier
    --> __________________
    --> #53: typeQualifierList => [ typeQualifierList ] typeQualifier @
    -->     Type: reduce
    -->     Reduce: typeQualifierList => [ typeQualifierList @ ] typeQualifier

** [FINAL] State #25: typeQualifier => ( const @ | volatile )
    --> __________________
    --> #51: declarationSpecifier => ( storageClassSpecifier | typeSpecifier | typeQualifier @ )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #52: specifierQualifierList => ( typeSpecifier | typeQualifier @ ) [ specifierQualifierList ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #53: typeQualifierList => [ typeQualifierList ] typeQualifier @
    -->     Type: reduce
    -->     Reduce: typeQualifierList => [ @ typeQualifierList ] typeQualifier
    --> __________________
    --> #53: typeQualifierList => [ typeQualifierList ] typeQualifier @
    -->     Type: reduce
    -->     Reduce: typeQualifierList => [ typeQualifierList @ ] typeQualifier

** [FINAL] State #26: storageClassSpecifier => ( typedef | extern | static | auto | register @ )
    --> __________________
    --> #54: declarationSpecifier => ( storageClassSpecifier @ | typeSpecifier | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )

** [FINAL] State #27: storageClassSpecifier => ( typedef @ | extern | static | auto | register )
    --> __________________
    --> #54: declarationSpecifier => ( storageClassSpecifier @ | typeSpecifier | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )

** [FINAL] State #28: storageClassSpecifier => ( typedef | extern @ | static | auto | register )
    --> __________________
    --> #54: declarationSpecifier => ( storageClassSpecifier @ | typeSpecifier | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )

** [FINAL] State #29: storageClassSpecifier => ( typedef | extern | static @ | auto | register )
    --> __________________
    --> #54: declarationSpecifier => ( storageClassSpecifier @ | typeSpecifier | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )

** [FINAL] State #30: storageClassSpecifier => ( typedef | extern | static | auto @ | register )
    --> __________________
    --> #54: declarationSpecifier => ( storageClassSpecifier @ | typeSpecifier | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )

** [FINAL] State #31: typeSpecifier => ( void @ | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    --> __________________
    --> #55: declarationSpecifier => ( storageClassSpecifier | typeSpecifier @ | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #56: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #57: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )
    -->     Type: recursion
    -->     LA: volatile const '^' '*'

** [FINAL] State #32: typeSpecifier => ( void | char @ | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    --> __________________
    --> #55: declarationSpecifier => ( storageClassSpecifier | typeSpecifier @ | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #56: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #57: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )
    -->     Type: recursion
    -->     LA: volatile const '^' '*'

** [FINAL] State #33: typeSpecifier => ( void | char | short @ | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    --> __________________
    --> #55: declarationSpecifier => ( storageClassSpecifier | typeSpecifier @ | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #56: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #57: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )
    -->     Type: recursion
    -->     LA: volatile const '^' '*'

** [FINAL] State #34: typeSpecifier => ( void | char | short | int @ | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    --> __________________
    --> #55: declarationSpecifier => ( storageClassSpecifier | typeSpecifier @ | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #56: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #57: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )
    -->     Type: recursion
    -->     LA: volatile const '^' '*'

** [FINAL] State #35: typeSpecifier => ( void | char | short | int | long @ | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    --> __________________
    --> #55: declarationSpecifier => ( storageClassSpecifier | typeSpecifier @ | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #56: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #57: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )
    -->     Type: recursion
    -->     LA: volatile const '^' '*'

** [FINAL] State #36: typeSpecifier => ( void | char | short | int | long | float @ | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    --> __________________
    --> #55: declarationSpecifier => ( storageClassSpecifier | typeSpecifier @ | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #56: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #57: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )
    -->     Type: recursion
    -->     LA: volatile const '^' '*'

** [FINAL] State #37: typeSpecifier => ( void | char | short | int | long | float | double @ | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    --> __________________
    --> #55: declarationSpecifier => ( storageClassSpecifier | typeSpecifier @ | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #56: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #57: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )
    -->     Type: recursion
    -->     LA: volatile const '^' '*'

** [FINAL] State #38: typeSpecifier => ( void | char | short | int | long | float | double | signed @ | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    --> __________________
    --> #55: declarationSpecifier => ( storageClassSpecifier | typeSpecifier @ | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #56: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #57: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )
    -->     Type: recursion
    -->     LA: volatile const '^' '*'

** [FINAL] State #39: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned @ | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    --> __________________
    --> #55: declarationSpecifier => ( storageClassSpecifier | typeSpecifier @ | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #56: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #57: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )
    -->     Type: recursion
    -->     LA: volatile const '^' '*'

** [FINAL] State #40: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool @ | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    --> __________________
    --> #55: declarationSpecifier => ( storageClassSpecifier | typeSpecifier @ | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #56: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #57: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )
    -->     Type: recursion
    -->     LA: volatile const '^' '*'

** State #41: structOrUnionSpecifier => @ structOrUnion ( #identifier# | [ #identifier# ] ('{') structDeclarationList ('}') )
    --> __________________
    --> #58: structOrUnion => @ ( struct | union )
    -->     Type: shift
    -->     LA: struct union

** State #42: enumSpecifier => @ (enum) ( [ #identifier# ] ('{') enumeratorList [ (',') ] ('{') | #identifier# )
    --> __________________
    --> #59: enumSpecifier => (enum) @ ( [ #identifier# ] ('{') enumeratorList [ (',') ] ('{') | #identifier# )
    -->     Type: pass
    -->     LA: enum

** State #43: typedefName => @ #identifier#
    --> __________________
    --> #60: typedefName => #identifier# @
    -->     Type: move
    -->     LA: #identifier#

** [FINAL] State #44: abstractDeclarator => ( pointer @ | [ pointer ] directAbstractDeclarator )
    --> __________________
    --> #61: directAbstractDeclarator => ( ('(') abstractDeclarator @ (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: reduce
    -->     Reduce: directAbstractDeclarator => ( ('(') @ abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #62: parameterDeclaration => ( declarationSpecifiers declarator | declarationSpecifiers2 [ abstractDeclarator @ ] )
    -->     Type: reduce
    -->     Reduce: parameterDeclaration => ( declarationSpecifiers declarator | declarationSpecifiers2 @ [ abstractDeclarator ] )
    --> __________________
    --> #63: typeName => specifierQualifierList [ abstractDeclarator @ ]
    -->     Type: reduce
    -->     Reduce: typeName => specifierQualifierList @ [ abstractDeclarator ]

** State #45: abstractDeclarator => ( pointer | [ pointer @ ] directAbstractDeclarator )
    --> __________________
    --> #64: directAbstractDeclarator => @ ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: shift
    -->     LA: '(' '['

** State #46: declarator => [ pointer @ ] directDeclarator
    --> __________________
    --> #13: directDeclarator => @ ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    -->     Type: shift
    -->     LA: #identifier# '('

** State #47: pointer => [ typeQualifierList ] [ pointer @ ] ( '*' | '^' )
    --> __________________
    --> #21: pointer => [ typeQualifierList ] [ pointer ] ( '*' | '^' @ )
    -->     Type: move
    -->     LA: '^'
    --> __________________
    --> #20: pointer => [ typeQualifierList ] [ pointer ] ( '*' @ | '^' )
    -->     Type: move
    -->     LA: '*'

** [FINAL] State #48: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer @ )
    --> __________________
    --> #55: declarationSpecifier => ( storageClassSpecifier | typeSpecifier @ | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #56: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #57: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )
    -->     Type: recursion
    -->     LA: volatile const '^' '*'

** [FINAL] State #49: declarator => [ pointer ] directDeclarator @
    --> __________________
    --> #65: directDeclarator => ( #identifier# | ('(') declarator @ (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    -->     Type: reduce
    -->     Reduce: directDeclarator => ( #identifier# | ('(') @ declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    --> __________________
    --> #66: functionDefinition => [ declarationSpecifiers ] declarator @ [ declarationList ] compoundStatement
    -->     Type: reduce
    -->     Reduce: functionDefinition => [ @ declarationSpecifiers ] declarator [ declarationList ] compoundStatement
    --> __________________
    --> #66: functionDefinition => [ declarationSpecifiers ] declarator @ [ declarationList ] compoundStatement
    -->     Type: reduce
    -->     Reduce: functionDefinition => [ declarationSpecifiers @ ] declarator [ declarationList ] compoundStatement
    --> __________________
    --> #67: initDeclarator => declarator @ [ ('=') initializer ]
    -->     Type: reduce
    -->     Reduce: initDeclarator => @ declarator [ ('=') initializer ]
    --> __________________
    --> #68: parameterDeclaration => ( declarationSpecifiers declarator @ | declarationSpecifiers2 [ abstractDeclarator ] )
    -->     Type: reduce
    -->     Reduce: parameterDeclaration => ( declarationSpecifiers @ declarator | declarationSpecifiers2 [ abstractDeclarator ] )
    --> __________________
    --> #69: structDeclarator => ( declarator @ | [ declarator ] ('=') constantExpression )
    -->     Type: reduce
    -->     Reduce: structDeclarator => @ ( declarator | [ declarator ] ('=') constantExpression )
    --> __________________
    --> #70: structDeclarator => ( declarator | [ declarator @ ] ('=') constantExpression )
    -->     Type: reduce
    -->     Reduce: structDeclarator => @ ( declarator | [ declarator ] ('=') constantExpression )

** State #50: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator @ ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    --> __________________
    --> #71: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') @ ( parameterTypeList | [ identifierList ] ) (')') ) )
    -->     Type: pass
    -->     LA: '('
    --> __________________
    --> #72: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') @ [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    -->     Type: pass
    -->     LA: '['

** [FINAL] State #51: declarationSpecifier => ( storageClassSpecifier | typeSpecifier | typeQualifier @ )
    --> __________________
    --> #73: declarationSpecifiers => [ declarationSpecifiers ] declarationSpecifier @
    -->     Type: reduce
    -->     Reduce: declarationSpecifiers => [ @ declarationSpecifiers ] declarationSpecifier
    --> __________________
    --> #73: declarationSpecifiers => [ declarationSpecifiers ] declarationSpecifier @
    -->     Type: reduce
    -->     Reduce: declarationSpecifiers => [ declarationSpecifiers @ ] declarationSpecifier
    --> __________________
    --> #74: declarationSpecifiers2 => [ declarationSpecifiers ] declarationSpecifier @
    -->     Type: reduce
    -->     Reduce: declarationSpecifiers2 => [ @ declarationSpecifiers ] declarationSpecifier
    --> __________________
    --> #74: declarationSpecifiers2 => [ declarationSpecifiers ] declarationSpecifier @
    -->     Type: reduce
    -->     Reduce: declarationSpecifiers2 => [ declarationSpecifiers @ ] declarationSpecifier

** [FINAL] State #52: specifierQualifierList => ( typeSpecifier | typeQualifier @ ) [ specifierQualifierList ]
    --> __________________
    --> #75: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    -->     Type: shift
    -->     LA: volatile const short signed #identifier#
    -->     LA: void unsigned float long char
    -->     LA: bool int enum double struct
    -->     LA: union
    --> __________________
    --> #76: specifierQualifierList => ( typeSpecifier | typeQualifier ) [ specifierQualifierList @ ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => ( typeSpecifier | typeQualifier @ ) [ specifierQualifierList ]
    --> __________________
    --> #76: specifierQualifierList => ( typeSpecifier | typeQualifier ) [ specifierQualifierList @ ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #77: structDeclaration => specifierQualifierList @ [ structDeclaratorList ] (';')
    -->     Type: reduce
    -->     Reduce: structDeclaration => @ specifierQualifierList [ structDeclaratorList ] (';')
    --> __________________
    --> #78: typeName => specifierQualifierList @ [ abstractDeclarator ]
    -->     Type: reduce
    -->     Reduce: typeName => @ specifierQualifierList [ abstractDeclarator ]

** [FINAL] State #53: typeQualifierList => [ typeQualifierList ] typeQualifier @
    --> __________________
    --> #79: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList @ ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: reduce
    -->     Reduce: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' @ ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #80: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList @ ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    -->     Type: reduce
    -->     Reduce: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') @ [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    --> __________________
    --> #81: pointer => [ typeQualifierList @ ] [ pointer ] ( '*' | '^' )
    -->     Type: reduce
    -->     Reduce: pointer => [ @ typeQualifierList ] [ pointer ] ( '*' | '^' )
    --> __________________
    --> #82: typeQualifierList => [ typeQualifierList @ ] typeQualifier
    -->     Type: recursion
    -->     LA: const volatile

** [FINAL] State #54: declarationSpecifier => ( storageClassSpecifier @ | typeSpecifier | typeQualifier )
    --> __________________
    --> #73: declarationSpecifiers => [ declarationSpecifiers ] declarationSpecifier @
    -->     Type: reduce
    -->     Reduce: declarationSpecifiers => [ @ declarationSpecifiers ] declarationSpecifier
    --> __________________
    --> #73: declarationSpecifiers => [ declarationSpecifiers ] declarationSpecifier @
    -->     Type: reduce
    -->     Reduce: declarationSpecifiers => [ declarationSpecifiers @ ] declarationSpecifier
    --> __________________
    --> #74: declarationSpecifiers2 => [ declarationSpecifiers ] declarationSpecifier @
    -->     Type: reduce
    -->     Reduce: declarationSpecifiers2 => [ @ declarationSpecifiers ] declarationSpecifier
    --> __________________
    --> #74: declarationSpecifiers2 => [ declarationSpecifiers ] declarationSpecifier @
    -->     Type: reduce
    -->     Reduce: declarationSpecifiers2 => [ declarationSpecifiers @ ] declarationSpecifier

** [FINAL] State #55: declarationSpecifier => ( storageClassSpecifier | typeSpecifier @ | typeQualifier )
    --> __________________
    --> #73: declarationSpecifiers => [ declarationSpecifiers ] declarationSpecifier @
    -->     Type: reduce
    -->     Reduce: declarationSpecifiers => [ @ declarationSpecifiers ] declarationSpecifier
    --> __________________
    --> #73: declarationSpecifiers => [ declarationSpecifiers ] declarationSpecifier @
    -->     Type: reduce
    -->     Reduce: declarationSpecifiers => [ declarationSpecifiers @ ] declarationSpecifier
    --> __________________
    --> #74: declarationSpecifiers2 => [ declarationSpecifiers ] declarationSpecifier @
    -->     Type: reduce
    -->     Reduce: declarationSpecifiers2 => [ @ declarationSpecifiers ] declarationSpecifier
    --> __________________
    --> #74: declarationSpecifiers2 => [ declarationSpecifiers ] declarationSpecifier @
    -->     Type: reduce
    -->     Reduce: declarationSpecifiers2 => [ declarationSpecifiers @ ] declarationSpecifier

** [FINAL] State #56: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #75: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    -->     Type: shift
    -->     LA: volatile const short signed #identifier#
    -->     LA: void unsigned float long char
    -->     LA: bool int enum double struct
    -->     LA: union
    --> __________________
    --> #76: specifierQualifierList => ( typeSpecifier | typeQualifier ) [ specifierQualifierList @ ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => ( typeSpecifier | typeQualifier @ ) [ specifierQualifierList ]
    --> __________________
    --> #76: specifierQualifierList => ( typeSpecifier | typeQualifier ) [ specifierQualifierList @ ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #77: structDeclaration => specifierQualifierList @ [ structDeclaratorList ] (';')
    -->     Type: reduce
    -->     Reduce: structDeclaration => @ specifierQualifierList [ structDeclaratorList ] (';')
    --> __________________
    --> #78: typeName => specifierQualifierList @ [ abstractDeclarator ]
    -->     Type: reduce
    -->     Reduce: typeName => @ specifierQualifierList [ abstractDeclarator ]

** State #57: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )
    --> __________________
    --> #12: pointer => [ @ typeQualifierList ] [ pointer ] ( '*' | '^' )
    -->     Type: shift
    -->     LA: volatile const '^' '*'

** State #58: structOrUnion => @ ( struct | union )
    --> __________________
    --> #83: structOrUnion => ( struct | union @ )
    -->     Type: move
    -->     LA: union
    --> __________________
    --> #84: structOrUnion => ( struct @ | union )
    -->     Type: move
    -->     LA: struct

** State #59: enumSpecifier => (enum) @ ( [ #identifier# ] ('{') enumeratorList [ (',') ] ('{') | #identifier# )
    --> __________________
    --> #85: enumSpecifier => (enum) ( [ #identifier# ] ('{') @ enumeratorList [ (',') ] ('{') | #identifier# )
    -->     Type: pass
    -->     LA: '{'
    --> __________________
    --> #86: enumSpecifier => (enum) ( [ #identifier# @ ] ('{') enumeratorList [ (',') ] ('{') | #identifier# )
    -->     Type: move
    -->     LA: #identifier#
    --> __________________
    --> #87: enumSpecifier => (enum) ( [ #identifier# ] ('{') enumeratorList [ (',') ] ('{') | #identifier# @ )
    -->     Type: move
    -->     LA: #identifier#

** [FINAL] State #60: typedefName => #identifier# @
    --> __________________
    --> #88: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName @ | typeSpecifier pointer )
    -->     Type: reduce
    -->     Reduce: typeSpecifier => @ ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )

** State #61: directAbstractDeclarator => ( ('(') abstractDeclarator @ (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #89: directAbstractDeclarator => ( ('(') abstractDeclarator (')') @ | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: pass
    -->     LA: ')'

** [FINAL] State #62: parameterDeclaration => ( declarationSpecifiers declarator | declarationSpecifiers2 [ abstractDeclarator @ ] )
    --> __________________
    --> #90: parameterList => [ parameterList (',') ] parameterDeclaration @
    -->     Type: reduce
    -->     Reduce: parameterList => [ @ parameterList (',') ] parameterDeclaration
    --> __________________
    --> #90: parameterList => [ parameterList (',') ] parameterDeclaration @
    -->     Type: reduce
    -->     Reduce: parameterList => [ parameterList (',') @ ] parameterDeclaration

** [FINAL] State #63: typeName => specifierQualifierList [ abstractDeclarator @ ]
    --> __________________
    --> #91: castExpression => ( ('(') typeName @ (')') castExpression | unaryExpression )
    -->     Type: reduce
    --> __________________
    --> #92: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName @ (')') ('{') initializerList [ (',') ] ('}') )
    -->     Type: reduce
    --> __________________
    --> #93: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName @ (')') ) )
    -->     Type: reduce

** State #64: directAbstractDeclarator => @ ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #94: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' @ [ parameterTypeList ] ')' ) )
    -->     Type: move
    -->     LA: '('
    --> __________________
    --> #95: directAbstractDeclarator => ( ('(') @ abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: pass
    -->     LA: '('
    --> __________________
    --> #96: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' @ ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: move
    -->     LA: '['

** State #65: directDeclarator => ( #identifier# | ('(') declarator @ (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    --> __________________
    --> #97: directDeclarator => ( #identifier# | ('(') declarator (')') @ | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    -->     Type: pass
    -->     LA: ')'

** State #66: functionDefinition => [ declarationSpecifiers ] declarator @ [ declarationList ] compoundStatement
    --> __________________
    --> #98: compoundStatement => @ ('{') [ blockItemList ] ('}')
    -->     Type: shift
    -->     LA: '{'
    --> __________________
    --> #99: declarationList => [ @ declarationList ] declaration
    -->     Type: shift
    -->     LA: register typedef extern static auto
    -->     LA: signed #identifier# volatile const short
    -->     LA: void double unsigned float long
    -->     LA: char bool int enum struct
    -->     LA: union

** [FINAL] State #67: initDeclarator => declarator @ [ ('=') initializer ]
    --> __________________
    --> #100: initDeclarator => declarator [ ('=') @ initializer ]
    -->     Type: pass
    -->     LA: '='
    --> __________________
    --> #101: initDeclaratorList => [ initDeclaratorList (',') ] initDeclarator @
    -->     Type: reduce
    -->     Reduce: initDeclaratorList => [ @ initDeclaratorList (',') ] initDeclarator
    --> __________________
    --> #101: initDeclaratorList => [ initDeclaratorList (',') ] initDeclarator @
    -->     Type: reduce
    -->     Reduce: initDeclaratorList => [ initDeclaratorList (',') @ ] initDeclarator

** [FINAL] State #68: parameterDeclaration => ( declarationSpecifiers declarator @ | declarationSpecifiers2 [ abstractDeclarator ] )
    --> __________________
    --> #90: parameterList => [ parameterList (',') ] parameterDeclaration @
    -->     Type: reduce
    -->     Reduce: parameterList => [ @ parameterList (',') ] parameterDeclaration
    --> __________________
    --> #90: parameterList => [ parameterList (',') ] parameterDeclaration @
    -->     Type: reduce
    -->     Reduce: parameterList => [ parameterList (',') @ ] parameterDeclaration

** [FINAL] State #69: structDeclarator => ( declarator @ | [ declarator ] ('=') constantExpression )
    --> __________________
    --> #102: structDeclaratorList => [ structDeclaratorList (',') ] structDeclarator @
    -->     Type: reduce
    -->     Reduce: structDeclaratorList => [ @ structDeclaratorList (',') ] structDeclarator
    --> __________________
    --> #102: structDeclaratorList => [ structDeclaratorList (',') ] structDeclarator @
    -->     Type: reduce
    -->     Reduce: structDeclaratorList => [ structDeclaratorList (',') @ ] structDeclarator

** State #70: structDeclarator => ( declarator | [ declarator @ ] ('=') constantExpression )
    --> __________________
    --> #103: structDeclarator => ( declarator | [ declarator ] ('=') @ constantExpression )
    -->     Type: pass
    -->     LA: '='

** State #71: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') @ ( parameterTypeList | [ identifierList ] ) (')') ) )
    --> __________________
    --> #104: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') @ ) )
    -->     Type: pass
    -->     LA: ')'
    --> __________________
    --> #105: parameterTypeList => @ parameterList [ (',') '...' ]
    -->     Type: shift
    -->     LA: union struct enum int bool
    -->     LA: char long float unsigned double
    -->     LA: void short const volatile #identifier#
    -->     LA: signed auto static extern typedef
    -->     LA: register
    --> __________________
    --> #106: identifierList => [ @ identifierList (',') ] #identifier#
    -->     Type: shift
    -->     LA: #identifier#

** State #72: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') @ [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    --> __________________
    --> #107: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' @ ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    -->     Type: move
    -->     LA: '*'
    --> __________________
    --> #19: typeQualifierList => [ @ typeQualifierList ] typeQualifier
    -->     Type: shift
    -->     LA: volatile const
    --> __________________
    --> #108: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExpression )
    -->     Type: shift
    -->     LA: #float# #ulong# #long# #int# #char#
    -->     LA: #identifier# #string# sizeof '!' '--'
    -->     LA: '++' '-' #ushort# '(' #short#
    -->     LA: '~' '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** [FINAL] State #73: declarationSpecifiers => [ declarationSpecifiers ] declarationSpecifier @
    --> __________________
    --> #109: declaration => declarationSpecifiers @ [ initDeclaratorList ] (';')
    -->     Type: reduce
    -->     Reduce: declaration => @ declarationSpecifiers [ initDeclaratorList ] (';')
    --> __________________
    --> #110: declarationSpecifiers => [ declarationSpecifiers @ ] declarationSpecifier
    -->     Type: recursion
    -->     LA: union struct enum int bool
    -->     LA: char long float unsigned double
    -->     LA: void short const volatile #identifier#
    -->     LA: signed auto static extern typedef
    -->     LA: register
    --> __________________
    --> #111: declarationSpecifiers2 => [ declarationSpecifiers @ ] declarationSpecifier
    -->     Type: reduce
    -->     Reduce: declarationSpecifiers2 => [ @ declarationSpecifiers ] declarationSpecifier
    --> __________________
    --> #112: forDeclaration => declarationSpecifiers @ [ initDeclaratorList ]
    -->     Type: reduce
    -->     Reduce: forDeclaration => @ declarationSpecifiers [ initDeclaratorList ]
    --> __________________
    --> #113: functionDefinition => [ declarationSpecifiers @ ] declarator [ declarationList ] compoundStatement
    -->     Type: reduce
    -->     Reduce: functionDefinition => [ @ declarationSpecifiers ] declarator [ declarationList ] compoundStatement
    --> __________________
    --> #114: parameterDeclaration => ( declarationSpecifiers @ declarator | declarationSpecifiers2 [ abstractDeclarator ] )
    -->     Type: reduce
    -->     Reduce: parameterDeclaration => @ ( declarationSpecifiers declarator | declarationSpecifiers2 [ abstractDeclarator ] )

** [FINAL] State #74: declarationSpecifiers2 => [ declarationSpecifiers ] declarationSpecifier @
    --> __________________
    --> #115: parameterDeclaration => ( declarationSpecifiers declarator | declarationSpecifiers2 @ [ abstractDeclarator ] )
    -->     Type: reduce
    -->     Reduce: parameterDeclaration => @ ( declarationSpecifiers declarator | declarationSpecifiers2 [ abstractDeclarator ] )

** State #75: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #16: typeQualifier => @ ( const | volatile )
    -->     Type: shift
    -->     LA: const volatile
    --> __________________
    --> #18: typeSpecifier => @ ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )
    -->     Type: shift
    -->     LA: union enum char short long
    -->     LA: void struct double float unsigned
    -->     LA: #identifier# signed int bool

** [FINAL] State #76: specifierQualifierList => ( typeSpecifier | typeQualifier ) [ specifierQualifierList @ ]
    --> __________________
    --> #76: specifierQualifierList => ( typeSpecifier | typeQualifier ) [ specifierQualifierList @ ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => ( typeSpecifier | typeQualifier @ ) [ specifierQualifierList ]
    --> __________________
    --> #76: specifierQualifierList => ( typeSpecifier | typeQualifier ) [ specifierQualifierList @ ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #77: structDeclaration => specifierQualifierList @ [ structDeclaratorList ] (';')
    -->     Type: reduce
    -->     Reduce: structDeclaration => @ specifierQualifierList [ structDeclaratorList ] (';')
    --> __________________
    --> #78: typeName => specifierQualifierList @ [ abstractDeclarator ]
    -->     Type: reduce
    -->     Reduce: typeName => @ specifierQualifierList [ abstractDeclarator ]

** State #77: structDeclaration => specifierQualifierList @ [ structDeclaratorList ] (';')
    --> __________________
    --> #116: structDeclaration => specifierQualifierList [ structDeclaratorList ] (';') @
    -->     Type: pass
    -->     LA: ';'
    --> __________________
    --> #117: structDeclaratorList => [ @ structDeclaratorList (',') ] structDeclarator
    -->     Type: shift
    -->     LA: volatile const '^' #identifier# '*'
    -->     LA: '(' '='

** [FINAL] State #78: typeName => specifierQualifierList @ [ abstractDeclarator ]
    --> __________________
    --> #118: abstractDeclarator => @ ( pointer | [ pointer ] directAbstractDeclarator )
    -->     Type: shift
    -->     LA: '[' '(' '*' '^' const
    -->     LA: volatile
    --> __________________
    --> #91: castExpression => ( ('(') typeName @ (')') castExpression | unaryExpression )
    -->     Type: reduce
    --> __________________
    --> #92: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName @ (')') ('{') initializerList [ (',') ] ('}') )
    -->     Type: reduce
    --> __________________
    --> #93: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName @ (')') ) )
    -->     Type: reduce

** State #79: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList @ ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #119: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' @ | '(' [ parameterTypeList ] ')' ) )
    -->     Type: move
    -->     LA: ']'
    --> __________________
    --> #108: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExpression )
    -->     Type: shift
    -->     LA: #float# #ulong# #long# #int# #char#
    -->     LA: #identifier# #string# sizeof '!' '--'
    -->     LA: '++' '-' #ushort# '(' #short#
    -->     LA: '~' '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #80: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList @ ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    --> __________________
    --> #107: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' @ ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    -->     Type: move
    -->     LA: '*'
    --> __________________
    --> #108: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExpression )
    -->     Type: shift
    -->     LA: #float# #ulong# #long# #int# #char#
    -->     LA: #identifier# #string# sizeof '!' '--'
    -->     LA: '++' '-' #ushort# '(' #short#
    -->     LA: '~' '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #81: pointer => [ typeQualifierList @ ] [ pointer ] ( '*' | '^' )
    --> __________________
    --> #21: pointer => [ typeQualifierList ] [ pointer ] ( '*' | '^' @ )
    -->     Type: move
    -->     LA: '^'
    --> __________________
    --> #12: pointer => [ @ typeQualifierList ] [ pointer ] ( '*' | '^' )
    -->     Type: shift
    -->     LA: volatile const '^' '*'
    --> __________________
    --> #20: pointer => [ typeQualifierList ] [ pointer ] ( '*' @ | '^' )
    -->     Type: move
    -->     LA: '*'

** State #82: typeQualifierList => [ typeQualifierList @ ] typeQualifier
    --> __________________
    --> #16: typeQualifier => @ ( const | volatile )
    -->     Type: shift
    -->     LA: const volatile

** [FINAL] State #83: structOrUnion => ( struct | union @ )
    --> __________________
    --> #120: structOrUnionSpecifier => structOrUnion @ ( #identifier# | [ #identifier# ] ('{') structDeclarationList ('}') )
    -->     Type: reduce
    -->     Reduce: structOrUnionSpecifier => @ structOrUnion ( #identifier# | [ #identifier# ] ('{') structDeclarationList ('}') )

** [FINAL] State #84: structOrUnion => ( struct @ | union )
    --> __________________
    --> #120: structOrUnionSpecifier => structOrUnion @ ( #identifier# | [ #identifier# ] ('{') structDeclarationList ('}') )
    -->     Type: reduce
    -->     Reduce: structOrUnionSpecifier => @ structOrUnion ( #identifier# | [ #identifier# ] ('{') structDeclarationList ('}') )

** State #85: enumSpecifier => (enum) ( [ #identifier# ] ('{') @ enumeratorList [ (',') ] ('{') | #identifier# )
    --> __________________
    --> #121: enumeratorList => [ @ enumeratorList (',') ] enumerator
    -->     Type: shift
    -->     LA: #identifier#

** State #86: enumSpecifier => (enum) ( [ #identifier# @ ] ('{') enumeratorList [ (',') ] ('{') | #identifier# )
    --> __________________
    --> #85: enumSpecifier => (enum) ( [ #identifier# ] ('{') @ enumeratorList [ (',') ] ('{') | #identifier# )
    -->     Type: pass
    -->     LA: '{'

** [FINAL] State #87: enumSpecifier => (enum) ( [ #identifier# ] ('{') enumeratorList [ (',') ] ('{') | #identifier# @ )
    --> __________________
    --> #122: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier @ | typedefName | typeSpecifier pointer )
    -->     Type: reduce
    -->     Reduce: typeSpecifier => @ ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )

** [FINAL] State #88: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName @ | typeSpecifier pointer )
    --> __________________
    --> #55: declarationSpecifier => ( storageClassSpecifier | typeSpecifier @ | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #56: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #57: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )
    -->     Type: recursion
    -->     LA: volatile const '^' '*'

** [FINAL] State #89: directAbstractDeclarator => ( ('(') abstractDeclarator (')') @ | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #123: abstractDeclarator => ( pointer | [ pointer ] directAbstractDeclarator @ )
    -->     Type: reduce
    -->     Reduce: abstractDeclarator => @ ( pointer | [ pointer ] directAbstractDeclarator )
    --> __________________
    --> #123: abstractDeclarator => ( pointer | [ pointer ] directAbstractDeclarator @ )
    -->     Type: reduce
    -->     Reduce: abstractDeclarator => ( pointer | [ pointer @ ] directAbstractDeclarator )
    --> __________________
    --> #124: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator @ ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: recursion
    -->     LA: '[' '('

** [FINAL] State #90: parameterList => [ parameterList (',') ] parameterDeclaration @
    --> __________________
    --> #125: parameterList => [ parameterList @ (',') ] parameterDeclaration
    -->     Type: recursion
    -->     LA: ','
    --> __________________
    --> #126: parameterTypeList => parameterList @ [ (',') '...' ]
    -->     Type: reduce
    -->     Reduce: parameterTypeList => @ parameterList [ (',') '...' ]

** State #91: castExpression => ( ('(') typeName @ (')') castExpression | unaryExpression )
    --> __________________
    --> #127: castExpression => ( ('(') typeName (')') @ castExpression | unaryExpression )
    -->     Type: pass
    -->     LA: ')'

** State #92: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName @ (')') ('{') initializerList [ (',') ] ('}') )
    --> __________________
    --> #128: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') @ ('{') initializerList [ (',') ] ('}') )
    -->     Type: pass
    -->     LA: ')'

** State #93: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName @ (')') ) )
    --> __________________
    --> #129: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') @ ) )
    -->     Type: pass
    -->     LA: ')'

** State #94: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' @ [ parameterTypeList ] ')' ) )
    --> __________________
    --> #130: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' @ ) )
    -->     Type: move
    -->     LA: ')'
    --> __________________
    --> #105: parameterTypeList => @ parameterList [ (',') '...' ]
    -->     Type: shift
    -->     LA: union struct enum int bool
    -->     LA: char long float unsigned double
    -->     LA: void short const volatile #identifier#
    -->     LA: signed auto static extern typedef
    -->     LA: register

** State #95: directAbstractDeclarator => ( ('(') @ abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #118: abstractDeclarator => @ ( pointer | [ pointer ] directAbstractDeclarator )
    -->     Type: shift
    -->     LA: '[' '(' '*' '^' const
    -->     LA: volatile

** State #96: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' @ ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #119: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' @ | '(' [ parameterTypeList ] ')' ) )
    -->     Type: move
    -->     LA: ']'
    --> __________________
    --> #19: typeQualifierList => [ @ typeQualifierList ] typeQualifier
    -->     Type: shift
    -->     LA: volatile const
    --> __________________
    --> #131: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' @ ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: move
    -->     LA: '*'
    --> __________________
    --> #108: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExpression )
    -->     Type: shift
    -->     LA: #float# #ulong# #long# #int# #char#
    -->     LA: #identifier# #string# sizeof '!' '--'
    -->     LA: '++' '-' #ushort# '(' #short#
    -->     LA: '~' '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** [FINAL] State #97: directDeclarator => ( #identifier# | ('(') declarator (')') @ | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    --> __________________
    --> #49: declarator => [ pointer ] directDeclarator @
    -->     Type: reduce
    -->     Reduce: declarator => [ @ pointer ] directDeclarator
    --> __________________
    --> #49: declarator => [ pointer ] directDeclarator @
    -->     Type: reduce
    -->     Reduce: declarator => [ pointer @ ] directDeclarator
    --> __________________
    --> #50: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator @ ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    -->     Type: recursion
    -->     LA: '[' '('

** State #98: compoundStatement => @ ('{') [ blockItemList ] ('}')
    --> __________________
    --> #132: compoundStatement => ('{') @ [ blockItemList ] ('}')
    -->     Type: pass
    -->     LA: '{'

** State #99: declarationList => [ @ declarationList ] declaration
    --> __________________
    --> #5: declaration => @ declarationSpecifiers [ initDeclaratorList ] (';')
    -->     Type: shift
    -->     LA: union struct enum int bool
    -->     LA: char long float unsigned double
    -->     LA: void short const volatile #identifier#
    -->     LA: signed auto static extern typedef
    -->     LA: register

** State #100: initDeclarator => declarator [ ('=') @ initializer ]
    --> __________________
    --> #133: initializer => @ ( assignmentExpression | '{' initializerList [ (',') ] '}' )
    -->     Type: shift
    -->     LA: '{' #string# #float# '~' #ulong#
    -->     LA: #long# #int# '!' #char# sizeof
    -->     LA: #identifier# '--' '++' '-' #ushort#
    -->     LA: '(' #double# #short# '+' #uchar#
    -->     LA: '*' #uint# '&'

** [FINAL] State #101: initDeclaratorList => [ initDeclaratorList (',') ] initDeclarator @
    --> __________________
    --> #134: declaration => declarationSpecifiers [ initDeclaratorList @ ] (';')
    -->     Type: reduce
    -->     Reduce: declaration => declarationSpecifiers @ [ initDeclaratorList ] (';')
    --> __________________
    --> #135: forDeclaration => declarationSpecifiers [ initDeclaratorList @ ]
    -->     Type: reduce
    -->     Reduce: forDeclaration => declarationSpecifiers @ [ initDeclaratorList ]
    --> __________________
    --> #136: initDeclaratorList => [ initDeclaratorList @ (',') ] initDeclarator
    -->     Type: recursion
    -->     LA: ','

** [FINAL] State #102: structDeclaratorList => [ structDeclaratorList (',') ] structDeclarator @
    --> __________________
    --> #137: structDeclaration => specifierQualifierList [ structDeclaratorList @ ] (';')
    -->     Type: reduce
    -->     Reduce: structDeclaration => specifierQualifierList @ [ structDeclaratorList ] (';')
    --> __________________
    --> #138: structDeclaratorList => [ structDeclaratorList @ (',') ] structDeclarator
    -->     Type: recursion
    -->     LA: ','

** State #103: structDeclarator => ( declarator | [ declarator ] ('=') @ constantExpression )
    --> __________________
    --> #139: constantExpression => @ conditionalExpression
    -->     Type: shift
    -->     LA: #double# '&' '*' #uint# '+'
    -->     LA: #uchar# #float# '~' #short# '('
    -->     LA: '-' #ushort# '++' '--' '!'
    -->     LA: #int# #char# sizeof #string# #identifier#
    -->     LA: #long# #ulong#

** [FINAL] State #104: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') @ ) )
    --> __________________
    --> #49: declarator => [ pointer ] directDeclarator @
    -->     Type: reduce
    -->     Reduce: declarator => [ @ pointer ] directDeclarator
    --> __________________
    --> #49: declarator => [ pointer ] directDeclarator @
    -->     Type: reduce
    -->     Reduce: declarator => [ pointer @ ] directDeclarator
    --> __________________
    --> #50: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator @ ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    -->     Type: recursion
    -->     LA: '[' '('

** State #105: parameterTypeList => @ parameterList [ (',') '...' ]
    --> __________________
    --> #140: parameterList => [ @ parameterList (',') ] parameterDeclaration
    -->     Type: shift
    -->     LA: register typedef extern static auto
    -->     LA: signed #identifier# volatile const short
    -->     LA: void double unsigned float long
    -->     LA: char bool int enum struct
    -->     LA: union

** State #106: identifierList => [ @ identifierList (',') ] #identifier#
    --> __________________
    --> #141: identifierList => [ identifierList (',') ] #identifier# @
    -->     Type: move
    -->     LA: #identifier#

** State #107: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' @ ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    --> __________________
    --> #142: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') @ | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    -->     Type: pass
    -->     LA: ']'

** State #108: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExpression )
    --> __________________
    --> #143: unaryExpression => @ ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: shift
    -->     LA: '&' #double# '*' #uint# '+'
    -->     LA: #uchar# '~' #short# '-' '('
    -->     LA: #ushort# '++' '--' '!' sizeof
    -->     LA: #string# #identifier# #char# #int# #long#
    -->     LA: #ulong# #float#
    --> __________________
    --> #144: conditionalExpression => @ logicalOrExpression [ '?' expression '=' conditionalExpression ]
    -->     Type: shift
    -->     LA: #double# '&' '*' #uint# '+'
    -->     LA: #uchar# #float# '~' #short# '('
    -->     LA: '-' #ushort# '++' '--' '!'
    -->     LA: #int# #char# sizeof #string# #identifier#
    -->     LA: #long# #ulong#

** State #109: declaration => declarationSpecifiers @ [ initDeclaratorList ] (';')
    --> __________________
    --> #145: declaration => declarationSpecifiers [ initDeclaratorList ] (';') @
    -->     Type: pass
    -->     LA: ';'
    --> __________________
    --> #146: initDeclaratorList => [ @ initDeclaratorList (',') ] initDeclarator
    -->     Type: shift
    -->     LA: volatile const '^' #identifier# '*'
    -->     LA: '('

** State #110: declarationSpecifiers => [ declarationSpecifiers @ ] declarationSpecifier
    --> __________________
    --> #11: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    -->     Type: shift
    -->     LA: union struct enum int bool
    -->     LA: char long float unsigned double
    -->     LA: void short const volatile #identifier#
    -->     LA: signed auto static extern typedef
    -->     LA: register

** State #111: declarationSpecifiers2 => [ declarationSpecifiers @ ] declarationSpecifier
    --> __________________
    --> #11: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    -->     Type: shift
    -->     LA: union struct enum int bool
    -->     LA: char long float unsigned double
    -->     LA: void short const volatile #identifier#
    -->     LA: signed auto static extern typedef
    -->     LA: register

** [FINAL] State #112: forDeclaration => declarationSpecifiers @ [ initDeclaratorList ]
    --> __________________
    --> #146: initDeclaratorList => [ @ initDeclaratorList (',') ] initDeclarator
    -->     Type: shift
    -->     LA: volatile const '^' #identifier# '*'
    -->     LA: '('
    --> __________________
    --> #147: forCondition => ( forDeclaration @ | [ expression ] ) ';' [ forExpression ] ';' [ forExpression ]
    -->     Type: reduce
    -->     Reduce: forCondition => @ ( forDeclaration | [ expression ] ) ';' [ forExpression ] ';' [ forExpression ]

** State #113: functionDefinition => [ declarationSpecifiers @ ] declarator [ declarationList ] compoundStatement
    --> __________________
    --> #8: declarator => [ @ pointer ] directDeclarator
    -->     Type: shift
    -->     LA: '(' '*' #identifier# '^' const
    -->     LA: volatile

** State #114: parameterDeclaration => ( declarationSpecifiers @ declarator | declarationSpecifiers2 [ abstractDeclarator ] )
    --> __________________
    --> #8: declarator => [ @ pointer ] directDeclarator
    -->     Type: shift
    -->     LA: '(' '*' #identifier# '^' const
    -->     LA: volatile

** [FINAL] State #115: parameterDeclaration => ( declarationSpecifiers declarator | declarationSpecifiers2 @ [ abstractDeclarator ] )
    --> __________________
    --> #118: abstractDeclarator => @ ( pointer | [ pointer ] directAbstractDeclarator )
    -->     Type: shift
    -->     LA: '[' '(' '*' '^' const
    -->     LA: volatile
    --> __________________
    --> #90: parameterList => [ parameterList (',') ] parameterDeclaration @
    -->     Type: reduce
    -->     Reduce: parameterList => [ @ parameterList (',') ] parameterDeclaration
    --> __________________
    --> #90: parameterList => [ parameterList (',') ] parameterDeclaration @
    -->     Type: reduce
    -->     Reduce: parameterList => [ parameterList (',') @ ] parameterDeclaration

** [FINAL] State #116: structDeclaration => specifierQualifierList [ structDeclaratorList ] (';') @
    --> __________________
    --> #148: structDeclarationList => [ structDeclarationList ] structDeclaration @
    -->     Type: reduce
    -->     Reduce: structDeclarationList => [ @ structDeclarationList ] structDeclaration
    --> __________________
    --> #148: structDeclarationList => [ structDeclarationList ] structDeclaration @
    -->     Type: reduce
    -->     Reduce: structDeclarationList => [ structDeclarationList @ ] structDeclaration

** State #117: structDeclaratorList => [ @ structDeclaratorList (',') ] structDeclarator
    --> __________________
    --> #149: structDeclarator => @ ( declarator | [ declarator ] ('=') constantExpression )
    -->     Type: shift
    -->     LA: '=' '(' '*' #identifier# '^'
    -->     LA: const volatile

** State #118: abstractDeclarator => @ ( pointer | [ pointer ] directAbstractDeclarator )
    --> __________________
    --> #64: directAbstractDeclarator => @ ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: shift
    -->     LA: '(' '['
    --> __________________
    --> #12: pointer => [ @ typeQualifierList ] [ pointer ] ( '*' | '^' )
    -->     Type: shift
    -->     LA: volatile const '^' '*'
    --> __________________
    --> #12: pointer => [ @ typeQualifierList ] [ pointer ] ( '*' | '^' )
    -->     Type: shift
    -->     LA: volatile const '^' '*'

** [FINAL] State #119: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' @ | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #123: abstractDeclarator => ( pointer | [ pointer ] directAbstractDeclarator @ )
    -->     Type: reduce
    -->     Reduce: abstractDeclarator => @ ( pointer | [ pointer ] directAbstractDeclarator )
    --> __________________
    --> #123: abstractDeclarator => ( pointer | [ pointer ] directAbstractDeclarator @ )
    -->     Type: reduce
    -->     Reduce: abstractDeclarator => ( pointer | [ pointer @ ] directAbstractDeclarator )
    --> __________________
    --> #124: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator @ ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: recursion
    -->     LA: '[' '('

** State #120: structOrUnionSpecifier => structOrUnion @ ( #identifier# | [ #identifier# ] ('{') structDeclarationList ('}') )
    --> __________________
    --> #150: structOrUnionSpecifier => structOrUnion ( #identifier# | [ #identifier# ] ('{') @ structDeclarationList ('}') )
    -->     Type: pass
    -->     LA: '{'
    --> __________________
    --> #151: structOrUnionSpecifier => structOrUnion ( #identifier# @ | [ #identifier# ] ('{') structDeclarationList ('}') )
    -->     Type: move
    -->     LA: #identifier#
    --> __________________
    --> #152: structOrUnionSpecifier => structOrUnion ( #identifier# | [ #identifier# @ ] ('{') structDeclarationList ('}') )
    -->     Type: move
    -->     LA: #identifier#

** State #121: enumeratorList => [ @ enumeratorList (',') ] enumerator
    --> __________________
    --> #153: enumerator => @ enumerationConstant [ ('=') constantExpression ]
    -->     Type: shift
    -->     LA: #identifier#

** [FINAL] State #122: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier @ | typedefName | typeSpecifier pointer )
    --> __________________
    --> #55: declarationSpecifier => ( storageClassSpecifier | typeSpecifier @ | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #56: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #57: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )
    -->     Type: recursion
    -->     LA: volatile const '^' '*'

** [FINAL] State #123: abstractDeclarator => ( pointer | [ pointer ] directAbstractDeclarator @ )
    --> __________________
    --> #61: directAbstractDeclarator => ( ('(') abstractDeclarator @ (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: reduce
    -->     Reduce: directAbstractDeclarator => ( ('(') @ abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #62: parameterDeclaration => ( declarationSpecifiers declarator | declarationSpecifiers2 [ abstractDeclarator @ ] )
    -->     Type: reduce
    -->     Reduce: parameterDeclaration => ( declarationSpecifiers declarator | declarationSpecifiers2 @ [ abstractDeclarator ] )
    --> __________________
    --> #63: typeName => specifierQualifierList [ abstractDeclarator @ ]
    -->     Type: reduce
    -->     Reduce: typeName => specifierQualifierList @ [ abstractDeclarator ]

** State #124: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator @ ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #94: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' @ [ parameterTypeList ] ')' ) )
    -->     Type: move
    -->     LA: '('
    --> __________________
    --> #96: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' @ ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: move
    -->     LA: '['

** State #125: parameterList => [ parameterList @ (',') ] parameterDeclaration
    --> __________________
    --> #154: parameterList => [ parameterList (',') @ ] parameterDeclaration
    -->     Type: pass
    -->     LA: ','

** [FINAL] State #126: parameterTypeList => parameterList @ [ (',') '...' ]
    --> __________________
    --> #155: parameterTypeList => parameterList [ (',') @ '...' ]
    -->     Type: pass
    -->     LA: ','
    --> __________________
    --> #156: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList @ ] ')' ) )
    -->     Type: reduce
    -->     Reduce: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' @ [ parameterTypeList ] ')' ) )
    --> __________________
    --> #157: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList @ | [ identifierList ] ) (')') ) )
    -->     Type: reduce
    -->     Reduce: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') @ ( parameterTypeList | [ identifierList ] ) (')') ) )

** State #127: castExpression => ( ('(') typeName (')') @ castExpression | unaryExpression )
    --> __________________
    --> #158: castExpression => @ ( ('(') typeName (')') castExpression | unaryExpression )
    -->     Type: shift
    -->     LA: #double# '&' '*' #uint# '+'
    -->     LA: #uchar# #float# '~' #short# '('
    -->     LA: '-' #ushort# '++' '--' '!'
    -->     LA: #int# #char# sizeof #string# #identifier#
    -->     LA: #long# #ulong#

** State #128: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') @ ('{') initializerList [ (',') ] ('}') )
    --> __________________
    --> #159: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') @ initializerList [ (',') ] ('}') )
    -->     Type: pass
    -->     LA: '{'

** [FINAL] State #129: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') @ ) )
    --> __________________
    --> #160: assignmentExpression => ( conditionalExpression | unaryExpression @ assignmentOperator assignmentExpression )
    -->     Type: reduce
    --> __________________
    --> #161: castExpression => ( ('(') typeName (')') castExpression | unaryExpression @ )
    -->     Type: reduce
    --> __________________
    --> #162: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression @ | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: reduce
    --> __________________
    --> #163: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression @ | ('(') typeName (')') ) )
    -->     Type: reduce
    --> __________________
    --> #162: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression @ | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: reduce

** [FINAL] State #130: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' @ ) )
    --> __________________
    --> #123: abstractDeclarator => ( pointer | [ pointer ] directAbstractDeclarator @ )
    -->     Type: reduce
    -->     Reduce: abstractDeclarator => @ ( pointer | [ pointer ] directAbstractDeclarator )
    --> __________________
    --> #123: abstractDeclarator => ( pointer | [ pointer ] directAbstractDeclarator @ )
    -->     Type: reduce
    -->     Reduce: abstractDeclarator => ( pointer | [ pointer @ ] directAbstractDeclarator )
    --> __________________
    --> #124: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator @ ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: recursion
    -->     LA: '[' '('

** State #131: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' @ ) ']' | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #119: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' @ | '(' [ parameterTypeList ] ')' ) )
    -->     Type: move
    -->     LA: ']'

** State #132: compoundStatement => ('{') @ [ blockItemList ] ('}')
    --> __________________
    --> #164: compoundStatement => ('{') [ blockItemList ] ('}') @
    -->     Type: pass
    -->     LA: '}'
    --> __________________
    --> #165: blockItemList => [ @ blockItemList ] blockItem
    -->     Type: shift
    -->     LA: #uint# '+' if '++' #uchar#
    -->     LA: sizeof '&' do '!' '-'
    -->     LA: '~' break for goto '*'
    -->     LA: default case '(' #string# while
    -->     LA: continue return #int# switch #ulong#
    -->     LA: union #ushort# struct ';' enum
    -->     LA: int bool char long '--'
    -->     LA: float #float# unsigned double #double#
    -->     LA: void short '{' const volatile
    -->     LA: #identifier# #char# signed auto #short#
    -->     LA: static extern #long# typedef register

** State #133: initializer => @ ( assignmentExpression | '{' initializerList [ (',') ] '}' )
    --> __________________
    --> #166: initializer => ( assignmentExpression | '{' @ initializerList [ (',') ] '}' )
    -->     Type: move
    -->     LA: '{'
    --> __________________
    --> #108: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExpression )
    -->     Type: shift
    -->     LA: #float# #ulong# #long# #int# #char#
    -->     LA: #identifier# #string# sizeof '!' '--'
    -->     LA: '++' '-' #ushort# '(' #short#
    -->     LA: '~' '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #134: declaration => declarationSpecifiers [ initDeclaratorList @ ] (';')
    --> __________________
    --> #145: declaration => declarationSpecifiers [ initDeclaratorList ] (';') @
    -->     Type: pass
    -->     LA: ';'

** [FINAL] State #135: forDeclaration => declarationSpecifiers [ initDeclaratorList @ ]
    --> __________________
    --> #147: forCondition => ( forDeclaration @ | [ expression ] ) ';' [ forExpression ] ';' [ forExpression ]
    -->     Type: reduce
    -->     Reduce: forCondition => @ ( forDeclaration | [ expression ] ) ';' [ forExpression ] ';' [ forExpression ]

** State #136: initDeclaratorList => [ initDeclaratorList @ (',') ] initDeclarator
    --> __________________
    --> #167: initDeclaratorList => [ initDeclaratorList (',') @ ] initDeclarator
    -->     Type: pass
    -->     LA: ','

** State #137: structDeclaration => specifierQualifierList [ structDeclaratorList @ ] (';')
    --> __________________
    --> #116: structDeclaration => specifierQualifierList [ structDeclaratorList ] (';') @
    -->     Type: pass
    -->     LA: ';'

** State #138: structDeclaratorList => [ structDeclaratorList @ (',') ] structDeclarator
    --> __________________
    --> #168: structDeclaratorList => [ structDeclaratorList (',') @ ] structDeclarator
    -->     Type: pass
    -->     LA: ','

** State #139: constantExpression => @ conditionalExpression
    --> __________________
    --> #144: conditionalExpression => @ logicalOrExpression [ '?' expression '=' conditionalExpression ]
    -->     Type: shift
    -->     LA: #double# '&' '*' #uint# '+'
    -->     LA: #uchar# #float# '~' #short# '('
    -->     LA: '-' #ushort# '++' '--' '!'
    -->     LA: #int# #char# sizeof #string# #identifier#
    -->     LA: #long# #ulong#

** State #140: parameterList => [ @ parameterList (',') ] parameterDeclaration
    --> __________________
    --> #169: parameterDeclaration => @ ( declarationSpecifiers declarator | declarationSpecifiers2 [ abstractDeclarator ] )
    -->     Type: shift
    -->     LA: union struct enum int bool
    -->     LA: char long float unsigned double
    -->     LA: void short const volatile #identifier#
    -->     LA: signed auto static extern typedef
    -->     LA: register

** [FINAL] State #141: identifierList => [ identifierList (',') ] #identifier# @
    --> __________________
    --> #170: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList @ ] ) (')') ) )
    -->     Type: reduce
    -->     Reduce: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') @ ( parameterTypeList | [ identifierList ] ) (')') ) )
    --> __________________
    --> #171: identifierList => [ identifierList @ (',') ] #identifier#
    -->     Type: recursion
    -->     LA: ','

** [FINAL] State #142: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') @ | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    --> __________________
    --> #49: declarator => [ pointer ] directDeclarator @
    -->     Type: reduce
    -->     Reduce: declarator => [ @ pointer ] directDeclarator
    --> __________________
    --> #49: declarator => [ pointer ] directDeclarator @
    -->     Type: reduce
    -->     Reduce: declarator => [ pointer @ ] directDeclarator
    --> __________________
    --> #50: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator @ ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    -->     Type: recursion
    -->     LA: '[' '('

** State #143: unaryExpression => @ ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    --> __________________
    --> #172: unaryExpression => ( postfixExpression | ( '++' | '--' @ ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: move
    -->     LA: '--'
    --> __________________
    --> #173: postfixExpression => @ ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    -->     Type: shift
    -->     LA: #double# #float# #ulong# #long# #uint#
    -->     LA: #int# #char# #uchar# #short# #ushort#
    -->     LA: #identifier# #string# '('
    --> __________________
    --> #174: unaryOperator => @ ( '&' | '*' | '+' | '-' | '~' | '!' )
    -->     Type: shift
    -->     LA: '-' '~' '+' '*' '&'
    -->     LA: '!'
    --> __________________
    --> #175: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof @ ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: move
    -->     LA: sizeof
    --> __________________
    --> #176: unaryExpression => ( postfixExpression | ( '++' @ | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: move
    -->     LA: '++'

** State #144: conditionalExpression => @ logicalOrExpression [ '?' expression '=' conditionalExpression ]
    --> __________________
    --> #177: logicalOrExpression => [ @ logicalOrExpression '||' ] logicalAndExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** [FINAL] State #145: declaration => declarationSpecifiers [ initDeclaratorList ] (';') @
    --> __________________
    --> #178: blockItem => ( statement | declaration @ )
    -->     Type: reduce
    -->     Reduce: blockItem => @ ( statement | declaration )
    --> __________________
    --> #179: declarationList => [ declarationList ] declaration @
    -->     Type: reduce
    -->     Reduce: declarationList => [ @ declarationList ] declaration
    --> __________________
    --> #179: declarationList => [ declarationList ] declaration @
    -->     Type: reduce
    -->     Reduce: declarationList => [ declarationList @ ] declaration
    --> __________________
    --> #180: externalDeclaration => ( functionDefinition | declaration @ | (';') )
    -->     Type: reduce
    -->     Reduce: externalDeclaration => @ ( functionDefinition | declaration | (';') )

** State #146: initDeclaratorList => [ @ initDeclaratorList (',') ] initDeclarator
    --> __________________
    --> #181: initDeclarator => @ declarator [ ('=') initializer ]
    -->     Type: shift
    -->     LA: '(' '*' #identifier# '^' const
    -->     LA: volatile

** State #147: forCondition => ( forDeclaration @ | [ expression ] ) ';' [ forExpression ] ';' [ forExpression ]
    --> __________________
    --> #182: forCondition => ( forDeclaration | [ expression ] ) ';' @ [ forExpression ] ';' [ forExpression ]
    -->     Type: move
    -->     LA: ';'

** [FINAL] State #148: structDeclarationList => [ structDeclarationList ] structDeclaration @
    --> __________________
    --> #183: structDeclarationList => [ structDeclarationList @ ] structDeclaration
    -->     Type: recursion
    -->     LA: volatile const short signed #identifier#
    -->     LA: void unsigned float long char
    -->     LA: bool int enum double struct
    -->     LA: union
    --> __________________
    --> #184: structOrUnionSpecifier => structOrUnion ( #identifier# | [ #identifier# ] ('{') structDeclarationList @ ('}') )
    -->     Type: reduce
    -->     Reduce: structOrUnionSpecifier => structOrUnion ( #identifier# | [ #identifier# ] ('{') @ structDeclarationList ('}') )

** State #149: structDeclarator => @ ( declarator | [ declarator ] ('=') constantExpression )
    --> __________________
    --> #103: structDeclarator => ( declarator | [ declarator ] ('=') @ constantExpression )
    -->     Type: pass
    -->     LA: '='
    --> __________________
    --> #8: declarator => [ @ pointer ] directDeclarator
    -->     Type: shift
    -->     LA: '(' '*' #identifier# '^' const
    -->     LA: volatile
    --> __________________
    --> #8: declarator => [ @ pointer ] directDeclarator
    -->     Type: shift
    -->     LA: '(' '*' #identifier# '^' const
    -->     LA: volatile

** State #150: structOrUnionSpecifier => structOrUnion ( #identifier# | [ #identifier# ] ('{') @ structDeclarationList ('}') )
    --> __________________
    --> #185: structDeclarationList => [ @ structDeclarationList ] structDeclaration
    -->     Type: shift
    -->     LA: union struct double enum #identifier#
    -->     LA: int bool char long float
    -->     LA: unsigned void signed short const
    -->     LA: volatile

** [FINAL] State #151: structOrUnionSpecifier => structOrUnion ( #identifier# @ | [ #identifier# ] ('{') structDeclarationList ('}') )
    --> __________________
    --> #186: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier @ | enumSpecifier | typedefName | typeSpecifier pointer )
    -->     Type: reduce
    -->     Reduce: typeSpecifier => @ ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )

** State #152: structOrUnionSpecifier => structOrUnion ( #identifier# | [ #identifier# @ ] ('{') structDeclarationList ('}') )
    --> __________________
    --> #150: structOrUnionSpecifier => structOrUnion ( #identifier# | [ #identifier# ] ('{') @ structDeclarationList ('}') )
    -->     Type: pass
    -->     LA: '{'

** State #153: enumerator => @ enumerationConstant [ ('=') constantExpression ]
    --> __________________
    --> #187: enumerationConstant => @ #identifier#
    -->     Type: shift
    -->     LA: #identifier#

** State #154: parameterList => [ parameterList (',') @ ] parameterDeclaration
    --> __________________
    --> #169: parameterDeclaration => @ ( declarationSpecifiers declarator | declarationSpecifiers2 [ abstractDeclarator ] )
    -->     Type: shift
    -->     LA: union struct enum int bool
    -->     LA: char long float unsigned double
    -->     LA: void short const volatile #identifier#
    -->     LA: signed auto static extern typedef
    -->     LA: register

** State #155: parameterTypeList => parameterList [ (',') @ '...' ]
    --> __________________
    --> #188: parameterTypeList => parameterList [ (',') '...' @ ]
    -->     Type: move
    -->     LA: '...'

** State #156: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList @ ] ')' ) )
    --> __________________
    --> #130: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' @ ) )
    -->     Type: move
    -->     LA: ')'

** State #157: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList @ | [ identifierList ] ) (')') ) )
    --> __________________
    --> #104: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') @ ) )
    -->     Type: pass
    -->     LA: ')'

** State #158: castExpression => @ ( ('(') typeName (')') castExpression | unaryExpression )
    --> __________________
    --> #143: unaryExpression => @ ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: shift
    -->     LA: '&' #double# '*' #uint# '+'
    -->     LA: #uchar# '~' #short# '-' '('
    -->     LA: #ushort# '++' '--' '!' sizeof
    -->     LA: #string# #identifier# #char# #int# #long#
    -->     LA: #ulong# #float#
    --> __________________
    --> #189: castExpression => ( ('(') @ typeName (')') castExpression | unaryExpression )
    -->     Type: pass
    -->     LA: '('

** State #159: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') @ initializerList [ (',') ] ('}') )
    --> __________________
    --> #190: initializerList => [ @ initializerList (',') ] [ designation ] initializer
    -->     Type: shift
    -->     LA: '.' '&' #uint# '*' #uchar#
    -->     LA: '[' '+' #short# #double# '('
    -->     LA: #ushort# '-' '++' '--' #identifier#
    -->     LA: sizeof #char# '!' #int# #long#
    -->     LA: #ulong# '~' #float# #string# '{'

** State #160: assignmentExpression => ( conditionalExpression | unaryExpression @ assignmentOperator assignmentExpression )
    --> __________________
    --> #191: assignmentOperator => @ ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' )
    -->     Type: shift
    -->     LA: '/=' '%=' '*=' '=' '<<='
    -->     LA: '+=' '-=' '>>='

** [FINAL] State #161: castExpression => ( ('(') typeName (')') castExpression | unaryExpression @ )
    --> __________________
    --> #192: castExpression => ( ('(') typeName (')') castExpression @ | unaryExpression )
    -->     Type: reduce
    --> __________________
    --> #193: multiplicativeExpression => [ multiplicativeExpression ( '*' | '/' | '%' ) ] castExpression @
    -->     Type: reduce
    --> __________________
    --> #193: multiplicativeExpression => [ multiplicativeExpression ( '*' | '/' | '%' ) ] castExpression @
    -->     Type: reduce
    --> __________________
    --> #193: multiplicativeExpression => [ multiplicativeExpression ( '*' | '/' | '%' ) ] castExpression @
    -->     Type: reduce
    --> __________________
    --> #193: multiplicativeExpression => [ multiplicativeExpression ( '*' | '/' | '%' ) ] castExpression @
    -->     Type: reduce
    --> __________________
    --> #194: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression @ | sizeof ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: reduce

** [FINAL] State #162: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression @ | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    --> __________________
    --> #160: assignmentExpression => ( conditionalExpression | unaryExpression @ assignmentOperator assignmentExpression )
    -->     Type: reduce
    --> __________________
    --> #161: castExpression => ( ('(') typeName (')') castExpression | unaryExpression @ )
    -->     Type: reduce
    --> __________________
    --> #162: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression @ | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: reduce
    --> __________________
    --> #163: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression @ | ('(') typeName (')') ) )
    -->     Type: reduce
    --> __________________
    --> #162: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression @ | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: reduce

** [FINAL] State #163: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression @ | ('(') typeName (')') ) )
    --> __________________
    --> #160: assignmentExpression => ( conditionalExpression | unaryExpression @ assignmentOperator assignmentExpression )
    -->     Type: reduce
    --> __________________
    --> #161: castExpression => ( ('(') typeName (')') castExpression | unaryExpression @ )
    -->     Type: reduce
    --> __________________
    --> #162: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression @ | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: reduce
    --> __________________
    --> #163: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression @ | ('(') typeName (')') ) )
    -->     Type: reduce
    --> __________________
    --> #162: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression @ | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: reduce

** [FINAL] State #164: compoundStatement => ('{') [ blockItemList ] ('}') @
    --> __________________
    --> #195: functionDefinition => [ declarationSpecifiers ] declarator [ declarationList ] compoundStatement @
    -->     Type: reduce
    -->     Reduce: functionDefinition => [ declarationSpecifiers ] declarator @ [ declarationList ] compoundStatement
    --> __________________
    --> #195: functionDefinition => [ declarationSpecifiers ] declarator [ declarationList ] compoundStatement @
    -->     Type: reduce
    -->     Reduce: functionDefinition => [ declarationSpecifiers ] declarator [ declarationList @ ] compoundStatement
    --> __________________
    --> #196: statement => ( labeledStatement | compoundStatement @ | expressionStatement | selectionStatement | iterationStatement | jumpStatement )
    -->     Type: reduce
    -->     Reduce: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationStatement | jumpStatement )

** State #165: blockItemList => [ @ blockItemList ] blockItem
    --> __________________
    --> #197: blockItem => @ ( statement | declaration )
    -->     Type: shift
    -->     LA: register typedef #long# extern static
    -->     LA: #short# auto signed #char# #identifier#
    -->     LA: volatile const '{' short void
    -->     LA: #double# double unsigned #float# float
    -->     LA: '--' long char bool int
    -->     LA: enum ';' struct #ushort# union
    -->     LA: #ulong# switch #int# return continue
    -->     LA: while #string# '(' case default
    -->     LA: '*' goto for break '~'
    -->     LA: '-' '!' do '&' sizeof
    -->     LA: #uchar# '++' if '+' #uint#

** State #166: initializer => ( assignmentExpression | '{' @ initializerList [ (',') ] '}' )
    --> __________________
    --> #190: initializerList => [ @ initializerList (',') ] [ designation ] initializer
    -->     Type: shift
    -->     LA: '.' '&' #uint# '*' #uchar#
    -->     LA: '[' '+' #short# #double# '('
    -->     LA: #ushort# '-' '++' '--' #identifier#
    -->     LA: sizeof #char# '!' #int# #long#
    -->     LA: #ulong# '~' #float# #string# '{'

** State #167: initDeclaratorList => [ initDeclaratorList (',') @ ] initDeclarator
    --> __________________
    --> #181: initDeclarator => @ declarator [ ('=') initializer ]
    -->     Type: shift
    -->     LA: '(' '*' #identifier# '^' const
    -->     LA: volatile

** State #168: structDeclaratorList => [ structDeclaratorList (',') @ ] structDeclarator
    --> __________________
    --> #149: structDeclarator => @ ( declarator | [ declarator ] ('=') constantExpression )
    -->     Type: shift
    -->     LA: '=' '(' '*' #identifier# '^'
    -->     LA: const volatile

** State #169: parameterDeclaration => @ ( declarationSpecifiers declarator | declarationSpecifiers2 [ abstractDeclarator ] )
    --> __________________
    --> #198: declarationSpecifiers2 => [ @ declarationSpecifiers ] declarationSpecifier
    -->     Type: shift
    -->     LA: register typedef extern static auto
    -->     LA: signed #identifier# volatile const short
    -->     LA: void double unsigned float long
    -->     LA: char bool int enum struct
    -->     LA: union
    --> __________________
    --> #7: declarationSpecifiers => [ @ declarationSpecifiers ] declarationSpecifier
    -->     Type: shift
    -->     LA: register typedef extern static auto
    -->     LA: signed #identifier# volatile const short
    -->     LA: void double unsigned float long
    -->     LA: char bool int enum struct
    -->     LA: union

** State #170: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList @ ] ) (')') ) )
    --> __________________
    --> #104: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') @ ) )
    -->     Type: pass
    -->     LA: ')'

** State #171: identifierList => [ identifierList @ (',') ] #identifier#
    --> __________________
    --> #199: identifierList => [ identifierList (',') @ ] #identifier#
    -->     Type: pass
    -->     LA: ','

** State #172: unaryExpression => ( postfixExpression | ( '++' | '--' @ ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    --> __________________
    --> #143: unaryExpression => @ ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: shift
    -->     LA: '&' #double# '*' #uint# '+'
    -->     LA: #uchar# '~' #short# '-' '('
    -->     LA: #ushort# '++' '--' '!' sizeof
    -->     LA: #string# #identifier# #char# #int# #long#
    -->     LA: #ulong# #float#

** State #173: postfixExpression => @ ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    --> __________________
    --> #200: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') @ typeName (')') ('{') initializerList [ (',') ] ('}') )
    -->     Type: pass
    -->     LA: '('
    --> __________________
    --> #201: primaryExpression => @ ( #identifier# | constant | #string# | ('(') expression (')') )
    -->     Type: shift
    -->     LA: #string# '(' #identifier# #ushort# #short#
    -->     LA: #uchar# #char# #int# #uint# #long#
    -->     LA: #ulong# #float# #double#

** State #174: unaryOperator => @ ( '&' | '*' | '+' | '-' | '~' | '!' )
    --> __________________
    --> #202: unaryOperator => ( '&' | '*' | '+' | '-' | '~' | '!' @ )
    -->     Type: move
    -->     LA: '!'
    --> __________________
    --> #203: unaryOperator => ( '&' @ | '*' | '+' | '-' | '~' | '!' )
    -->     Type: move
    -->     LA: '&'
    --> __________________
    --> #204: unaryOperator => ( '&' | '*' @ | '+' | '-' | '~' | '!' )
    -->     Type: move
    -->     LA: '*'
    --> __________________
    --> #205: unaryOperator => ( '&' | '*' | '+' @ | '-' | '~' | '!' )
    -->     Type: move
    -->     LA: '+'
    --> __________________
    --> #206: unaryOperator => ( '&' | '*' | '+' | '-' @ | '~' | '!' )
    -->     Type: move
    -->     LA: '-'
    --> __________________
    --> #207: unaryOperator => ( '&' | '*' | '+' | '-' | '~' @ | '!' )
    -->     Type: move
    -->     LA: '~'

** State #175: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof @ ( unaryExpression | ('(') typeName (')') ) )
    --> __________________
    --> #208: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') @ typeName (')') ) )
    -->     Type: pass
    -->     LA: '('
    --> __________________
    --> #143: unaryExpression => @ ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: shift
    -->     LA: '&' #double# '*' #uint# '+'
    -->     LA: #uchar# '~' #short# '-' '('
    -->     LA: #ushort# '++' '--' '!' sizeof
    -->     LA: #string# #identifier# #char# #int# #long#
    -->     LA: #ulong# #float#

** State #176: unaryExpression => ( postfixExpression | ( '++' @ | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    --> __________________
    --> #143: unaryExpression => @ ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: shift
    -->     LA: '&' #double# '*' #uint# '+'
    -->     LA: #uchar# '~' #short# '-' '('
    -->     LA: #ushort# '++' '--' '!' sizeof
    -->     LA: #string# #identifier# #char# #int# #long#
    -->     LA: #ulong# #float#

** State #177: logicalOrExpression => [ @ logicalOrExpression '||' ] logicalAndExpression
    --> __________________
    --> #209: logicalAndExpression => [ @ logicalAndExpression '&&' ] inclusiveOrExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** [FINAL] State #178: blockItem => ( statement | declaration @ )
    --> __________________
    --> #210: blockItemList => [ blockItemList ] blockItem @
    -->     Type: reduce
    -->     Reduce: blockItemList => [ @ blockItemList ] blockItem
    --> __________________
    --> #210: blockItemList => [ blockItemList ] blockItem @
    -->     Type: reduce
    -->     Reduce: blockItemList => [ blockItemList @ ] blockItem

** [FINAL] State #179: declarationList => [ declarationList ] declaration @
    --> __________________
    --> #211: declarationList => [ declarationList @ ] declaration
    -->     Type: recursion
    -->     LA: union struct enum int bool
    -->     LA: char long float unsigned double
    -->     LA: void short const volatile #identifier#
    -->     LA: signed auto static extern typedef
    -->     LA: register
    --> __________________
    --> #212: functionDefinition => [ declarationSpecifiers ] declarator [ declarationList @ ] compoundStatement
    -->     Type: reduce
    -->     Reduce: functionDefinition => [ declarationSpecifiers ] declarator @ [ declarationList ] compoundStatement

** [FINAL] State #180: externalDeclaration => ( functionDefinition | declaration @ | (';') )
    --> __________________
    --> #6: translationUnit => [ translationUnit ] externalDeclaration @
    -->     Type: reduce
    -->     Reduce: translationUnit => [ @ translationUnit ] externalDeclaration
    --> __________________
    --> #6: translationUnit => [ translationUnit ] externalDeclaration @
    -->     Type: reduce
    -->     Reduce: translationUnit => [ translationUnit @ ] externalDeclaration

** State #181: initDeclarator => @ declarator [ ('=') initializer ]
    --> __________________
    --> #8: declarator => [ @ pointer ] directDeclarator
    -->     Type: shift
    -->     LA: '(' '*' #identifier# '^' const
    -->     LA: volatile

** State #182: forCondition => ( forDeclaration | [ expression ] ) ';' @ [ forExpression ] ';' [ forExpression ]
    --> __________________
    --> #213: forCondition => ( forDeclaration | [ expression ] ) ';' [ forExpression ] ';' @ [ forExpression ]
    -->     Type: move
    -->     LA: ';'
    --> __________________
    --> #214: forExpression => [ @ forExpression (',') ] assignmentExpression
    -->     Type: shift
    -->     LA: #double# '&' #identifier# #uint# '*'
    -->     LA: #long# #uchar# '+' #short# '~'
    -->     LA: '(' #ushort# '-' #int# '++'
    -->     LA: '--' '!' sizeof #string# #char#
    -->     LA: #ulong# #float#

** State #183: structDeclarationList => [ structDeclarationList @ ] structDeclaration
    --> __________________
    --> #215: structDeclaration => @ specifierQualifierList [ structDeclaratorList ] (';')
    -->     Type: shift
    -->     LA: volatile const short signed #identifier#
    -->     LA: void unsigned float long char
    -->     LA: bool int enum double struct
    -->     LA: union

** State #184: structOrUnionSpecifier => structOrUnion ( #identifier# | [ #identifier# ] ('{') structDeclarationList @ ('}') )
    --> __________________
    --> #216: structOrUnionSpecifier => structOrUnion ( #identifier# | [ #identifier# ] ('{') structDeclarationList ('}') @ )
    -->     Type: pass
    -->     LA: '}'

** State #185: structDeclarationList => [ @ structDeclarationList ] structDeclaration
    --> __________________
    --> #215: structDeclaration => @ specifierQualifierList [ structDeclaratorList ] (';')
    -->     Type: shift
    -->     LA: volatile const short signed #identifier#
    -->     LA: void unsigned float long char
    -->     LA: bool int enum double struct
    -->     LA: union

** [FINAL] State #186: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier @ | enumSpecifier | typedefName | typeSpecifier pointer )
    --> __________________
    --> #55: declarationSpecifier => ( storageClassSpecifier | typeSpecifier @ | typeQualifier )
    -->     Type: reduce
    -->     Reduce: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    --> __________________
    --> #56: specifierQualifierList => ( typeSpecifier @ | typeQualifier ) [ specifierQualifierList ]
    -->     Type: reduce
    -->     Reduce: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    --> __________________
    --> #57: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier @ pointer )
    -->     Type: recursion
    -->     LA: volatile const '^' '*'

** State #187: enumerationConstant => @ #identifier#
    --> __________________
    --> #217: enumerationConstant => #identifier# @
    -->     Type: move
    -->     LA: #identifier#

** [FINAL] State #188: parameterTypeList => parameterList [ (',') '...' @ ]
    --> __________________
    --> #156: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList @ ] ')' ) )
    -->     Type: reduce
    -->     Reduce: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' @ [ parameterTypeList ] ')' ) )
    --> __________________
    --> #157: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList @ | [ identifierList ] ) (')') ) )
    -->     Type: reduce
    -->     Reduce: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') @ ( parameterTypeList | [ identifierList ] ) (')') ) )

** State #189: castExpression => ( ('(') @ typeName (')') castExpression | unaryExpression )
    --> __________________
    --> #218: typeName => @ specifierQualifierList [ abstractDeclarator ]
    -->     Type: shift
    -->     LA: volatile const short signed #identifier#
    -->     LA: void unsigned float long char
    -->     LA: bool int enum double struct
    -->     LA: union

** State #190: initializerList => [ @ initializerList (',') ] [ designation ] initializer
    --> __________________
    --> #219: designation => @ designatorList '='
    -->     Type: shift
    -->     LA: '[' '.'
    --> __________________
    --> #133: initializer => @ ( assignmentExpression | '{' initializerList [ (',') ] '}' )
    -->     Type: shift
    -->     LA: '{' #string# #float# '~' #ulong#
    -->     LA: #long# #int# '!' #char# sizeof
    -->     LA: #identifier# '--' '++' '-' #ushort#
    -->     LA: '(' #double# #short# '+' #uchar#
    -->     LA: '*' #uint# '&'

** State #191: assignmentOperator => @ ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' )
    --> __________________
    --> #220: assignmentOperator => ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' @ )
    -->     Type: move
    -->     LA: '>>='
    --> __________________
    --> #221: assignmentOperator => ( '=' @ | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' )
    -->     Type: move
    -->     LA: '='
    --> __________________
    --> #222: assignmentOperator => ( '=' | '*=' @ | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' )
    -->     Type: move
    -->     LA: '*='
    --> __________________
    --> #223: assignmentOperator => ( '=' | '*=' | '/=' @ | '%=' | '+=' | '-=' | '<<=' | '>>=' )
    -->     Type: move
    -->     LA: '/='
    --> __________________
    --> #224: assignmentOperator => ( '=' | '*=' | '/=' | '%=' @ | '+=' | '-=' | '<<=' | '>>=' )
    -->     Type: move
    -->     LA: '%='
    --> __________________
    --> #225: assignmentOperator => ( '=' | '*=' | '/=' | '%=' | '+=' @ | '-=' | '<<=' | '>>=' )
    -->     Type: move
    -->     LA: '+='
    --> __________________
    --> #226: assignmentOperator => ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' @ | '<<=' | '>>=' )
    -->     Type: move
    -->     LA: '-='
    --> __________________
    --> #227: assignmentOperator => ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' @ | '>>=' )
    -->     Type: move
    -->     LA: '<<='

** [FINAL] State #192: castExpression => ( ('(') typeName (')') castExpression @ | unaryExpression )
    --> __________________
    --> #192: castExpression => ( ('(') typeName (')') castExpression @ | unaryExpression )
    -->     Type: reduce
    --> __________________
    --> #193: multiplicativeExpression => [ multiplicativeExpression ( '*' | '/' | '%' ) ] castExpression @
    -->     Type: reduce
    --> __________________
    --> #193: multiplicativeExpression => [ multiplicativeExpression ( '*' | '/' | '%' ) ] castExpression @
    -->     Type: reduce
    --> __________________
    --> #193: multiplicativeExpression => [ multiplicativeExpression ( '*' | '/' | '%' ) ] castExpression @
    -->     Type: reduce
    --> __________________
    --> #193: multiplicativeExpression => [ multiplicativeExpression ( '*' | '/' | '%' ) ] castExpression @
    -->     Type: reduce
    --> __________________
    --> #194: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression @ | sizeof ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: reduce

** [FINAL] State #193: multiplicativeExpression => [ multiplicativeExpression ( '*' | '/' | '%' ) ] castExpression @
    --> __________________
    --> #228: additiveExpression => [ additiveExpression ( '+' | '-' ) ] multiplicativeExpression @
    -->     Type: reduce
    --> __________________
    --> #228: additiveExpression => [ additiveExpression ( '+' | '-' ) ] multiplicativeExpression @
    -->     Type: reduce
    --> __________________
    --> #228: additiveExpression => [ additiveExpression ( '+' | '-' ) ] multiplicativeExpression @
    -->     Type: reduce
    --> __________________
    --> #229: multiplicativeExpression => [ multiplicativeExpression @ ( '*' | '/' | '%' ) ] castExpression
    -->     Type: recursion
    -->     LA: '/' '*' '%'

** [FINAL] State #194: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression @ | sizeof ( unaryExpression | ('(') typeName (')') ) )
    --> __________________
    --> #160: assignmentExpression => ( conditionalExpression | unaryExpression @ assignmentOperator assignmentExpression )
    -->     Type: reduce
    --> __________________
    --> #161: castExpression => ( ('(') typeName (')') castExpression | unaryExpression @ )
    -->     Type: reduce
    --> __________________
    --> #162: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression @ | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: reduce
    --> __________________
    --> #163: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression @ | ('(') typeName (')') ) )
    -->     Type: reduce
    --> __________________
    --> #162: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression @ | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: reduce

** [FINAL] State #195: functionDefinition => [ declarationSpecifiers ] declarator [ declarationList ] compoundStatement @
    --> __________________
    --> #230: externalDeclaration => ( functionDefinition @ | declaration | (';') )
    -->     Type: reduce
    -->     Reduce: externalDeclaration => @ ( functionDefinition | declaration | (';') )

** [FINAL] State #196: statement => ( labeledStatement | compoundStatement @ | expressionStatement | selectionStatement | iterationStatement | jumpStatement )
    --> __________________
    --> #231: blockItem => ( statement @ | declaration )
    -->     Type: reduce
    -->     Reduce: blockItem => @ ( statement | declaration )
    --> __________________
    --> #232: iterationStatement => ( while ('(') expression (')') statement | do statement @ while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while ('(') expression (')') statement | do @ statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    --> __________________
    --> #233: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement @ )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') @ statement )
    --> __________________
    --> #234: iterationStatement => ( while ('(') expression (')') statement @ | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while ('(') expression (')') @ statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    --> __________________
    --> #235: labeledStatement => ( #identifier# | case constantExpression | default ) '=' statement @
    -->     Type: reduce
    -->     Reduce: labeledStatement => ( #identifier# | case constantExpression | default ) '=' @ statement
    --> __________________
    --> #236: selectionStatement => ( if ('(') expression (')') statement [ else statement ] | switch ('(') expression (')') statement @ )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if ('(') expression (')') statement [ else statement ] | switch ('(') expression (')') @ statement )
    --> __________________
    --> #237: selectionStatement => ( if ('(') expression (')') statement @ [ else statement ] | switch ('(') expression (')') statement )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if ('(') expression (')') @ statement [ else statement ] | switch ('(') expression (')') statement )
    --> __________________
    --> #238: selectionStatement => ( if ('(') expression (')') statement [ else statement @ ] | switch ('(') expression (')') statement )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if ('(') expression (')') statement [ else @ statement ] | switch ('(') expression (')') statement )

** State #197: blockItem => @ ( statement | declaration )
    --> __________________
    --> #5: declaration => @ declarationSpecifiers [ initDeclaratorList ] (';')
    -->     Type: shift
    -->     LA: union struct enum int bool
    -->     LA: char long float unsigned double
    -->     LA: void short const volatile #identifier#
    -->     LA: signed auto static extern typedef
    -->     LA: register
    --> __________________
    --> #239: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationStatement | jumpStatement )
    -->     Type: shift
    -->     LA: '{' switch return continue while
    -->     LA: '(' #identifier# default case ';'
    -->     LA: '*' #long# goto #float# for
    -->     LA: #ulong# #int# break '-' '!'
    -->     LA: do '&' #char# '~' sizeof
    -->     LA: #string# '--' '++' #ushort# if
    -->     LA: #double# #short# '+' #uchar# #uint#

** State #198: declarationSpecifiers2 => [ @ declarationSpecifiers ] declarationSpecifier
    --> __________________
    --> #7: declarationSpecifiers => [ @ declarationSpecifiers ] declarationSpecifier
    -->     Type: shift
    -->     LA: register typedef extern static auto
    -->     LA: signed #identifier# volatile const short
    -->     LA: void double unsigned float long
    -->     LA: char bool int enum struct
    -->     LA: union
    --> __________________
    --> #11: declarationSpecifier => @ ( storageClassSpecifier | typeSpecifier | typeQualifier )
    -->     Type: shift
    -->     LA: union struct enum int bool
    -->     LA: char long float unsigned double
    -->     LA: void short const volatile #identifier#
    -->     LA: signed auto static extern typedef
    -->     LA: register

** State #199: identifierList => [ identifierList (',') @ ] #identifier#
    --> __________________
    --> #141: identifierList => [ identifierList (',') ] #identifier# @
    -->     Type: move
    -->     LA: #identifier#

** State #200: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') @ typeName (')') ('{') initializerList [ (',') ] ('}') )
    --> __________________
    --> #218: typeName => @ specifierQualifierList [ abstractDeclarator ]
    -->     Type: shift
    -->     LA: volatile const short signed #identifier#
    -->     LA: void unsigned float long char
    -->     LA: bool int enum double struct
    -->     LA: union

** State #201: primaryExpression => @ ( #identifier# | constant | #string# | ('(') expression (')') )
    --> __________________
    --> #240: primaryExpression => ( #identifier# | constant | #string# | ('(') @ expression (')') )
    -->     Type: pass
    -->     LA: '('
    --> __________________
    --> #241: primaryExpression => ( #identifier# @ | constant | #string# | ('(') expression (')') )
    -->     Type: move
    -->     LA: #identifier#
    --> __________________
    --> #242: constant => @ ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #float# | #double# )
    -->     Type: shift
    -->     LA: #ushort# #short# #uchar# #char# #int#
    -->     LA: #uint# #long# #ulong# #float# #double#
    --> __________________
    --> #243: primaryExpression => ( #identifier# | constant | #string# @ | ('(') expression (')') )
    -->     Type: move
    -->     LA: #string#

** [FINAL] State #202: unaryOperator => ( '&' | '*' | '+' | '-' | '~' | '!' @ )
    --> __________________
    --> #244: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator @ castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: reduce

** [FINAL] State #203: unaryOperator => ( '&' @ | '*' | '+' | '-' | '~' | '!' )
    --> __________________
    --> #244: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator @ castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: reduce

** [FINAL] State #204: unaryOperator => ( '&' | '*' @ | '+' | '-' | '~' | '!' )
    --> __________________
    --> #244: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator @ castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: reduce

** [FINAL] State #205: unaryOperator => ( '&' | '*' | '+' @ | '-' | '~' | '!' )
    --> __________________
    --> #244: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator @ castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: reduce

** [FINAL] State #206: unaryOperator => ( '&' | '*' | '+' | '-' @ | '~' | '!' )
    --> __________________
    --> #244: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator @ castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: reduce

** [FINAL] State #207: unaryOperator => ( '&' | '*' | '+' | '-' | '~' @ | '!' )
    --> __________________
    --> #244: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator @ castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: reduce

** State #208: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') @ typeName (')') ) )
    --> __________________
    --> #218: typeName => @ specifierQualifierList [ abstractDeclarator ]
    -->     Type: shift
    -->     LA: volatile const short signed #identifier#
    -->     LA: void unsigned float long char
    -->     LA: bool int enum double struct
    -->     LA: union

** State #209: logicalAndExpression => [ @ logicalAndExpression '&&' ] inclusiveOrExpression
    --> __________________
    --> #245: inclusiveOrExpression => [ @ inclusiveOrExpression '|' ] exclusiveOrExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** [FINAL] State #210: blockItemList => [ blockItemList ] blockItem @
    --> __________________
    --> #246: blockItemList => [ blockItemList @ ] blockItem
    -->     Type: recursion
    -->     LA: register typedef #long# extern static
    -->     LA: #short# auto signed #char# #identifier#
    -->     LA: volatile const '{' short void
    -->     LA: #double# double unsigned #float# float
    -->     LA: '--' long char bool int
    -->     LA: enum ';' struct #ushort# union
    -->     LA: #ulong# switch #int# return continue
    -->     LA: while #string# '(' case default
    -->     LA: '*' goto for break '~'
    -->     LA: '-' '!' do '&' sizeof
    -->     LA: #uchar# '++' if '+' #uint#
    --> __________________
    --> #247: compoundStatement => ('{') [ blockItemList @ ] ('}')
    -->     Type: reduce
    -->     Reduce: compoundStatement => ('{') @ [ blockItemList ] ('}')

** State #211: declarationList => [ declarationList @ ] declaration
    --> __________________
    --> #5: declaration => @ declarationSpecifiers [ initDeclaratorList ] (';')
    -->     Type: shift
    -->     LA: union struct enum int bool
    -->     LA: char long float unsigned double
    -->     LA: void short const volatile #identifier#
    -->     LA: signed auto static extern typedef
    -->     LA: register

** State #212: functionDefinition => [ declarationSpecifiers ] declarator [ declarationList @ ] compoundStatement
    --> __________________
    --> #98: compoundStatement => @ ('{') [ blockItemList ] ('}')
    -->     Type: shift
    -->     LA: '{'

** [FINAL] State #213: forCondition => ( forDeclaration | [ expression ] ) ';' [ forExpression ] ';' @ [ forExpression ]
    --> __________________
    --> #214: forExpression => [ @ forExpression (',') ] assignmentExpression
    -->     Type: shift
    -->     LA: #double# '&' #identifier# #uint# '*'
    -->     LA: #long# #uchar# '+' #short# '~'
    -->     LA: '(' #ushort# '-' #int# '++'
    -->     LA: '--' '!' sizeof #string# #char#
    -->     LA: #ulong# #float#
    --> __________________
    --> #248: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition @ (')') statement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') @ forCondition (')') statement )

** State #214: forExpression => [ @ forExpression (',') ] assignmentExpression
    --> __________________
    --> #108: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExpression )
    -->     Type: shift
    -->     LA: #float# #ulong# #long# #int# #char#
    -->     LA: #identifier# #string# sizeof '!' '--'
    -->     LA: '++' '-' #ushort# '(' #short#
    -->     LA: '~' '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #215: structDeclaration => @ specifierQualifierList [ structDeclaratorList ] (';')
    --> __________________
    --> #75: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    -->     Type: shift
    -->     LA: volatile const short signed #identifier#
    -->     LA: void unsigned float long char
    -->     LA: bool int enum double struct
    -->     LA: union

** [FINAL] State #216: structOrUnionSpecifier => structOrUnion ( #identifier# | [ #identifier# ] ('{') structDeclarationList ('}') @ )
    --> __________________
    --> #186: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier @ | enumSpecifier | typedefName | typeSpecifier pointer )
    -->     Type: reduce
    -->     Reduce: typeSpecifier => @ ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )

** [FINAL] State #217: enumerationConstant => #identifier# @
    --> __________________
    --> #249: enumerator => enumerationConstant @ [ ('=') constantExpression ]
    -->     Type: reduce
    -->     Reduce: enumerator => @ enumerationConstant [ ('=') constantExpression ]

** State #218: typeName => @ specifierQualifierList [ abstractDeclarator ]
    --> __________________
    --> #75: specifierQualifierList => @ ( typeSpecifier | typeQualifier ) [ specifierQualifierList ]
    -->     Type: shift
    -->     LA: volatile const short signed #identifier#
    -->     LA: void unsigned float long char
    -->     LA: bool int enum double struct
    -->     LA: union

** State #219: designation => @ designatorList '='
    --> __________________
    --> #250: designatorList => [ @ designatorList ] designator
    -->     Type: shift
    -->     LA: '.' '['

** [FINAL] State #220: assignmentOperator => ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' @ )
    --> __________________
    --> #251: assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator @ assignmentExpression )
    -->     Type: reduce

** [FINAL] State #221: assignmentOperator => ( '=' @ | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' )
    --> __________________
    --> #251: assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator @ assignmentExpression )
    -->     Type: reduce

** [FINAL] State #222: assignmentOperator => ( '=' | '*=' @ | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' )
    --> __________________
    --> #251: assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator @ assignmentExpression )
    -->     Type: reduce

** [FINAL] State #223: assignmentOperator => ( '=' | '*=' | '/=' @ | '%=' | '+=' | '-=' | '<<=' | '>>=' )
    --> __________________
    --> #251: assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator @ assignmentExpression )
    -->     Type: reduce

** [FINAL] State #224: assignmentOperator => ( '=' | '*=' | '/=' | '%=' @ | '+=' | '-=' | '<<=' | '>>=' )
    --> __________________
    --> #251: assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator @ assignmentExpression )
    -->     Type: reduce

** [FINAL] State #225: assignmentOperator => ( '=' | '*=' | '/=' | '%=' | '+=' @ | '-=' | '<<=' | '>>=' )
    --> __________________
    --> #251: assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator @ assignmentExpression )
    -->     Type: reduce

** [FINAL] State #226: assignmentOperator => ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' @ | '<<=' | '>>=' )
    --> __________________
    --> #251: assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator @ assignmentExpression )
    -->     Type: reduce

** [FINAL] State #227: assignmentOperator => ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' @ | '>>=' )
    --> __________________
    --> #251: assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator @ assignmentExpression )
    -->     Type: reduce

** [FINAL] State #228: additiveExpression => [ additiveExpression ( '+' | '-' ) ] multiplicativeExpression @
    --> __________________
    --> #252: additiveExpression => [ additiveExpression @ ( '+' | '-' ) ] multiplicativeExpression
    -->     Type: recursion
    -->     LA: '+' '-'
    --> __________________
    --> #253: shiftExpression => [ shiftExpression ( '<<' | '>>' ) ] additiveExpression @
    -->     Type: reduce
    --> __________________
    --> #253: shiftExpression => [ shiftExpression ( '<<' | '>>' ) ] additiveExpression @
    -->     Type: reduce
    --> __________________
    --> #253: shiftExpression => [ shiftExpression ( '<<' | '>>' ) ] additiveExpression @
    -->     Type: reduce

** State #229: multiplicativeExpression => [ multiplicativeExpression @ ( '*' | '/' | '%' ) ] castExpression
    --> __________________
    --> #254: multiplicativeExpression => [ multiplicativeExpression ( '*' | '/' | '%' @ ) ] castExpression
    -->     Type: move
    -->     LA: '%'
    --> __________________
    --> #255: multiplicativeExpression => [ multiplicativeExpression ( '*' @ | '/' | '%' ) ] castExpression
    -->     Type: move
    -->     LA: '*'
    --> __________________
    --> #256: multiplicativeExpression => [ multiplicativeExpression ( '*' | '/' @ | '%' ) ] castExpression
    -->     Type: move
    -->     LA: '/'

** [FINAL] State #230: externalDeclaration => ( functionDefinition @ | declaration | (';') )
    --> __________________
    --> #6: translationUnit => [ translationUnit ] externalDeclaration @
    -->     Type: reduce
    -->     Reduce: translationUnit => [ @ translationUnit ] externalDeclaration
    --> __________________
    --> #6: translationUnit => [ translationUnit ] externalDeclaration @
    -->     Type: reduce
    -->     Reduce: translationUnit => [ translationUnit @ ] externalDeclaration

** [FINAL] State #231: blockItem => ( statement @ | declaration )
    --> __________________
    --> #210: blockItemList => [ blockItemList ] blockItem @
    -->     Type: reduce
    -->     Reduce: blockItemList => [ @ blockItemList ] blockItem
    --> __________________
    --> #210: blockItemList => [ blockItemList ] blockItem @
    -->     Type: reduce
    -->     Reduce: blockItemList => [ blockItemList @ ] blockItem

** State #232: iterationStatement => ( while ('(') expression (')') statement | do statement @ while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    --> __________________
    --> #257: iterationStatement => ( while ('(') expression (')') statement | do statement while @ ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    -->     Type: move
    -->     LA: while

** [FINAL] State #233: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement @ )
    --> __________________
    --> #258: statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationStatement @ | jumpStatement )
    -->     Type: reduce
    -->     Reduce: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationStatement | jumpStatement )

** [FINAL] State #234: iterationStatement => ( while ('(') expression (')') statement @ | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    --> __________________
    --> #258: statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationStatement @ | jumpStatement )
    -->     Type: reduce
    -->     Reduce: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationStatement | jumpStatement )

** [FINAL] State #235: labeledStatement => ( #identifier# | case constantExpression | default ) '=' statement @
    --> __________________
    --> #259: statement => ( labeledStatement @ | compoundStatement | expressionStatement | selectionStatement | iterationStatement | jumpStatement )
    -->     Type: reduce
    -->     Reduce: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationStatement | jumpStatement )

** [FINAL] State #236: selectionStatement => ( if ('(') expression (')') statement [ else statement ] | switch ('(') expression (')') statement @ )
    --> __________________
    --> #260: statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement @ | iterationStatement | jumpStatement )
    -->     Type: reduce
    -->     Reduce: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationStatement | jumpStatement )

** [FINAL] State #237: selectionStatement => ( if ('(') expression (')') statement @ [ else statement ] | switch ('(') expression (')') statement )
    --> __________________
    --> #261: selectionStatement => ( if ('(') expression (')') statement [ else @ statement ] | switch ('(') expression (')') statement )
    -->     Type: move
    -->     LA: else
    --> __________________
    --> #260: statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement @ | iterationStatement | jumpStatement )
    -->     Type: reduce
    -->     Reduce: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationStatement | jumpStatement )

** [FINAL] State #238: selectionStatement => ( if ('(') expression (')') statement [ else statement @ ] | switch ('(') expression (')') statement )
    --> __________________
    --> #260: statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement @ | iterationStatement | jumpStatement )
    -->     Type: reduce
    -->     Reduce: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationStatement | jumpStatement )

** State #239: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationStatement | jumpStatement )
    --> __________________
    --> #262: jumpStatement => @ ( goto #identifier# | continue | break | return [ expression ] ) (';')
    -->     Type: shift
    -->     LA: goto continue return break
    --> __________________
    --> #263: labeledStatement => @ ( #identifier# | case constantExpression | default ) '=' statement
    -->     Type: shift
    -->     LA: #identifier# default case
    --> __________________
    --> #98: compoundStatement => @ ('{') [ blockItemList ] ('}')
    -->     Type: shift
    -->     LA: '{'
    --> __________________
    --> #264: expressionStatement => [ @ expression ] (';')
    -->     Type: shift
    -->     LA: ';' '*' #float# '~' #ulong#
    -->     LA: #long# #int# '!' #char# sizeof
    -->     LA: #identifier# #string# '--' '++' '-'
    -->     LA: #ushort# '(' #double# #short# '+'
    -->     LA: #uchar# #uint# '&'
    --> __________________
    --> #265: selectionStatement => @ ( if ('(') expression (')') statement [ else statement ] | switch ('(') expression (')') statement )
    -->     Type: shift
    -->     LA: if switch
    --> __________________
    --> #266: iterationStatement => @ ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    -->     Type: shift
    -->     LA: while do for

** State #240: primaryExpression => ( #identifier# | constant | #string# | ('(') @ expression (')') )
    --> __________________
    --> #267: expression => [ @ expression (',') ] assignmentExpression
    -->     Type: shift
    -->     LA: #double# '&' #identifier# #uint# '*'
    -->     LA: #long# #uchar# '+' #short# '~'
    -->     LA: '(' #ushort# '-' #int# '++'
    -->     LA: '--' '!' sizeof #string# #char#
    -->     LA: #ulong# #float#

** [FINAL] State #241: primaryExpression => ( #identifier# @ | constant | #string# | ('(') expression (')') )
    --> __________________
    --> #268: postfixExpression => ( primaryExpression @ | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    -->     Type: reduce

** State #242: constant => @ ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #float# | #double# )
    --> __________________
    --> #269: constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #float# | #double# @ )
    -->     Type: move
    -->     LA: #double#
    --> __________________
    --> #270: constant => ( #char# @ | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #float# | #double# )
    -->     Type: move
    -->     LA: #char#
    --> __________________
    --> #271: constant => ( #char# | #uchar# @ | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #float# | #double# )
    -->     Type: move
    -->     LA: #uchar#
    --> __________________
    --> #272: constant => ( #char# | #uchar# | #short# @ | #ushort# | #int# | #uint# | #long# | #ulong# | #float# | #double# )
    -->     Type: move
    -->     LA: #short#
    --> __________________
    --> #273: constant => ( #char# | #uchar# | #short# | #ushort# @ | #int# | #uint# | #long# | #ulong# | #float# | #double# )
    -->     Type: move
    -->     LA: #ushort#
    --> __________________
    --> #274: constant => ( #char# | #uchar# | #short# | #ushort# | #int# @ | #uint# | #long# | #ulong# | #float# | #double# )
    -->     Type: move
    -->     LA: #int#
    --> __________________
    --> #275: constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# @ | #long# | #ulong# | #float# | #double# )
    -->     Type: move
    -->     LA: #uint#
    --> __________________
    --> #276: constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# @ | #ulong# | #float# | #double# )
    -->     Type: move
    -->     LA: #long#
    --> __________________
    --> #277: constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# @ | #float# | #double# )
    -->     Type: move
    -->     LA: #ulong#
    --> __________________
    --> #278: constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #float# @ | #double# )
    -->     Type: move
    -->     LA: #float#

** [FINAL] State #243: primaryExpression => ( #identifier# | constant | #string# @ | ('(') expression (')') )
    --> __________________
    --> #268: postfixExpression => ( primaryExpression @ | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    -->     Type: reduce

** State #244: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator @ castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    --> __________________
    --> #158: castExpression => @ ( ('(') typeName (')') castExpression | unaryExpression )
    -->     Type: shift
    -->     LA: #double# '&' '*' #uint# '+'
    -->     LA: #uchar# #float# '~' #short# '('
    -->     LA: '-' #ushort# '++' '--' '!'
    -->     LA: #int# #char# sizeof #string# #identifier#
    -->     LA: #long# #ulong#

** State #245: inclusiveOrExpression => [ @ inclusiveOrExpression '|' ] exclusiveOrExpression
    --> __________________
    --> #279: exclusiveOrExpression => [ @ exclusiveOrExpression '^' ] andExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #246: blockItemList => [ blockItemList @ ] blockItem
    --> __________________
    --> #197: blockItem => @ ( statement | declaration )
    -->     Type: shift
    -->     LA: register typedef #long# extern static
    -->     LA: #short# auto signed #char# #identifier#
    -->     LA: volatile const '{' short void
    -->     LA: #double# double unsigned #float# float
    -->     LA: '--' long char bool int
    -->     LA: enum ';' struct #ushort# union
    -->     LA: #ulong# switch #int# return continue
    -->     LA: while #string# '(' case default
    -->     LA: '*' goto for break '~'
    -->     LA: '-' '!' do '&' sizeof
    -->     LA: #uchar# '++' if '+' #uint#

** State #247: compoundStatement => ('{') [ blockItemList @ ] ('}')
    --> __________________
    --> #164: compoundStatement => ('{') [ blockItemList ] ('}') @
    -->     Type: pass
    -->     LA: '}'

** State #248: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition @ (')') statement )
    --> __________________
    --> #280: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') @ statement )
    -->     Type: pass
    -->     LA: ')'

** [FINAL] State #249: enumerator => enumerationConstant @ [ ('=') constantExpression ]
    --> __________________
    --> #281: enumerator => enumerationConstant [ ('=') @ constantExpression ]
    -->     Type: pass
    -->     LA: '='
    --> __________________
    --> #282: enumeratorList => [ enumeratorList (',') ] enumerator @
    -->     Type: reduce
    -->     Reduce: enumeratorList => [ @ enumeratorList (',') ] enumerator
    --> __________________
    --> #282: enumeratorList => [ enumeratorList (',') ] enumerator @
    -->     Type: reduce
    -->     Reduce: enumeratorList => [ enumeratorList (',') @ ] enumerator

** State #250: designatorList => [ @ designatorList ] designator
    --> __________________
    --> #283: designator => @ ( '[' constantExpression ']' | '.' #identifier# )
    -->     Type: shift
    -->     LA: '[' '.'

** State #251: assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator @ assignmentExpression )
    --> __________________
    --> #108: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExpression )
    -->     Type: shift
    -->     LA: #float# #ulong# #long# #int# #char#
    -->     LA: #identifier# #string# sizeof '!' '--'
    -->     LA: '++' '-' #ushort# '(' #short#
    -->     LA: '~' '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #252: additiveExpression => [ additiveExpression @ ( '+' | '-' ) ] multiplicativeExpression
    --> __________________
    --> #284: additiveExpression => [ additiveExpression ( '+' | '-' @ ) ] multiplicativeExpression
    -->     Type: move
    -->     LA: '-'
    --> __________________
    --> #285: additiveExpression => [ additiveExpression ( '+' @ | '-' ) ] multiplicativeExpression
    -->     Type: move
    -->     LA: '+'

** [FINAL] State #253: shiftExpression => [ shiftExpression ( '<<' | '>>' ) ] additiveExpression @
    --> __________________
    --> #286: relationalExpression => [ relationalExpression ( '<' | '>' | '<=' | '>=' ) ] shiftExpression @
    -->     Type: reduce
    --> __________________
    --> #286: relationalExpression => [ relationalExpression ( '<' | '>' | '<=' | '>=' ) ] shiftExpression @
    -->     Type: reduce
    --> __________________
    --> #286: relationalExpression => [ relationalExpression ( '<' | '>' | '<=' | '>=' ) ] shiftExpression @
    -->     Type: reduce
    --> __________________
    --> #286: relationalExpression => [ relationalExpression ( '<' | '>' | '<=' | '>=' ) ] shiftExpression @
    -->     Type: reduce
    --> __________________
    --> #286: relationalExpression => [ relationalExpression ( '<' | '>' | '<=' | '>=' ) ] shiftExpression @
    -->     Type: reduce
    --> __________________
    --> #287: shiftExpression => [ shiftExpression @ ( '<<' | '>>' ) ] additiveExpression
    -->     Type: recursion
    -->     LA: '<<' '>>'

** State #254: multiplicativeExpression => [ multiplicativeExpression ( '*' | '/' | '%' @ ) ] castExpression
    --> __________________
    --> #158: castExpression => @ ( ('(') typeName (')') castExpression | unaryExpression )
    -->     Type: shift
    -->     LA: #double# '&' '*' #uint# '+'
    -->     LA: #uchar# #float# '~' #short# '('
    -->     LA: '-' #ushort# '++' '--' '!'
    -->     LA: #int# #char# sizeof #string# #identifier#
    -->     LA: #long# #ulong#

** State #255: multiplicativeExpression => [ multiplicativeExpression ( '*' @ | '/' | '%' ) ] castExpression
    --> __________________
    --> #158: castExpression => @ ( ('(') typeName (')') castExpression | unaryExpression )
    -->     Type: shift
    -->     LA: #double# '&' '*' #uint# '+'
    -->     LA: #uchar# #float# '~' #short# '('
    -->     LA: '-' #ushort# '++' '--' '!'
    -->     LA: #int# #char# sizeof #string# #identifier#
    -->     LA: #long# #ulong#

** State #256: multiplicativeExpression => [ multiplicativeExpression ( '*' | '/' @ | '%' ) ] castExpression
    --> __________________
    --> #158: castExpression => @ ( ('(') typeName (')') castExpression | unaryExpression )
    -->     Type: shift
    -->     LA: #double# '&' '*' #uint# '+'
    -->     LA: #uchar# #float# '~' #short# '('
    -->     LA: '-' #ushort# '++' '--' '!'
    -->     LA: #int# #char# sizeof #string# #identifier#
    -->     LA: #long# #ulong#

** State #257: iterationStatement => ( while ('(') expression (')') statement | do statement while @ ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    --> __________________
    --> #288: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') @ expression (')') ';' | for ('(') forCondition (')') statement )
    -->     Type: pass
    -->     LA: '('

** [FINAL] State #258: statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationStatement @ | jumpStatement )
    --> __________________
    --> #231: blockItem => ( statement @ | declaration )
    -->     Type: reduce
    -->     Reduce: blockItem => @ ( statement | declaration )
    --> __________________
    --> #232: iterationStatement => ( while ('(') expression (')') statement | do statement @ while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while ('(') expression (')') statement | do @ statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    --> __________________
    --> #233: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement @ )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') @ statement )
    --> __________________
    --> #234: iterationStatement => ( while ('(') expression (')') statement @ | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while ('(') expression (')') @ statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    --> __________________
    --> #235: labeledStatement => ( #identifier# | case constantExpression | default ) '=' statement @
    -->     Type: reduce
    -->     Reduce: labeledStatement => ( #identifier# | case constantExpression | default ) '=' @ statement
    --> __________________
    --> #236: selectionStatement => ( if ('(') expression (')') statement [ else statement ] | switch ('(') expression (')') statement @ )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if ('(') expression (')') statement [ else statement ] | switch ('(') expression (')') @ statement )
    --> __________________
    --> #237: selectionStatement => ( if ('(') expression (')') statement @ [ else statement ] | switch ('(') expression (')') statement )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if ('(') expression (')') @ statement [ else statement ] | switch ('(') expression (')') statement )
    --> __________________
    --> #238: selectionStatement => ( if ('(') expression (')') statement [ else statement @ ] | switch ('(') expression (')') statement )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if ('(') expression (')') statement [ else @ statement ] | switch ('(') expression (')') statement )

** [FINAL] State #259: statement => ( labeledStatement @ | compoundStatement | expressionStatement | selectionStatement | iterationStatement | jumpStatement )
    --> __________________
    --> #231: blockItem => ( statement @ | declaration )
    -->     Type: reduce
    -->     Reduce: blockItem => @ ( statement | declaration )
    --> __________________
    --> #232: iterationStatement => ( while ('(') expression (')') statement | do statement @ while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while ('(') expression (')') statement | do @ statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    --> __________________
    --> #233: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement @ )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') @ statement )
    --> __________________
    --> #234: iterationStatement => ( while ('(') expression (')') statement @ | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while ('(') expression (')') @ statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    --> __________________
    --> #235: labeledStatement => ( #identifier# | case constantExpression | default ) '=' statement @
    -->     Type: reduce
    -->     Reduce: labeledStatement => ( #identifier# | case constantExpression | default ) '=' @ statement
    --> __________________
    --> #236: selectionStatement => ( if ('(') expression (')') statement [ else statement ] | switch ('(') expression (')') statement @ )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if ('(') expression (')') statement [ else statement ] | switch ('(') expression (')') @ statement )
    --> __________________
    --> #237: selectionStatement => ( if ('(') expression (')') statement @ [ else statement ] | switch ('(') expression (')') statement )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if ('(') expression (')') @ statement [ else statement ] | switch ('(') expression (')') statement )
    --> __________________
    --> #238: selectionStatement => ( if ('(') expression (')') statement [ else statement @ ] | switch ('(') expression (')') statement )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if ('(') expression (')') statement [ else @ statement ] | switch ('(') expression (')') statement )

** [FINAL] State #260: statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement @ | iterationStatement | jumpStatement )
    --> __________________
    --> #231: blockItem => ( statement @ | declaration )
    -->     Type: reduce
    -->     Reduce: blockItem => @ ( statement | declaration )
    --> __________________
    --> #232: iterationStatement => ( while ('(') expression (')') statement | do statement @ while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while ('(') expression (')') statement | do @ statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    --> __________________
    --> #233: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement @ )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') @ statement )
    --> __________________
    --> #234: iterationStatement => ( while ('(') expression (')') statement @ | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while ('(') expression (')') @ statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    --> __________________
    --> #235: labeledStatement => ( #identifier# | case constantExpression | default ) '=' statement @
    -->     Type: reduce
    -->     Reduce: labeledStatement => ( #identifier# | case constantExpression | default ) '=' @ statement
    --> __________________
    --> #236: selectionStatement => ( if ('(') expression (')') statement [ else statement ] | switch ('(') expression (')') statement @ )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if ('(') expression (')') statement [ else statement ] | switch ('(') expression (')') @ statement )
    --> __________________
    --> #237: selectionStatement => ( if ('(') expression (')') statement @ [ else statement ] | switch ('(') expression (')') statement )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if ('(') expression (')') @ statement [ else statement ] | switch ('(') expression (')') statement )
    --> __________________
    --> #238: selectionStatement => ( if ('(') expression (')') statement [ else statement @ ] | switch ('(') expression (')') statement )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if ('(') expression (')') statement [ else @ statement ] | switch ('(') expression (')') statement )

** State #261: selectionStatement => ( if ('(') expression (')') statement [ else @ statement ] | switch ('(') expression (')') statement )
    --> __________________
    --> #239: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationStatement | jumpStatement )
    -->     Type: shift
    -->     LA: '{' switch return continue while
    -->     LA: '(' #identifier# default case ';'
    -->     LA: '*' #long# goto #float# for
    -->     LA: #ulong# #int# break '-' '!'
    -->     LA: do '&' #char# '~' sizeof
    -->     LA: #string# '--' '++' #ushort# if
    -->     LA: #double# #short# '+' #uchar# #uint#

** State #262: jumpStatement => @ ( goto #identifier# | continue | break | return [ expression ] ) (';')
    --> __________________
    --> #289: jumpStatement => ( goto #identifier# | continue | break | return @ [ expression ] ) (';')
    -->     Type: move
    -->     LA: return
    --> __________________
    --> #290: jumpStatement => ( goto @ #identifier# | continue | break | return [ expression ] ) (';')
    -->     Type: move
    -->     LA: goto
    --> __________________
    --> #291: jumpStatement => ( goto #identifier# | continue @ | break | return [ expression ] ) (';')
    -->     Type: move
    -->     LA: continue
    --> __________________
    --> #292: jumpStatement => ( goto #identifier# | continue | break @ | return [ expression ] ) (';')
    -->     Type: move
    -->     LA: break

** State #263: labeledStatement => @ ( #identifier# | case constantExpression | default ) '=' statement
    --> __________________
    --> #293: labeledStatement => ( #identifier# | case constantExpression | default @ ) '=' statement
    -->     Type: move
    -->     LA: default
    --> __________________
    --> #294: labeledStatement => ( #identifier# @ | case constantExpression | default ) '=' statement
    -->     Type: move
    -->     LA: #identifier#
    --> __________________
    --> #295: labeledStatement => ( #identifier# | case @ constantExpression | default ) '=' statement
    -->     Type: move
    -->     LA: case

** State #264: expressionStatement => [ @ expression ] (';')
    --> __________________
    --> #267: expression => [ @ expression (',') ] assignmentExpression
    -->     Type: shift
    -->     LA: #double# '&' #identifier# #uint# '*'
    -->     LA: #long# #uchar# '+' #short# '~'
    -->     LA: '(' #ushort# '-' #int# '++'
    -->     LA: '--' '!' sizeof #string# #char#
    -->     LA: #ulong# #float#
    --> __________________
    --> #296: expressionStatement => [ expression ] (';') @
    -->     Type: pass
    -->     LA: ';'

** State #265: selectionStatement => @ ( if ('(') expression (')') statement [ else statement ] | switch ('(') expression (')') statement )
    --> __________________
    --> #297: selectionStatement => ( if ('(') expression (')') statement [ else statement ] | switch @ ('(') expression (')') statement )
    -->     Type: move
    -->     LA: switch
    --> __________________
    --> #298: selectionStatement => ( if @ ('(') expression (')') statement [ else statement ] | switch ('(') expression (')') statement )
    -->     Type: move
    -->     LA: if

** State #266: iterationStatement => @ ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    --> __________________
    --> #299: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for @ ('(') forCondition (')') statement )
    -->     Type: move
    -->     LA: for
    --> __________________
    --> #300: iterationStatement => ( while @ ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    -->     Type: move
    -->     LA: while
    --> __________________
    --> #301: iterationStatement => ( while ('(') expression (')') statement | do @ statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    -->     Type: move
    -->     LA: do

** State #267: expression => [ @ expression (',') ] assignmentExpression
    --> __________________
    --> #108: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExpression )
    -->     Type: shift
    -->     LA: #float# #ulong# #long# #int# #char#
    -->     LA: #identifier# #string# sizeof '!' '--'
    -->     LA: '++' '-' #ushort# '(' #short#
    -->     LA: '~' '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** [FINAL] State #268: postfixExpression => ( primaryExpression @ | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    --> __________________
    --> #302: postfixExpression => ( primaryExpression | postfixExpression @ ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    -->     Type: recursion
    --> __________________
    --> #303: unaryExpression => ( postfixExpression @ | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: reduce

** [FINAL] State #269: constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #float# | #double# @ )
    --> __________________
    --> #304: primaryExpression => ( #identifier# | constant @ | #string# | ('(') expression (')') )
    -->     Type: reduce
    -->     Reduce: primaryExpression => @ ( #identifier# | constant | #string# | ('(') expression (')') )

** [FINAL] State #270: constant => ( #char# @ | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #float# | #double# )
    --> __________________
    --> #304: primaryExpression => ( #identifier# | constant @ | #string# | ('(') expression (')') )
    -->     Type: reduce
    -->     Reduce: primaryExpression => @ ( #identifier# | constant | #string# | ('(') expression (')') )

** [FINAL] State #271: constant => ( #char# | #uchar# @ | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #float# | #double# )
    --> __________________
    --> #304: primaryExpression => ( #identifier# | constant @ | #string# | ('(') expression (')') )
    -->     Type: reduce
    -->     Reduce: primaryExpression => @ ( #identifier# | constant | #string# | ('(') expression (')') )

** [FINAL] State #272: constant => ( #char# | #uchar# | #short# @ | #ushort# | #int# | #uint# | #long# | #ulong# | #float# | #double# )
    --> __________________
    --> #304: primaryExpression => ( #identifier# | constant @ | #string# | ('(') expression (')') )
    -->     Type: reduce
    -->     Reduce: primaryExpression => @ ( #identifier# | constant | #string# | ('(') expression (')') )

** [FINAL] State #273: constant => ( #char# | #uchar# | #short# | #ushort# @ | #int# | #uint# | #long# | #ulong# | #float# | #double# )
    --> __________________
    --> #304: primaryExpression => ( #identifier# | constant @ | #string# | ('(') expression (')') )
    -->     Type: reduce
    -->     Reduce: primaryExpression => @ ( #identifier# | constant | #string# | ('(') expression (')') )

** [FINAL] State #274: constant => ( #char# | #uchar# | #short# | #ushort# | #int# @ | #uint# | #long# | #ulong# | #float# | #double# )
    --> __________________
    --> #304: primaryExpression => ( #identifier# | constant @ | #string# | ('(') expression (')') )
    -->     Type: reduce
    -->     Reduce: primaryExpression => @ ( #identifier# | constant | #string# | ('(') expression (')') )

** [FINAL] State #275: constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# @ | #long# | #ulong# | #float# | #double# )
    --> __________________
    --> #304: primaryExpression => ( #identifier# | constant @ | #string# | ('(') expression (')') )
    -->     Type: reduce
    -->     Reduce: primaryExpression => @ ( #identifier# | constant | #string# | ('(') expression (')') )

** [FINAL] State #276: constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# @ | #ulong# | #float# | #double# )
    --> __________________
    --> #304: primaryExpression => ( #identifier# | constant @ | #string# | ('(') expression (')') )
    -->     Type: reduce
    -->     Reduce: primaryExpression => @ ( #identifier# | constant | #string# | ('(') expression (')') )

** [FINAL] State #277: constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# @ | #float# | #double# )
    --> __________________
    --> #304: primaryExpression => ( #identifier# | constant @ | #string# | ('(') expression (')') )
    -->     Type: reduce
    -->     Reduce: primaryExpression => @ ( #identifier# | constant | #string# | ('(') expression (')') )

** [FINAL] State #278: constant => ( #char# | #uchar# | #short# | #ushort# | #int# | #uint# | #long# | #ulong# | #float# @ | #double# )
    --> __________________
    --> #304: primaryExpression => ( #identifier# | constant @ | #string# | ('(') expression (')') )
    -->     Type: reduce
    -->     Reduce: primaryExpression => @ ( #identifier# | constant | #string# | ('(') expression (')') )

** State #279: exclusiveOrExpression => [ @ exclusiveOrExpression '^' ] andExpression
    --> __________________
    --> #305: andExpression => [ @ andExpression '&' ] equalityExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #280: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') @ statement )
    --> __________________
    --> #239: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationStatement | jumpStatement )
    -->     Type: shift
    -->     LA: '{' switch return continue while
    -->     LA: '(' #identifier# default case ';'
    -->     LA: '*' #long# goto #float# for
    -->     LA: #ulong# #int# break '-' '!'
    -->     LA: do '&' #char# '~' sizeof
    -->     LA: #string# '--' '++' #ushort# if
    -->     LA: #double# #short# '+' #uchar# #uint#

** State #281: enumerator => enumerationConstant [ ('=') @ constantExpression ]
    --> __________________
    --> #139: constantExpression => @ conditionalExpression
    -->     Type: shift
    -->     LA: #double# '&' '*' #uint# '+'
    -->     LA: #uchar# #float# '~' #short# '('
    -->     LA: '-' #ushort# '++' '--' '!'
    -->     LA: #int# #char# sizeof #string# #identifier#
    -->     LA: #long# #ulong#

** [FINAL] State #282: enumeratorList => [ enumeratorList (',') ] enumerator @
    --> __________________
    --> #306: enumSpecifier => (enum) ( [ #identifier# ] ('{') enumeratorList @ [ (',') ] ('{') | #identifier# )
    -->     Type: reduce
    -->     Reduce: enumSpecifier => (enum) ( [ #identifier# ] ('{') @ enumeratorList [ (',') ] ('{') | #identifier# )
    --> __________________
    --> #307: enumeratorList => [ enumeratorList @ (',') ] enumerator
    -->     Type: recursion
    -->     LA: ','

** State #283: designator => @ ( '[' constantExpression ']' | '.' #identifier# )
    --> __________________
    --> #308: designator => ( '[' constantExpression ']' | '.' @ #identifier# )
    -->     Type: move
    -->     LA: '.'
    --> __________________
    --> #309: designator => ( '[' @ constantExpression ']' | '.' #identifier# )
    -->     Type: move
    -->     LA: '['

** State #284: additiveExpression => [ additiveExpression ( '+' | '-' @ ) ] multiplicativeExpression
    --> __________________
    --> #310: multiplicativeExpression => [ @ multiplicativeExpression ( '*' | '/' | '%' ) ] castExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #285: additiveExpression => [ additiveExpression ( '+' @ | '-' ) ] multiplicativeExpression
    --> __________________
    --> #310: multiplicativeExpression => [ @ multiplicativeExpression ( '*' | '/' | '%' ) ] castExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** [FINAL] State #286: relationalExpression => [ relationalExpression ( '<' | '>' | '<=' | '>=' ) ] shiftExpression @
    --> __________________
    --> #311: equalityExpression => [ equalityExpression ( '==' | '!=' ) ] relationalExpression @
    -->     Type: reduce
    --> __________________
    --> #311: equalityExpression => [ equalityExpression ( '==' | '!=' ) ] relationalExpression @
    -->     Type: reduce
    --> __________________
    --> #311: equalityExpression => [ equalityExpression ( '==' | '!=' ) ] relationalExpression @
    -->     Type: reduce
    --> __________________
    --> #312: relationalExpression => [ relationalExpression @ ( '<' | '>' | '<=' | '>=' ) ] shiftExpression
    -->     Type: recursion
    -->     LA: '<=' '>' '<' '>='

** State #287: shiftExpression => [ shiftExpression @ ( '<<' | '>>' ) ] additiveExpression
    --> __________________
    --> #313: shiftExpression => [ shiftExpression ( '<<' | '>>' @ ) ] additiveExpression
    -->     Type: move
    -->     LA: '>>'
    --> __________________
    --> #314: shiftExpression => [ shiftExpression ( '<<' @ | '>>' ) ] additiveExpression
    -->     Type: move
    -->     LA: '<<'

** State #288: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') @ expression (')') ';' | for ('(') forCondition (')') statement )
    --> __________________
    --> #267: expression => [ @ expression (',') ] assignmentExpression
    -->     Type: shift
    -->     LA: #double# '&' #identifier# #uint# '*'
    -->     LA: #long# #uchar# '+' #short# '~'
    -->     LA: '(' #ushort# '-' #int# '++'
    -->     LA: '--' '!' sizeof #string# #char#
    -->     LA: #ulong# #float#

** State #289: jumpStatement => ( goto #identifier# | continue | break | return @ [ expression ] ) (';')
    --> __________________
    --> #315: jumpStatement => ( goto #identifier# | continue | break | return [ expression ] ) (';') @
    -->     Type: pass
    -->     LA: ';'
    --> __________________
    --> #267: expression => [ @ expression (',') ] assignmentExpression
    -->     Type: shift
    -->     LA: #double# '&' #identifier# #uint# '*'
    -->     LA: #long# #uchar# '+' #short# '~'
    -->     LA: '(' #ushort# '-' #int# '++'
    -->     LA: '--' '!' sizeof #string# #char#
    -->     LA: #ulong# #float#

** State #290: jumpStatement => ( goto @ #identifier# | continue | break | return [ expression ] ) (';')
    --> __________________
    --> #316: jumpStatement => ( goto #identifier# @ | continue | break | return [ expression ] ) (';')
    -->     Type: move
    -->     LA: #identifier#

** State #291: jumpStatement => ( goto #identifier# | continue @ | break | return [ expression ] ) (';')
    --> __________________
    --> #315: jumpStatement => ( goto #identifier# | continue | break | return [ expression ] ) (';') @
    -->     Type: pass
    -->     LA: ';'

** State #292: jumpStatement => ( goto #identifier# | continue | break @ | return [ expression ] ) (';')
    --> __________________
    --> #315: jumpStatement => ( goto #identifier# | continue | break | return [ expression ] ) (';') @
    -->     Type: pass
    -->     LA: ';'

** State #293: labeledStatement => ( #identifier# | case constantExpression | default @ ) '=' statement
    --> __________________
    --> #317: labeledStatement => ( #identifier# | case constantExpression | default ) '=' @ statement
    -->     Type: move
    -->     LA: '='

** State #294: labeledStatement => ( #identifier# @ | case constantExpression | default ) '=' statement
    --> __________________
    --> #317: labeledStatement => ( #identifier# | case constantExpression | default ) '=' @ statement
    -->     Type: move
    -->     LA: '='

** State #295: labeledStatement => ( #identifier# | case @ constantExpression | default ) '=' statement
    --> __________________
    --> #139: constantExpression => @ conditionalExpression
    -->     Type: shift
    -->     LA: #double# '&' '*' #uint# '+'
    -->     LA: #uchar# #float# '~' #short# '('
    -->     LA: '-' #ushort# '++' '--' '!'
    -->     LA: #int# #char# sizeof #string# #identifier#
    -->     LA: #long# #ulong#

** [FINAL] State #296: expressionStatement => [ expression ] (';') @
    --> __________________
    --> #318: statement => ( labeledStatement | compoundStatement | expressionStatement @ | selectionStatement | iterationStatement | jumpStatement )
    -->     Type: reduce
    -->     Reduce: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationStatement | jumpStatement )

** State #297: selectionStatement => ( if ('(') expression (')') statement [ else statement ] | switch @ ('(') expression (')') statement )
    --> __________________
    --> #319: selectionStatement => ( if ('(') expression (')') statement [ else statement ] | switch ('(') @ expression (')') statement )
    -->     Type: pass
    -->     LA: '('

** State #298: selectionStatement => ( if @ ('(') expression (')') statement [ else statement ] | switch ('(') expression (')') statement )
    --> __________________
    --> #320: selectionStatement => ( if ('(') @ expression (')') statement [ else statement ] | switch ('(') expression (')') statement )
    -->     Type: pass
    -->     LA: '('

** State #299: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for @ ('(') forCondition (')') statement )
    --> __________________
    --> #321: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') @ forCondition (')') statement )
    -->     Type: pass
    -->     LA: '('

** State #300: iterationStatement => ( while @ ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    --> __________________
    --> #322: iterationStatement => ( while ('(') @ expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    -->     Type: pass
    -->     LA: '('

** State #301: iterationStatement => ( while ('(') expression (')') statement | do @ statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    --> __________________
    --> #239: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationStatement | jumpStatement )
    -->     Type: shift
    -->     LA: '{' switch return continue while
    -->     LA: '(' #identifier# default case ';'
    -->     LA: '*' #long# goto #float# for
    -->     LA: #ulong# #int# break '-' '!'
    -->     LA: do '&' #char# '~' sizeof
    -->     LA: #string# '--' '++' #ushort# if
    -->     LA: #double# #short# '+' #uchar# #uint#

** State #302: postfixExpression => ( primaryExpression | postfixExpression @ ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    --> __________________
    --> #323: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' @ ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    -->     Type: move
    -->     LA: '->'
    --> __________________
    --> #324: postfixExpression => ( primaryExpression | postfixExpression ( ('[') @ expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    -->     Type: pass
    -->     LA: '['
    --> __________________
    --> #325: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') @ [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    -->     Type: pass
    -->     LA: '('
    --> __________________
    --> #326: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' @ | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    -->     Type: move
    -->     LA: '++'
    --> __________________
    --> #327: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' @ ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    -->     Type: move
    -->     LA: '--'
    --> __________________
    --> #328: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' @ | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    -->     Type: move
    -->     LA: '.'

** [FINAL] State #303: unaryExpression => ( postfixExpression @ | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    --> __________________
    --> #160: assignmentExpression => ( conditionalExpression | unaryExpression @ assignmentOperator assignmentExpression )
    -->     Type: reduce
    --> __________________
    --> #161: castExpression => ( ('(') typeName (')') castExpression | unaryExpression @ )
    -->     Type: reduce
    --> __________________
    --> #162: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression @ | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: reduce
    --> __________________
    --> #163: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression @ | ('(') typeName (')') ) )
    -->     Type: reduce
    --> __________________
    --> #162: unaryExpression => ( postfixExpression | ( '++' | '--' ) unaryExpression @ | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: reduce

** [FINAL] State #304: primaryExpression => ( #identifier# | constant @ | #string# | ('(') expression (')') )
    --> __________________
    --> #268: postfixExpression => ( primaryExpression @ | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    -->     Type: reduce

** State #305: andExpression => [ @ andExpression '&' ] equalityExpression
    --> __________________
    --> #329: equalityExpression => [ @ equalityExpression ( '==' | '!=' ) ] relationalExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #306: enumSpecifier => (enum) ( [ #identifier# ] ('{') enumeratorList @ [ (',') ] ('{') | #identifier# )
    --> __________________
    --> #330: enumSpecifier => (enum) ( [ #identifier# ] ('{') enumeratorList [ (',') ] ('{') @ | #identifier# )
    -->     Type: pass
    -->     LA: '{'
    --> __________________
    --> #331: enumSpecifier => (enum) ( [ #identifier# ] ('{') enumeratorList [ (',') @ ] ('{') | #identifier# )
    -->     Type: pass
    -->     LA: ','

** State #307: enumeratorList => [ enumeratorList @ (',') ] enumerator
    --> __________________
    --> #332: enumeratorList => [ enumeratorList (',') @ ] enumerator
    -->     Type: pass
    -->     LA: ','

** State #308: designator => ( '[' constantExpression ']' | '.' @ #identifier# )
    --> __________________
    --> #333: designator => ( '[' constantExpression ']' | '.' #identifier# @ )
    -->     Type: move
    -->     LA: #identifier#

** State #309: designator => ( '[' @ constantExpression ']' | '.' #identifier# )
    --> __________________
    --> #139: constantExpression => @ conditionalExpression
    -->     Type: shift
    -->     LA: #double# '&' '*' #uint# '+'
    -->     LA: #uchar# #float# '~' #short# '('
    -->     LA: '-' #ushort# '++' '--' '!'
    -->     LA: #int# #char# sizeof #string# #identifier#
    -->     LA: #long# #ulong#

** State #310: multiplicativeExpression => [ @ multiplicativeExpression ( '*' | '/' | '%' ) ] castExpression
    --> __________________
    --> #158: castExpression => @ ( ('(') typeName (')') castExpression | unaryExpression )
    -->     Type: shift
    -->     LA: #double# '&' '*' #uint# '+'
    -->     LA: #uchar# #float# '~' #short# '('
    -->     LA: '-' #ushort# '++' '--' '!'
    -->     LA: #int# #char# sizeof #string# #identifier#
    -->     LA: #long# #ulong#

** [FINAL] State #311: equalityExpression => [ equalityExpression ( '==' | '!=' ) ] relationalExpression @
    --> __________________
    --> #334: andExpression => [ andExpression '&' ] equalityExpression @
    -->     Type: reduce
    --> __________________
    --> #334: andExpression => [ andExpression '&' ] equalityExpression @
    -->     Type: reduce
    --> __________________
    --> #335: equalityExpression => [ equalityExpression @ ( '==' | '!=' ) ] relationalExpression
    -->     Type: recursion
    -->     LA: '==' '!='

** State #312: relationalExpression => [ relationalExpression @ ( '<' | '>' | '<=' | '>=' ) ] shiftExpression
    --> __________________
    --> #336: relationalExpression => [ relationalExpression ( '<' | '>' | '<=' | '>=' @ ) ] shiftExpression
    -->     Type: move
    -->     LA: '>='
    --> __________________
    --> #337: relationalExpression => [ relationalExpression ( '<' @ | '>' | '<=' | '>=' ) ] shiftExpression
    -->     Type: move
    -->     LA: '<'
    --> __________________
    --> #338: relationalExpression => [ relationalExpression ( '<' | '>' @ | '<=' | '>=' ) ] shiftExpression
    -->     Type: move
    -->     LA: '>'
    --> __________________
    --> #339: relationalExpression => [ relationalExpression ( '<' | '>' | '<=' @ | '>=' ) ] shiftExpression
    -->     Type: move
    -->     LA: '<='

** State #313: shiftExpression => [ shiftExpression ( '<<' | '>>' @ ) ] additiveExpression
    --> __________________
    --> #340: additiveExpression => [ @ additiveExpression ( '+' | '-' ) ] multiplicativeExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #314: shiftExpression => [ shiftExpression ( '<<' @ | '>>' ) ] additiveExpression
    --> __________________
    --> #340: additiveExpression => [ @ additiveExpression ( '+' | '-' ) ] multiplicativeExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** [FINAL] State #315: jumpStatement => ( goto #identifier# | continue | break | return [ expression ] ) (';') @
    --> __________________
    --> #341: statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationStatement | jumpStatement @ )
    -->     Type: reduce
    -->     Reduce: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationStatement | jumpStatement )

** State #316: jumpStatement => ( goto #identifier# @ | continue | break | return [ expression ] ) (';')
    --> __________________
    --> #315: jumpStatement => ( goto #identifier# | continue | break | return [ expression ] ) (';') @
    -->     Type: pass
    -->     LA: ';'

** State #317: labeledStatement => ( #identifier# | case constantExpression | default ) '=' @ statement
    --> __________________
    --> #239: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationStatement | jumpStatement )
    -->     Type: shift
    -->     LA: '{' switch return continue while
    -->     LA: '(' #identifier# default case ';'
    -->     LA: '*' #long# goto #float# for
    -->     LA: #ulong# #int# break '-' '!'
    -->     LA: do '&' #char# '~' sizeof
    -->     LA: #string# '--' '++' #ushort# if
    -->     LA: #double# #short# '+' #uchar# #uint#

** [FINAL] State #318: statement => ( labeledStatement | compoundStatement | expressionStatement @ | selectionStatement | iterationStatement | jumpStatement )
    --> __________________
    --> #231: blockItem => ( statement @ | declaration )
    -->     Type: reduce
    -->     Reduce: blockItem => @ ( statement | declaration )
    --> __________________
    --> #232: iterationStatement => ( while ('(') expression (')') statement | do statement @ while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while ('(') expression (')') statement | do @ statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    --> __________________
    --> #233: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement @ )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') @ statement )
    --> __________________
    --> #234: iterationStatement => ( while ('(') expression (')') statement @ | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while ('(') expression (')') @ statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    --> __________________
    --> #235: labeledStatement => ( #identifier# | case constantExpression | default ) '=' statement @
    -->     Type: reduce
    -->     Reduce: labeledStatement => ( #identifier# | case constantExpression | default ) '=' @ statement
    --> __________________
    --> #236: selectionStatement => ( if ('(') expression (')') statement [ else statement ] | switch ('(') expression (')') statement @ )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if ('(') expression (')') statement [ else statement ] | switch ('(') expression (')') @ statement )
    --> __________________
    --> #237: selectionStatement => ( if ('(') expression (')') statement @ [ else statement ] | switch ('(') expression (')') statement )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if ('(') expression (')') @ statement [ else statement ] | switch ('(') expression (')') statement )
    --> __________________
    --> #238: selectionStatement => ( if ('(') expression (')') statement [ else statement @ ] | switch ('(') expression (')') statement )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if ('(') expression (')') statement [ else @ statement ] | switch ('(') expression (')') statement )

** State #319: selectionStatement => ( if ('(') expression (')') statement [ else statement ] | switch ('(') @ expression (')') statement )
    --> __________________
    --> #267: expression => [ @ expression (',') ] assignmentExpression
    -->     Type: shift
    -->     LA: #double# '&' #identifier# #uint# '*'
    -->     LA: #long# #uchar# '+' #short# '~'
    -->     LA: '(' #ushort# '-' #int# '++'
    -->     LA: '--' '!' sizeof #string# #char#
    -->     LA: #ulong# #float#

** State #320: selectionStatement => ( if ('(') @ expression (')') statement [ else statement ] | switch ('(') expression (')') statement )
    --> __________________
    --> #267: expression => [ @ expression (',') ] assignmentExpression
    -->     Type: shift
    -->     LA: #double# '&' #identifier# #uint# '*'
    -->     LA: #long# #uchar# '+' #short# '~'
    -->     LA: '(' #ushort# '-' #int# '++'
    -->     LA: '--' '!' sizeof #string# #char#
    -->     LA: #ulong# #float#

** State #321: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') @ forCondition (')') statement )
    --> __________________
    --> #342: forCondition => @ ( forDeclaration | [ expression ] ) ';' [ forExpression ] ';' [ forExpression ]
    -->     Type: shift
    -->     LA: #uint# #uchar# sizeof '+' #short#
    -->     LA: #double# void '(' #ushort# static
    -->     LA: '++' struct '--' #string# '&'
    -->     LA: #identifier# volatile #char# '!' '-'
    -->     LA: #int# typedef #ulong# union float
    -->     LA: '~' #float# unsigned #long# '*'
    -->     LA: signed ';' enum int bool
    -->     LA: char long double short const
    -->     LA: auto extern register

** State #322: iterationStatement => ( while ('(') @ expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    --> __________________
    --> #267: expression => [ @ expression (',') ] assignmentExpression
    -->     Type: shift
    -->     LA: #double# '&' #identifier# #uint# '*'
    -->     LA: #long# #uchar# '+' #short# '~'
    -->     LA: '(' #ushort# '-' #int# '++'
    -->     LA: '--' '!' sizeof #string# #char#
    -->     LA: #ulong# #float#

** State #323: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' @ ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    --> __________________
    --> #343: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# @ | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    -->     Type: move
    -->     LA: #identifier#

** State #324: postfixExpression => ( primaryExpression | postfixExpression ( ('[') @ expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    --> __________________
    --> #267: expression => [ @ expression (',') ] assignmentExpression
    -->     Type: shift
    -->     LA: #double# '&' #identifier# #uint# '*'
    -->     LA: #long# #uchar# '+' #short# '~'
    -->     LA: '(' #ushort# '-' #int# '++'
    -->     LA: '--' '!' sizeof #string# #char#
    -->     LA: #ulong# #float#

** State #325: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') @ [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    --> __________________
    --> #344: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') @ | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    -->     Type: pass
    -->     LA: ')'
    --> __________________
    --> #345: argumentExpressionList => [ @ argumentExpressionList (',') ] assignmentExpression
    -->     Type: shift
    -->     LA: #double# '&' #identifier# #uint# '*'
    -->     LA: #long# #uchar# '+' #short# '~'
    -->     LA: '(' #ushort# '-' #int# '++'
    -->     LA: '--' '!' sizeof #string# #char#
    -->     LA: #ulong# #float#

** [FINAL] State #326: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' @ | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    --> __________________
    --> #302: postfixExpression => ( primaryExpression | postfixExpression @ ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    -->     Type: recursion
    -->     LA: '.' '->' '[' '--' '('
    -->     LA: '++'
    --> __________________
    --> #303: unaryExpression => ( postfixExpression @ | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: reduce

** [FINAL] State #327: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' @ ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    --> __________________
    --> #302: postfixExpression => ( primaryExpression | postfixExpression @ ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    -->     Type: recursion
    -->     LA: '.' '->' '[' '--' '('
    -->     LA: '++'
    --> __________________
    --> #303: unaryExpression => ( postfixExpression @ | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: reduce

** State #328: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' @ | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    --> __________________
    --> #343: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# @ | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    -->     Type: move
    -->     LA: #identifier#

** State #329: equalityExpression => [ @ equalityExpression ( '==' | '!=' ) ] relationalExpression
    --> __________________
    --> #346: relationalExpression => [ @ relationalExpression ( '<' | '>' | '<=' | '>=' ) ] shiftExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** [FINAL] State #330: enumSpecifier => (enum) ( [ #identifier# ] ('{') enumeratorList [ (',') ] ('{') @ | #identifier# )
    --> __________________
    --> #122: typeSpecifier => ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier @ | typedefName | typeSpecifier pointer )
    -->     Type: reduce
    -->     Reduce: typeSpecifier => @ ( void | char | short | int | long | float | double | signed | unsigned | bool | structOrUnionSpecifier | enumSpecifier | typedefName | typeSpecifier pointer )

** State #331: enumSpecifier => (enum) ( [ #identifier# ] ('{') enumeratorList [ (',') @ ] ('{') | #identifier# )
    --> __________________
    --> #330: enumSpecifier => (enum) ( [ #identifier# ] ('{') enumeratorList [ (',') ] ('{') @ | #identifier# )
    -->     Type: pass
    -->     LA: '{'

** State #332: enumeratorList => [ enumeratorList (',') @ ] enumerator
    --> __________________
    --> #153: enumerator => @ enumerationConstant [ ('=') constantExpression ]
    -->     Type: shift
    -->     LA: #identifier#

** [FINAL] State #333: designator => ( '[' constantExpression ']' | '.' #identifier# @ )
    --> __________________
    --> #347: designatorList => [ designatorList ] designator @
    -->     Type: reduce
    -->     Reduce: designatorList => [ @ designatorList ] designator
    --> __________________
    --> #347: designatorList => [ designatorList ] designator @
    -->     Type: reduce
    -->     Reduce: designatorList => [ designatorList @ ] designator

** [FINAL] State #334: andExpression => [ andExpression '&' ] equalityExpression @
    --> __________________
    --> #348: andExpression => [ andExpression @ '&' ] equalityExpression
    -->     Type: recursion
    -->     LA: '&'
    --> __________________
    --> #349: exclusiveOrExpression => [ exclusiveOrExpression '^' ] andExpression @
    -->     Type: reduce
    --> __________________
    --> #349: exclusiveOrExpression => [ exclusiveOrExpression '^' ] andExpression @
    -->     Type: reduce

** State #335: equalityExpression => [ equalityExpression @ ( '==' | '!=' ) ] relationalExpression
    --> __________________
    --> #350: equalityExpression => [ equalityExpression ( '==' | '!=' @ ) ] relationalExpression
    -->     Type: move
    -->     LA: '!='
    --> __________________
    --> #351: equalityExpression => [ equalityExpression ( '==' @ | '!=' ) ] relationalExpression
    -->     Type: move
    -->     LA: '=='

** State #336: relationalExpression => [ relationalExpression ( '<' | '>' | '<=' | '>=' @ ) ] shiftExpression
    --> __________________
    --> #352: shiftExpression => [ @ shiftExpression ( '<<' | '>>' ) ] additiveExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #337: relationalExpression => [ relationalExpression ( '<' @ | '>' | '<=' | '>=' ) ] shiftExpression
    --> __________________
    --> #352: shiftExpression => [ @ shiftExpression ( '<<' | '>>' ) ] additiveExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #338: relationalExpression => [ relationalExpression ( '<' | '>' @ | '<=' | '>=' ) ] shiftExpression
    --> __________________
    --> #352: shiftExpression => [ @ shiftExpression ( '<<' | '>>' ) ] additiveExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #339: relationalExpression => [ relationalExpression ( '<' | '>' | '<=' @ | '>=' ) ] shiftExpression
    --> __________________
    --> #352: shiftExpression => [ @ shiftExpression ( '<<' | '>>' ) ] additiveExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #340: additiveExpression => [ @ additiveExpression ( '+' | '-' ) ] multiplicativeExpression
    --> __________________
    --> #310: multiplicativeExpression => [ @ multiplicativeExpression ( '*' | '/' | '%' ) ] castExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** [FINAL] State #341: statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationStatement | jumpStatement @ )
    --> __________________
    --> #231: blockItem => ( statement @ | declaration )
    -->     Type: reduce
    -->     Reduce: blockItem => @ ( statement | declaration )
    --> __________________
    --> #232: iterationStatement => ( while ('(') expression (')') statement | do statement @ while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while ('(') expression (')') statement | do @ statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    --> __________________
    --> #233: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement @ )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') @ statement )
    --> __________________
    --> #234: iterationStatement => ( while ('(') expression (')') statement @ | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while ('(') expression (')') @ statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    --> __________________
    --> #235: labeledStatement => ( #identifier# | case constantExpression | default ) '=' statement @
    -->     Type: reduce
    -->     Reduce: labeledStatement => ( #identifier# | case constantExpression | default ) '=' @ statement
    --> __________________
    --> #236: selectionStatement => ( if ('(') expression (')') statement [ else statement ] | switch ('(') expression (')') statement @ )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if ('(') expression (')') statement [ else statement ] | switch ('(') expression (')') @ statement )
    --> __________________
    --> #237: selectionStatement => ( if ('(') expression (')') statement @ [ else statement ] | switch ('(') expression (')') statement )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if ('(') expression (')') @ statement [ else statement ] | switch ('(') expression (')') statement )
    --> __________________
    --> #238: selectionStatement => ( if ('(') expression (')') statement [ else statement @ ] | switch ('(') expression (')') statement )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if ('(') expression (')') statement [ else @ statement ] | switch ('(') expression (')') statement )

** State #342: forCondition => @ ( forDeclaration | [ expression ] ) ';' [ forExpression ] ';' [ forExpression ]
    --> __________________
    --> #182: forCondition => ( forDeclaration | [ expression ] ) ';' @ [ forExpression ] ';' [ forExpression ]
    -->     Type: move
    -->     LA: ';'
    --> __________________
    --> #353: forDeclaration => @ declarationSpecifiers [ initDeclaratorList ]
    -->     Type: shift
    -->     LA: union struct enum int bool
    -->     LA: char long float unsigned double
    -->     LA: void short const volatile #identifier#
    -->     LA: signed auto static extern typedef
    -->     LA: register
    --> __________________
    --> #267: expression => [ @ expression (',') ] assignmentExpression
    -->     Type: shift
    -->     LA: #double# '&' #identifier# #uint# '*'
    -->     LA: #long# #uchar# '+' #short# '~'
    -->     LA: '(' #ushort# '-' #int# '++'
    -->     LA: '--' '!' sizeof #string# #char#
    -->     LA: #ulong# #float#

** [FINAL] State #343: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# @ | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    --> __________________
    --> #302: postfixExpression => ( primaryExpression | postfixExpression @ ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    -->     Type: recursion
    -->     LA: '.' '->' '[' '--' '('
    -->     LA: '++'
    --> __________________
    --> #303: unaryExpression => ( postfixExpression @ | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: reduce

** [FINAL] State #344: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') @ | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    --> __________________
    --> #302: postfixExpression => ( primaryExpression | postfixExpression @ ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    -->     Type: recursion
    -->     LA: '.' '->' '[' '--' '('
    -->     LA: '++'
    --> __________________
    --> #303: unaryExpression => ( postfixExpression @ | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: reduce

** State #345: argumentExpressionList => [ @ argumentExpressionList (',') ] assignmentExpression
    --> __________________
    --> #108: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExpression )
    -->     Type: shift
    -->     LA: #float# #ulong# #long# #int# #char#
    -->     LA: #identifier# #string# sizeof '!' '--'
    -->     LA: '++' '-' #ushort# '(' #short#
    -->     LA: '~' '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #346: relationalExpression => [ @ relationalExpression ( '<' | '>' | '<=' | '>=' ) ] shiftExpression
    --> __________________
    --> #352: shiftExpression => [ @ shiftExpression ( '<<' | '>>' ) ] additiveExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** [FINAL] State #347: designatorList => [ designatorList ] designator @
    --> __________________
    --> #354: designation => designatorList @ '='
    -->     Type: reduce
    -->     Reduce: designation => @ designatorList '='
    --> __________________
    --> #355: designatorList => [ designatorList @ ] designator
    -->     Type: recursion
    -->     LA: '[' '.'

** State #348: andExpression => [ andExpression @ '&' ] equalityExpression
    --> __________________
    --> #356: andExpression => [ andExpression '&' @ ] equalityExpression
    -->     Type: move
    -->     LA: '&'

** [FINAL] State #349: exclusiveOrExpression => [ exclusiveOrExpression '^' ] andExpression @
    --> __________________
    --> #357: exclusiveOrExpression => [ exclusiveOrExpression @ '^' ] andExpression
    -->     Type: recursion
    -->     LA: '^'
    --> __________________
    --> #358: inclusiveOrExpression => [ inclusiveOrExpression '|' ] exclusiveOrExpression @
    -->     Type: reduce
    --> __________________
    --> #358: inclusiveOrExpression => [ inclusiveOrExpression '|' ] exclusiveOrExpression @
    -->     Type: reduce

** State #350: equalityExpression => [ equalityExpression ( '==' | '!=' @ ) ] relationalExpression
    --> __________________
    --> #346: relationalExpression => [ @ relationalExpression ( '<' | '>' | '<=' | '>=' ) ] shiftExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #351: equalityExpression => [ equalityExpression ( '==' @ | '!=' ) ] relationalExpression
    --> __________________
    --> #346: relationalExpression => [ @ relationalExpression ( '<' | '>' | '<=' | '>=' ) ] shiftExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #352: shiftExpression => [ @ shiftExpression ( '<<' | '>>' ) ] additiveExpression
    --> __________________
    --> #340: additiveExpression => [ @ additiveExpression ( '+' | '-' ) ] multiplicativeExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #353: forDeclaration => @ declarationSpecifiers [ initDeclaratorList ]
    --> __________________
    --> #7: declarationSpecifiers => [ @ declarationSpecifiers ] declarationSpecifier
    -->     Type: shift
    -->     LA: register typedef extern static auto
    -->     LA: signed #identifier# volatile const short
    -->     LA: void double unsigned float long
    -->     LA: char bool int enum struct
    -->     LA: union

** State #354: designation => designatorList @ '='
    --> __________________
    --> #359: designation => designatorList '=' @
    -->     Type: move
    -->     LA: '='

** State #355: designatorList => [ designatorList @ ] designator
    --> __________________
    --> #283: designator => @ ( '[' constantExpression ']' | '.' #identifier# )
    -->     Type: shift
    -->     LA: '[' '.'

** State #356: andExpression => [ andExpression '&' @ ] equalityExpression
    --> __________________
    --> #329: equalityExpression => [ @ equalityExpression ( '==' | '!=' ) ] relationalExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #357: exclusiveOrExpression => [ exclusiveOrExpression @ '^' ] andExpression
    --> __________________
    --> #360: exclusiveOrExpression => [ exclusiveOrExpression '^' @ ] andExpression
    -->     Type: move
    -->     LA: '^'

** [FINAL] State #358: inclusiveOrExpression => [ inclusiveOrExpression '|' ] exclusiveOrExpression @
    --> __________________
    --> #361: inclusiveOrExpression => [ inclusiveOrExpression @ '|' ] exclusiveOrExpression
    -->     Type: recursion
    -->     LA: '|'
    --> __________________
    --> #362: logicalAndExpression => [ logicalAndExpression '&&' ] inclusiveOrExpression @
    -->     Type: reduce
    --> __________________
    --> #362: logicalAndExpression => [ logicalAndExpression '&&' ] inclusiveOrExpression @
    -->     Type: reduce

** [FINAL] State #359: designation => designatorList '=' @
    --> __________________
    --> #363: initializerList => [ initializerList (',') ] [ designation @ ] initializer
    -->     Type: reduce
    -->     Reduce: initializerList => [ @ initializerList (',') ] [ designation ] initializer
    --> __________________
    --> #363: initializerList => [ initializerList (',') ] [ designation @ ] initializer
    -->     Type: reduce
    -->     Reduce: initializerList => [ initializerList (',') @ ] [ designation ] initializer

** State #360: exclusiveOrExpression => [ exclusiveOrExpression '^' @ ] andExpression
    --> __________________
    --> #305: andExpression => [ @ andExpression '&' ] equalityExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #361: inclusiveOrExpression => [ inclusiveOrExpression @ '|' ] exclusiveOrExpression
    --> __________________
    --> #364: inclusiveOrExpression => [ inclusiveOrExpression '|' @ ] exclusiveOrExpression
    -->     Type: move
    -->     LA: '|'

** [FINAL] State #362: logicalAndExpression => [ logicalAndExpression '&&' ] inclusiveOrExpression @
    --> __________________
    --> #365: logicalAndExpression => [ logicalAndExpression @ '&&' ] inclusiveOrExpression
    -->     Type: recursion
    -->     LA: '&&'
    --> __________________
    --> #366: logicalOrExpression => [ logicalOrExpression '||' ] logicalAndExpression @
    -->     Type: reduce
    --> __________________
    --> #366: logicalOrExpression => [ logicalOrExpression '||' ] logicalAndExpression @
    -->     Type: reduce

** State #363: initializerList => [ initializerList (',') ] [ designation @ ] initializer
    --> __________________
    --> #133: initializer => @ ( assignmentExpression | '{' initializerList [ (',') ] '}' )
    -->     Type: shift
    -->     LA: '{' #string# #float# '~' #ulong#
    -->     LA: #long# #int# '!' #char# sizeof
    -->     LA: #identifier# '--' '++' '-' #ushort#
    -->     LA: '(' #double# #short# '+' #uchar#
    -->     LA: '*' #uint# '&'

** State #364: inclusiveOrExpression => [ inclusiveOrExpression '|' @ ] exclusiveOrExpression
    --> __________________
    --> #279: exclusiveOrExpression => [ @ exclusiveOrExpression '^' ] andExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #365: logicalAndExpression => [ logicalAndExpression @ '&&' ] inclusiveOrExpression
    --> __________________
    --> #367: logicalAndExpression => [ logicalAndExpression '&&' @ ] inclusiveOrExpression
    -->     Type: move
    -->     LA: '&&'

** [FINAL] State #366: logicalOrExpression => [ logicalOrExpression '||' ] logicalAndExpression @
    --> __________________
    --> #368: conditionalExpression => logicalOrExpression @ [ '?' expression '=' conditionalExpression ]
    -->     Type: reduce
    --> __________________
    --> #369: logicalOrExpression => [ logicalOrExpression @ '||' ] logicalAndExpression
    -->     Type: recursion
    -->     LA: '||'

** State #367: logicalAndExpression => [ logicalAndExpression '&&' @ ] inclusiveOrExpression
    --> __________________
    --> #245: inclusiveOrExpression => [ @ inclusiveOrExpression '|' ] exclusiveOrExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** [FINAL] State #368: conditionalExpression => logicalOrExpression @ [ '?' expression '=' conditionalExpression ]
    --> __________________
    --> #370: conditionalExpression => logicalOrExpression [ '?' @ expression '=' conditionalExpression ]
    -->     Type: move
    -->     LA: '?'
    --> __________________
    --> #371: assignmentExpression => ( conditionalExpression @ | unaryExpression assignmentOperator assignmentExpression )
    -->     Type: reduce
    --> __________________
    --> #372: conditionalExpression => logicalOrExpression [ '?' expression '=' conditionalExpression @ ]
    -->     Type: reduce
    --> __________________
    --> #373: constantExpression => conditionalExpression @
    -->     Type: reduce
    -->     Reduce: constantExpression => @ conditionalExpression

** State #369: logicalOrExpression => [ logicalOrExpression @ '||' ] logicalAndExpression
    --> __________________
    --> #374: logicalOrExpression => [ logicalOrExpression '||' @ ] logicalAndExpression
    -->     Type: move
    -->     LA: '||'

** State #370: conditionalExpression => logicalOrExpression [ '?' @ expression '=' conditionalExpression ]
    --> __________________
    --> #267: expression => [ @ expression (',') ] assignmentExpression
    -->     Type: shift
    -->     LA: #double# '&' #identifier# #uint# '*'
    -->     LA: #long# #uchar# '+' #short# '~'
    -->     LA: '(' #ushort# '-' #int# '++'
    -->     LA: '--' '!' sizeof #string# #char#
    -->     LA: #ulong# #float#

** [FINAL] State #371: assignmentExpression => ( conditionalExpression @ | unaryExpression assignmentOperator assignmentExpression )
    --> __________________
    --> #375: argumentExpressionList => [ argumentExpressionList (',') ] assignmentExpression @
    -->     Type: reduce
    --> __________________
    --> #375: argumentExpressionList => [ argumentExpressionList (',') ] assignmentExpression @
    -->     Type: reduce
    --> __________________
    --> #376: assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator assignmentExpression @ )
    -->     Type: reduce
    --> __________________
    --> #377: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression @ ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: reduce
    -->     Reduce: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' @ ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #377: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression @ ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: reduce
    -->     Reduce: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList @ ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #378: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression @ | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    -->     Type: reduce
    -->     Reduce: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') @ [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    --> __________________
    --> #378: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression @ | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    -->     Type: reduce
    -->     Reduce: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList @ ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    --> __________________
    --> #379: expression => [ expression (',') ] assignmentExpression @
    -->     Type: reduce
    --> __________________
    --> #379: expression => [ expression (',') ] assignmentExpression @
    -->     Type: reduce
    --> __________________
    --> #380: forExpression => [ forExpression (',') ] assignmentExpression @
    -->     Type: reduce
    -->     Reduce: forExpression => [ @ forExpression (',') ] assignmentExpression
    --> __________________
    --> #380: forExpression => [ forExpression (',') ] assignmentExpression @
    -->     Type: reduce
    -->     Reduce: forExpression => [ forExpression (',') @ ] assignmentExpression
    --> __________________
    --> #381: initializer => ( assignmentExpression @ | '{' initializerList [ (',') ] '}' )
    -->     Type: reduce
    -->     Reduce: initializer => @ ( assignmentExpression | '{' initializerList [ (',') ] '}' )

** [FINAL] State #372: conditionalExpression => logicalOrExpression [ '?' expression '=' conditionalExpression @ ]
    --> __________________
    --> #371: assignmentExpression => ( conditionalExpression @ | unaryExpression assignmentOperator assignmentExpression )
    -->     Type: reduce
    --> __________________
    --> #372: conditionalExpression => logicalOrExpression [ '?' expression '=' conditionalExpression @ ]
    -->     Type: reduce
    --> __________________
    --> #373: constantExpression => conditionalExpression @
    -->     Type: reduce
    -->     Reduce: constantExpression => @ conditionalExpression

** [FINAL] State #373: constantExpression => conditionalExpression @
    --> __________________
    --> #382: designator => ( '[' constantExpression @ ']' | '.' #identifier# )
    -->     Type: reduce
    -->     Reduce: designator => ( '[' @ constantExpression ']' | '.' #identifier# )
    --> __________________
    --> #383: enumerator => enumerationConstant [ ('=') constantExpression @ ]
    -->     Type: reduce
    -->     Reduce: enumerator => enumerationConstant [ ('=') @ constantExpression ]
    --> __________________
    --> #384: labeledStatement => ( #identifier# | case constantExpression @ | default ) '=' statement
    -->     Type: reduce
    -->     Reduce: labeledStatement => ( #identifier# | case @ constantExpression | default ) '=' statement
    --> __________________
    --> #385: structDeclarator => ( declarator | [ declarator ] ('=') constantExpression @ )
    -->     Type: reduce
    -->     Reduce: structDeclarator => ( declarator | [ declarator ] ('=') @ constantExpression )

** State #374: logicalOrExpression => [ logicalOrExpression '||' @ ] logicalAndExpression
    --> __________________
    --> #209: logicalAndExpression => [ @ logicalAndExpression '&&' ] inclusiveOrExpression
    -->     Type: shift
    -->     LA: #ulong# #long# #identifier# #string# sizeof
    -->     LA: #char# #int# '!' '--' '++'
    -->     LA: '-' #ushort# '(' #short# '~'
    -->     LA: #float# '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** [FINAL] State #375: argumentExpressionList => [ argumentExpressionList (',') ] assignmentExpression @
    --> __________________
    --> #386: argumentExpressionList => [ argumentExpressionList @ (',') ] assignmentExpression
    -->     Type: recursion
    -->     LA: ','
    --> __________________
    --> #387: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList @ ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    -->     Type: reduce

** [FINAL] State #376: assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator assignmentExpression @ )
    --> __________________
    --> #375: argumentExpressionList => [ argumentExpressionList (',') ] assignmentExpression @
    -->     Type: reduce
    --> __________________
    --> #375: argumentExpressionList => [ argumentExpressionList (',') ] assignmentExpression @
    -->     Type: reduce
    --> __________________
    --> #376: assignmentExpression => ( conditionalExpression | unaryExpression assignmentOperator assignmentExpression @ )
    -->     Type: reduce
    --> __________________
    --> #377: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression @ ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: reduce
    -->     Reduce: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' @ ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #377: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression @ ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    -->     Type: reduce
    -->     Reduce: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList @ ] [ assignmentExpression ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #378: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression @ | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    -->     Type: reduce
    -->     Reduce: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') @ [ typeQualifierList ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    --> __________________
    --> #378: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression @ | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    -->     Type: reduce
    -->     Reduce: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList @ ] ( assignmentExpression | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    --> __________________
    --> #379: expression => [ expression (',') ] assignmentExpression @
    -->     Type: reduce
    --> __________________
    --> #379: expression => [ expression (',') ] assignmentExpression @
    -->     Type: reduce
    --> __________________
    --> #380: forExpression => [ forExpression (',') ] assignmentExpression @
    -->     Type: reduce
    -->     Reduce: forExpression => [ @ forExpression (',') ] assignmentExpression
    --> __________________
    --> #380: forExpression => [ forExpression (',') ] assignmentExpression @
    -->     Type: reduce
    -->     Reduce: forExpression => [ forExpression (',') @ ] assignmentExpression
    --> __________________
    --> #381: initializer => ( assignmentExpression @ | '{' initializerList [ (',') ] '}' )
    -->     Type: reduce
    -->     Reduce: initializer => @ ( assignmentExpression | '{' initializerList [ (',') ] '}' )

** State #377: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression @ ] | '*' ) ']' | '(' [ parameterTypeList ] ')' ) )
    --> __________________
    --> #119: directAbstractDeclarator => ( ('(') abstractDeclarator (')') | [ directAbstractDeclarator ] ( '[' ( [ typeQualifierList ] [ assignmentExpression ] | '*' ) ']' @ | '(' [ parameterTypeList ] ')' ) )
    -->     Type: move
    -->     LA: ']'

** State #378: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression @ | '*' ) (']') | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    --> __________________
    --> #142: directDeclarator => ( #identifier# | ('(') declarator (')') | directDeclarator ( ('[') [ typeQualifierList ] ( assignmentExpression | '*' ) (']') @ | ('(') ( parameterTypeList | [ identifierList ] ) (')') ) )
    -->     Type: pass
    -->     LA: ']'

** [FINAL] State #379: expression => [ expression (',') ] assignmentExpression @
    --> __________________
    --> #388: conditionalExpression => logicalOrExpression [ '?' expression @ '=' conditionalExpression ]
    -->     Type: reduce
    --> __________________
    --> #389: expression => [ expression @ (',') ] assignmentExpression
    -->     Type: recursion
    -->     LA: ','
    --> __________________
    --> #390: expressionStatement => [ expression @ ] (';')
    -->     Type: reduce
    -->     Reduce: expressionStatement => [ @ expression ] (';')
    --> __________________
    --> #391: forCondition => ( forDeclaration | [ expression @ ] ) ';' [ forExpression ] ';' [ forExpression ]
    -->     Type: reduce
    -->     Reduce: forCondition => @ ( forDeclaration | [ expression ] ) ';' [ forExpression ] ';' [ forExpression ]
    --> __________________
    --> #392: iterationStatement => ( while ('(') expression @ (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while ('(') @ expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    --> __________________
    --> #393: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression @ (')') ';' | for ('(') forCondition (')') statement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') @ expression (')') ';' | for ('(') forCondition (')') statement )
    --> __________________
    --> #394: jumpStatement => ( goto #identifier# | continue | break | return [ expression @ ] ) (';')
    -->     Type: reduce
    -->     Reduce: jumpStatement => ( goto #identifier# | continue | break | return @ [ expression ] ) (';')
    --> __________________
    --> #395: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression @ (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    -->     Type: reduce
    --> __________________
    --> #396: primaryExpression => ( #identifier# | constant | #string# | ('(') expression @ (')') )
    -->     Type: reduce
    -->     Reduce: primaryExpression => ( #identifier# | constant | #string# | ('(') @ expression (')') )
    --> __________________
    --> #397: selectionStatement => ( if ('(') expression (')') statement [ else statement ] | switch ('(') expression @ (')') statement )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if ('(') expression (')') statement [ else statement ] | switch ('(') @ expression (')') statement )
    --> __________________
    --> #398: selectionStatement => ( if ('(') expression @ (')') statement [ else statement ] | switch ('(') expression (')') statement )
    -->     Type: reduce
    -->     Reduce: selectionStatement => ( if ('(') @ expression (')') statement [ else statement ] | switch ('(') expression (')') statement )

** [FINAL] State #380: forExpression => [ forExpression (',') ] assignmentExpression @
    --> __________________
    --> #399: forCondition => ( forDeclaration | [ expression ] ) ';' [ forExpression @ ] ';' [ forExpression ]
    -->     Type: reduce
    -->     Reduce: forCondition => ( forDeclaration | [ expression ] ) ';' @ [ forExpression ] ';' [ forExpression ]
    --> __________________
    --> #400: forCondition => ( forDeclaration | [ expression ] ) ';' [ forExpression ] ';' [ forExpression @ ]
    -->     Type: reduce
    -->     Reduce: forCondition => ( forDeclaration | [ expression ] ) ';' [ forExpression ] ';' @ [ forExpression ]
    --> __________________
    --> #401: forExpression => [ forExpression @ (',') ] assignmentExpression
    -->     Type: recursion
    -->     LA: ','

** [FINAL] State #381: initializer => ( assignmentExpression @ | '{' initializerList [ (',') ] '}' )
    --> __________________
    --> #402: initDeclarator => declarator [ ('=') initializer @ ]
    -->     Type: reduce
    -->     Reduce: initDeclarator => declarator [ ('=') @ initializer ]
    --> __________________
    --> #403: initializerList => [ initializerList (',') ] [ designation ] initializer @
    -->     Type: reduce
    -->     Reduce: initializerList => [ @ initializerList (',') ] [ designation ] initializer
    --> __________________
    --> #403: initializerList => [ initializerList (',') ] [ designation ] initializer @
    -->     Type: reduce
    -->     Reduce: initializerList => [ initializerList (',') ] [ designation @ ] initializer
    --> __________________
    --> #403: initializerList => [ initializerList (',') ] [ designation ] initializer @
    -->     Type: reduce
    -->     Reduce: initializerList => [ initializerList (',') @ ] [ designation ] initializer

** State #382: designator => ( '[' constantExpression @ ']' | '.' #identifier# )
    --> __________________
    --> #404: designator => ( '[' constantExpression ']' @ | '.' #identifier# )
    -->     Type: move
    -->     LA: ']'

** [FINAL] State #383: enumerator => enumerationConstant [ ('=') constantExpression @ ]
    --> __________________
    --> #282: enumeratorList => [ enumeratorList (',') ] enumerator @
    -->     Type: reduce
    -->     Reduce: enumeratorList => [ @ enumeratorList (',') ] enumerator
    --> __________________
    --> #282: enumeratorList => [ enumeratorList (',') ] enumerator @
    -->     Type: reduce
    -->     Reduce: enumeratorList => [ enumeratorList (',') @ ] enumerator

** State #384: labeledStatement => ( #identifier# | case constantExpression @ | default ) '=' statement
    --> __________________
    --> #317: labeledStatement => ( #identifier# | case constantExpression | default ) '=' @ statement
    -->     Type: move
    -->     LA: '='

** [FINAL] State #385: structDeclarator => ( declarator | [ declarator ] ('=') constantExpression @ )
    --> __________________
    --> #102: structDeclaratorList => [ structDeclaratorList (',') ] structDeclarator @
    -->     Type: reduce
    -->     Reduce: structDeclaratorList => [ @ structDeclaratorList (',') ] structDeclarator
    --> __________________
    --> #102: structDeclaratorList => [ structDeclaratorList (',') ] structDeclarator @
    -->     Type: reduce
    -->     Reduce: structDeclaratorList => [ structDeclaratorList (',') @ ] structDeclarator

** State #386: argumentExpressionList => [ argumentExpressionList @ (',') ] assignmentExpression
    --> __________________
    --> #405: argumentExpressionList => [ argumentExpressionList (',') @ ] assignmentExpression
    -->     Type: pass
    -->     LA: ','

** State #387: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList @ ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    --> __________________
    --> #344: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') @ | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    -->     Type: pass
    -->     LA: ')'

** State #388: conditionalExpression => logicalOrExpression [ '?' expression @ '=' conditionalExpression ]
    --> __________________
    --> #406: conditionalExpression => logicalOrExpression [ '?' expression '=' @ conditionalExpression ]
    -->     Type: move
    -->     LA: '='

** State #389: expression => [ expression @ (',') ] assignmentExpression
    --> __________________
    --> #407: expression => [ expression (',') @ ] assignmentExpression
    -->     Type: pass
    -->     LA: ','

** State #390: expressionStatement => [ expression @ ] (';')
    --> __________________
    --> #296: expressionStatement => [ expression ] (';') @
    -->     Type: pass
    -->     LA: ';'

** State #391: forCondition => ( forDeclaration | [ expression @ ] ) ';' [ forExpression ] ';' [ forExpression ]
    --> __________________
    --> #182: forCondition => ( forDeclaration | [ expression ] ) ';' @ [ forExpression ] ';' [ forExpression ]
    -->     Type: move
    -->     LA: ';'

** State #392: iterationStatement => ( while ('(') expression @ (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    --> __________________
    --> #408: iterationStatement => ( while ('(') expression (')') @ statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    -->     Type: pass
    -->     LA: ')'

** State #393: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression @ (')') ';' | for ('(') forCondition (')') statement )
    --> __________________
    --> #409: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') @ ';' | for ('(') forCondition (')') statement )
    -->     Type: pass
    -->     LA: ')'

** State #394: jumpStatement => ( goto #identifier# | continue | break | return [ expression @ ] ) (';')
    --> __________________
    --> #315: jumpStatement => ( goto #identifier# | continue | break | return [ expression ] ) (';') @
    -->     Type: pass
    -->     LA: ';'

** State #395: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression @ (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    --> __________________
    --> #410: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') @ | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    -->     Type: pass
    -->     LA: ']'

** State #396: primaryExpression => ( #identifier# | constant | #string# | ('(') expression @ (')') )
    --> __________________
    --> #411: primaryExpression => ( #identifier# | constant | #string# | ('(') expression (')') @ )
    -->     Type: pass
    -->     LA: ')'

** State #397: selectionStatement => ( if ('(') expression (')') statement [ else statement ] | switch ('(') expression @ (')') statement )
    --> __________________
    --> #412: selectionStatement => ( if ('(') expression (')') statement [ else statement ] | switch ('(') expression (')') @ statement )
    -->     Type: pass
    -->     LA: ')'

** State #398: selectionStatement => ( if ('(') expression @ (')') statement [ else statement ] | switch ('(') expression (')') statement )
    --> __________________
    --> #413: selectionStatement => ( if ('(') expression (')') @ statement [ else statement ] | switch ('(') expression (')') statement )
    -->     Type: pass
    -->     LA: ')'

** State #399: forCondition => ( forDeclaration | [ expression ] ) ';' [ forExpression @ ] ';' [ forExpression ]
    --> __________________
    --> #213: forCondition => ( forDeclaration | [ expression ] ) ';' [ forExpression ] ';' @ [ forExpression ]
    -->     Type: move
    -->     LA: ';'

** [FINAL] State #400: forCondition => ( forDeclaration | [ expression ] ) ';' [ forExpression ] ';' [ forExpression @ ]
    --> __________________
    --> #248: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') forCondition @ (')') statement )
    -->     Type: reduce
    -->     Reduce: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' | for ('(') @ forCondition (')') statement )

** State #401: forExpression => [ forExpression @ (',') ] assignmentExpression
    --> __________________
    --> #414: forExpression => [ forExpression (',') @ ] assignmentExpression
    -->     Type: pass
    -->     LA: ','

** [FINAL] State #402: initDeclarator => declarator [ ('=') initializer @ ]
    --> __________________
    --> #101: initDeclaratorList => [ initDeclaratorList (',') ] initDeclarator @
    -->     Type: reduce
    -->     Reduce: initDeclaratorList => [ @ initDeclaratorList (',') ] initDeclarator
    --> __________________
    --> #101: initDeclaratorList => [ initDeclaratorList (',') ] initDeclarator @
    -->     Type: reduce
    -->     Reduce: initDeclaratorList => [ initDeclaratorList (',') @ ] initDeclarator

** [FINAL] State #403: initializerList => [ initializerList (',') ] [ designation ] initializer @
    --> __________________
    --> #415: initializer => ( assignmentExpression | '{' initializerList @ [ (',') ] '}' )
    -->     Type: reduce
    -->     Reduce: initializer => ( assignmentExpression | '{' @ initializerList [ (',') ] '}' )
    --> __________________
    --> #416: initializerList => [ initializerList @ (',') ] [ designation ] initializer
    -->     Type: recursion
    -->     LA: ','
    --> __________________
    --> #417: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList @ [ (',') ] ('}') )
    -->     Type: reduce

** [FINAL] State #404: designator => ( '[' constantExpression ']' @ | '.' #identifier# )
    --> __________________
    --> #347: designatorList => [ designatorList ] designator @
    -->     Type: reduce
    -->     Reduce: designatorList => [ @ designatorList ] designator
    --> __________________
    --> #347: designatorList => [ designatorList ] designator @
    -->     Type: reduce
    -->     Reduce: designatorList => [ designatorList @ ] designator

** State #405: argumentExpressionList => [ argumentExpressionList (',') @ ] assignmentExpression
    --> __________________
    --> #108: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExpression )
    -->     Type: shift
    -->     LA: #float# #ulong# #long# #int# #char#
    -->     LA: #identifier# #string# sizeof '!' '--'
    -->     LA: '++' '-' #ushort# '(' #short#
    -->     LA: '~' '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #406: conditionalExpression => logicalOrExpression [ '?' expression '=' @ conditionalExpression ]
    --> __________________
    --> #144: conditionalExpression => @ logicalOrExpression [ '?' expression '=' conditionalExpression ]
    -->     Type: shift
    -->     LA: #double# '&' '*' #uint# '+'
    -->     LA: #uchar# #float# '~' #short# '('
    -->     LA: '-' #ushort# '++' '--' '!'
    -->     LA: #int# #char# sizeof #string# #identifier#
    -->     LA: #long# #ulong#

** State #407: expression => [ expression (',') @ ] assignmentExpression
    --> __________________
    --> #108: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExpression )
    -->     Type: shift
    -->     LA: #float# #ulong# #long# #int# #char#
    -->     LA: #identifier# #string# sizeof '!' '--'
    -->     LA: '++' '-' #ushort# '(' #short#
    -->     LA: '~' '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #408: iterationStatement => ( while ('(') expression (')') @ statement | do statement while ('(') expression (')') ';' | for ('(') forCondition (')') statement )
    --> __________________
    --> #239: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationStatement | jumpStatement )
    -->     Type: shift
    -->     LA: '{' switch return continue while
    -->     LA: '(' #identifier# default case ';'
    -->     LA: '*' #long# goto #float# for
    -->     LA: #ulong# #int# break '-' '!'
    -->     LA: do '&' #char# '~' sizeof
    -->     LA: #string# '--' '++' #ushort# if
    -->     LA: #double# #short# '+' #uchar# #uint#

** State #409: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') @ ';' | for ('(') forCondition (')') statement )
    --> __________________
    --> #418: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' @ | for ('(') forCondition (')') statement )
    -->     Type: move
    -->     LA: ';'

** [FINAL] State #410: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') @ | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    --> __________________
    --> #302: postfixExpression => ( primaryExpression | postfixExpression @ ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    -->     Type: recursion
    -->     LA: '.' '->' '[' '--' '('
    -->     LA: '++'
    --> __________________
    --> #303: unaryExpression => ( postfixExpression @ | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: reduce

** [FINAL] State #411: primaryExpression => ( #identifier# | constant | #string# | ('(') expression (')') @ )
    --> __________________
    --> #268: postfixExpression => ( primaryExpression @ | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    -->     Type: reduce

** State #412: selectionStatement => ( if ('(') expression (')') statement [ else statement ] | switch ('(') expression (')') @ statement )
    --> __________________
    --> #239: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationStatement | jumpStatement )
    -->     Type: shift
    -->     LA: '{' switch return continue while
    -->     LA: '(' #identifier# default case ';'
    -->     LA: '*' #long# goto #float# for
    -->     LA: #ulong# #int# break '-' '!'
    -->     LA: do '&' #char# '~' sizeof
    -->     LA: #string# '--' '++' #ushort# if
    -->     LA: #double# #short# '+' #uchar# #uint#

** State #413: selectionStatement => ( if ('(') expression (')') @ statement [ else statement ] | switch ('(') expression (')') statement )
    --> __________________
    --> #239: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationStatement | jumpStatement )
    -->     Type: shift
    -->     LA: '{' switch return continue while
    -->     LA: '(' #identifier# default case ';'
    -->     LA: '*' #long# goto #float# for
    -->     LA: #ulong# #int# break '-' '!'
    -->     LA: do '&' #char# '~' sizeof
    -->     LA: #string# '--' '++' #ushort# if
    -->     LA: #double# #short# '+' #uchar# #uint#

** State #414: forExpression => [ forExpression (',') @ ] assignmentExpression
    --> __________________
    --> #108: assignmentExpression => @ ( conditionalExpression | unaryExpression assignmentOperator assignmentExpression )
    -->     Type: shift
    -->     LA: #float# #ulong# #long# #int# #char#
    -->     LA: #identifier# #string# sizeof '!' '--'
    -->     LA: '++' '-' #ushort# '(' #short#
    -->     LA: '~' '+' #uchar# '*' #uint#
    -->     LA: '&' #double#

** State #415: initializer => ( assignmentExpression | '{' initializerList @ [ (',') ] '}' )
    --> __________________
    --> #419: initializer => ( assignmentExpression | '{' initializerList [ (',') ] '}' @ )
    -->     Type: move
    -->     LA: '}'
    --> __________________
    --> #420: initializer => ( assignmentExpression | '{' initializerList [ (',') @ ] '}' )
    -->     Type: pass
    -->     LA: ','

** State #416: initializerList => [ initializerList @ (',') ] [ designation ] initializer
    --> __________________
    --> #421: initializerList => [ initializerList (',') @ ] [ designation ] initializer
    -->     Type: pass
    -->     LA: ','

** State #417: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList @ [ (',') ] ('}') )
    --> __________________
    --> #422: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') @ )
    -->     Type: pass
    -->     LA: '}'
    --> __________________
    --> #423: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') @ ] ('}') )
    -->     Type: pass
    -->     LA: ','

** [FINAL] State #418: iterationStatement => ( while ('(') expression (')') statement | do statement while ('(') expression (')') ';' @ | for ('(') forCondition (')') statement )
    --> __________________
    --> #258: statement => ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationStatement @ | jumpStatement )
    -->     Type: reduce
    -->     Reduce: statement => @ ( labeledStatement | compoundStatement | expressionStatement | selectionStatement | iterationStatement | jumpStatement )

** [FINAL] State #419: initializer => ( assignmentExpression | '{' initializerList [ (',') ] '}' @ )
    --> __________________
    --> #402: initDeclarator => declarator [ ('=') initializer @ ]
    -->     Type: reduce
    -->     Reduce: initDeclarator => declarator [ ('=') @ initializer ]
    --> __________________
    --> #403: initializerList => [ initializerList (',') ] [ designation ] initializer @
    -->     Type: reduce
    -->     Reduce: initializerList => [ @ initializerList (',') ] [ designation ] initializer
    --> __________________
    --> #403: initializerList => [ initializerList (',') ] [ designation ] initializer @
    -->     Type: reduce
    -->     Reduce: initializerList => [ initializerList (',') ] [ designation @ ] initializer
    --> __________________
    --> #403: initializerList => [ initializerList (',') ] [ designation ] initializer @
    -->     Type: reduce
    -->     Reduce: initializerList => [ initializerList (',') @ ] [ designation ] initializer

** State #420: initializer => ( assignmentExpression | '{' initializerList [ (',') @ ] '}' )
    --> __________________
    --> #419: initializer => ( assignmentExpression | '{' initializerList [ (',') ] '}' @ )
    -->     Type: move
    -->     LA: '}'

** State #421: initializerList => [ initializerList (',') @ ] [ designation ] initializer
    --> __________________
    --> #133: initializer => @ ( assignmentExpression | '{' initializerList [ (',') ] '}' )
    -->     Type: shift
    -->     LA: '{' #string# #float# '~' #ulong#
    -->     LA: #long# #int# '!' #char# sizeof
    -->     LA: #identifier# '--' '++' '-' #ushort#
    -->     LA: '(' #double# #short# '+' #uchar#
    -->     LA: '*' #uint# '&'
    --> __________________
    --> #219: designation => @ designatorList '='
    -->     Type: shift
    -->     LA: '[' '.'

** [FINAL] State #422: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') @ )
    --> __________________
    --> #302: postfixExpression => ( primaryExpression | postfixExpression @ ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') )
    -->     Type: recursion
    -->     LA: '.' '->' '[' '--' '('
    -->     LA: '++'
    --> __________________
    --> #303: unaryExpression => ( postfixExpression @ | ( '++' | '--' ) unaryExpression | unaryOperator castExpression | sizeof ( unaryExpression | ('(') typeName (')') ) )
    -->     Type: reduce

** State #423: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') @ ] ('}') )
    --> __________________
    --> #422: postfixExpression => ( primaryExpression | postfixExpression ( ('[') expression (']') | ('(') [ argumentExpressionList ] (')') | ( '.' | '->' ) #identifier# | '++' | '--' ) | ('(') typeName (')') ('{') initializerList [ (',') ] ('}') @ )
    -->     Type: pass
    -->     LA: '}'
